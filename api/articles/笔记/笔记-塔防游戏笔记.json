{"title":"塔防游戏笔记","uid":"c540c9b9a4bdc44ea456b40df3a36e31","slug":"笔记/笔记-塔防游戏笔记","date":"2024-06-25T20:47:56.000Z","updated":"2024-10-18T20:48:56.123Z","comments":true,"path":"api/articles/笔记/笔记-塔防游戏笔记.json","keywords":null,"cover":"\\img\\post\\笔记\\笔记-塔防游戏笔记\\cover.png","content":"<h1 id=\"介绍\"><a class=\"markdownIt-Anchor\" href=\"#介绍\"></a> 🔖介绍</h1>\n<p>该笔记主要参考于 v佬 <a href=\"https://space.bilibili.com/25864506\">Voidmatrix</a> 的 <a href=\"https://www.bilibili.com/cheese/play/ep749443\">C++双人塔防游戏开发</a> 课程。</p>\n<p>该笔记的复刻项目源码为：<a href=\"https://github.com/zExNocs/TowerDefenseGame_Copybat\">点击传送</a></p>\n<p>本笔记的内容排序可能不会按照课程排序，而是根据内容进行分类归纳。<br />\n本笔记主要由下面几个部分组成：<br />\n一. 游戏引擎 (框架解剖)<br />\n二. 塔防游戏用到的技术/技巧 (技术解剖)<br />\n三. 游戏开发用到的设计模式 (技术解剖)<br />\n四. 笔者的内容扩展 (框架扩展)<br />\n五. 开发步骤 (实践步骤)<br />\n六. 补充</p>\n<p>本笔记从各个游戏组成成分进行解剖，并介绍其功能和作用，然后开始介绍游戏开发的步骤。<br />\n此外，本笔记额外添加了课程中没有的一些功能，例如对可绘制平面的封装来实现前景和背景分离。</p>\n<hr />\n<h1 id=\"一-游戏引擎\"><a class=\"markdownIt-Anchor\" href=\"#一-游戏引擎\"></a> 一. 游戏引擎</h1>\n<h2 id=\"基本框架介绍\"><a class=\"markdownIt-Anchor\" href=\"#基本框架介绍\"></a> 基本框架介绍</h2>\n<p>正如所有游戏设计那样。</p>\n<h2 id=\"数据文件的概念和设计\"><a class=\"markdownIt-Anchor\" href=\"#数据文件的概念和设计\"></a> 数据文件的概念和设计</h2>\n<p>在本游戏设计中，数据文件主要有三个方面组成，分别是地图文件<code>map.csv</code>、配置文件<code>config.json</code>和关卡文件<code>level.json</code>组成。</p>\n<h3 id=\"1-地图文件\"><a class=\"markdownIt-Anchor\" href=\"#1-地图文件\"></a> 1. 地图文件</h3>\n<p>地图文件是使用 <code>csv</code> 格式储存的二维网格数组文件。<br />\n每个单元格储存每个瓦片<code>tile</code>的数据，每个数据格式为 <code>terrian\\decoration\\direction\\special</code>，都为整型：</p>\n<ul>\n<li><code>terrian</code>：地形瓦片。表示地形图片的 <code>id</code> 索引。</li>\n<li><code>decoration</code>：装饰瓦片。表示装饰图片的 <code>id</code> 索引。如果没有装饰，则为 <code>-1</code>。</li>\n<li><code>direction</code>：行进路线。表示敌人的行进路线，上下左右。如果不进行走路，则为 <code>-1</code>。</li>\n<li><code>special</code>：特殊标志。例如防守位点、敌人生成点。如果没有特殊标志，则为 <code>-1</code>。\n<ul>\n<li>在本游戏中，特殊标志约定 <code>0</code> 为防守位点，<code>1 ~ 8</code> 表示敌人不同的生成点。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-配置文件\"><a class=\"markdownIt-Anchor\" href=\"#2-配置文件\"></a> 2. 配置文件</h3>\n<p>配置文件是使用 <code>json</code> 储存各种数据和角色数值的文件。<br />\n其整体是一个对象类，储存了三大对象类，分别是 <code>basic</code> 基础数据、<code>player</code> 玩家数据和 <code>enemy</code> 敌人数据。</p>\n<p>其形式和层级如下：</p>\n<ul>\n<li><code>basic</code>：对象型。储存基础数据。\n<ul>\n<li><code>window_title</code>：字符串型。窗口标题。</li>\n<li><code>window_width</code>：整型。窗口宽度。</li>\n<li><code>window_height</code>：整形。窗口高度。</li>\n</ul>\n</li>\n<li><code>player</code>：对象型。储存玩家的属性。\n<ul>\n<li><code>speed</code>：整型。玩家的速度，以 <code>单位</code> 作为单位，表示一个网格，即每秒移动网格的距离。</li>\n<li><code>normal_attack_interval</code>：浮点型。普通攻击的时间间隔。</li>\n<li><code>normal_attack_damage</code>：整型。普通攻击的伤害值。</li>\n<li><code>skill_interval</code>：浮点型。技能的攻击间隔。</li>\n<li><code>skill_damage</code>：整型。技能的伤害值。</li>\n</ul>\n</li>\n<li><code>tower</code>：对象型。储存各类防御塔的属性。防御塔可以升级。\n<ul>\n<li><code>&#123;typeName&#125;</code>：对象型。储存该类防御塔的各种属性。\n<ul>\n<li><code>interval</code>：浮点型的数组。表示各个等级时的攻击间隔。</li>\n<li><code>damage</code>：整型的数组。表示各个等级的伤害。</li>\n<li><code>view_range</code>：整型的数组。表示各个等级的视野范围，以 <code>单位</code> 作为单位。</li>\n<li><code>cost</code>：整型的数组。表示卖出的价格。</li>\n<li><code>upgrade_cost</code>：整型的数组。表示升级到下一个等级需要的花费。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>enemy</code>：对象型。储存各类敌人的属性。\n<ul>\n<li><code>&#123;typeName&#125;</code>：对象型。储存各类敌人的属性。\n<ul>\n<li><code>hp</code>：整型。敌人的血量。</li>\n<li><code>speed</code>：浮点型。敌人的速度。</li>\n<li><code>damage</code>：整型。敌人的攻击伤害。</li>\n<li><code>reward_ratio</code>：浮点型。奖励的概率。</li>\n<li><code>recover_interval</code>：整型。恢复的间隔。</li>\n<li><code>recover_range</code>：整型。恢复的范围。以<code>单位</code>为单位。<code>-1</code> 表示不进行恢复。</li>\n<li><code>recover_intensity</code>：整型。恢复的强度。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-关卡文件\"><a class=\"markdownIt-Anchor\" href=\"#3-关卡文件\"></a> 3. 关卡文件</h3>\n<p>关卡文件是使用 <code>json</code> 文件来控制每波次的怪物生成。<br />\n其整体是一个数组类型，该数组类型储存成员为对象类型，表示每个波次的数据。数组的长度就是波次的数量。</p>\n<p>对于每个波次，其形式如下：</p>\n<ul>\n<li><code>interval</code>：整型。表示距离上个波次结束后多少秒开始本次本波次。</li>\n<li><code>rewards</code>：整型。表示完成这个波次后奖励的金币数。</li>\n<li><code>spawn_list</code>：对象型的数组型。表示一个生成事件。\n<ul>\n<li><code>interval</code>：整型。表示距离上个生成事件过后多少秒后开始生成。</li>\n<li><code>point</code>：整型。表示怪物的出生点位置。</li>\n<li><code>enemy</code>：字符串型。表示该生成事件生成的怪物类型。</li>\n</ul>\n</li>\n</ul>\n<p>注意每个波次的结束指的是该波次生成的所有敌人被清空。每个波次的开始是在上个波次结束后经过 <code>interval</code> 秒开始。<br />\n而每个生成事件的结束是该生成事件生成完敌人后结束，而不是该敌人死亡后结束。每个生成事件的开始是在上个生成事件结束后经过 <code>interval</code> 秒后开始。</p>\n<h2 id=\"引擎框架类及其作用\"><a class=\"markdownIt-Anchor\" href=\"#引擎框架类及其作用\"></a> 引擎框架类及其作用</h2>\n<h3 id=\"1-gamemanager-游戏管理器\"><a class=\"markdownIt-Anchor\" href=\"#1-gamemanager-游戏管理器\"></a> 1. GameManager 游戏管理器</h3>\n<h4 id=\"介绍-2\"><a class=\"markdownIt-Anchor\" href=\"#介绍-2\"></a> 介绍</h4>\n<p>是游戏的主要引擎。用于初始化窗口、渲染器，并启动游戏的主循环。</p>\n<p><em>在我的项目中称之为 <code>BaseEngine</code> 而不是 <code>GameManager</code>。</em></p>\n<h4 id=\"方法和功能\"><a class=\"markdownIt-Anchor\" href=\"#方法和功能\"></a> 方法和功能</h4>\n<hr />\n<h1 id=\"二-塔防游戏中用到的技术技巧\"><a class=\"markdownIt-Anchor\" href=\"#二-塔防游戏中用到的技术技巧\"></a> 二. 塔防游戏中用到的技术/技巧</h1>\n<h2 id=\"1-洋流图预烘焙寻路\"><a class=\"markdownIt-Anchor\" href=\"#1-洋流图预烘焙寻路\"></a> 1. 洋流图预烘焙寻路</h2>\n<p>游戏中有很多寻路算法，例如比较常用的 A* 寻路算法。但是如果在塔防游戏中使用 A* 算法可能会出现一些无法预料的情况。<br />\n在塔防游戏中，我们更偏向于让敌人按照指定的路径(静态的)来寻走而不是动态生成的。这种静态的路径我们可以称之为 <strong>洋流图</strong>。<br />\n洋流图将会在<strong>地图缓存</strong>的阶段进行生成，这个过程可以称之为预烘焙。</p>\n<p>在该项目中，我们使用 <code>Route</code> 类来储存洋流图。<br />\n<code>Route</code> 类本质上是一个 从某个点出发(出发点) 所经历所有点的路径 类，是一种点的容器/索引类。<br />\n在地图缓存阶段，我们将所有怪物刷怪点为出发点来储存这些路径，并<br />\n初始化 <code>Route</code>类注意的点：</p>\n<ul>\n<li>何时停止储存\n<ul>\n<li>超过地图边界</li>\n<li>点重复储存</li>\n<li>到达终点</li>\n<li>下一个目标点是非移动点</li>\n</ul>\n</li>\n<li>循环路径处理\n<ul>\n<li>在原视频中，实际上并没有对循环路径进行更多的处理。如果真的会出现循环路径，</li>\n</ul>\n</li>\n</ul>\n<p>为什么要用 <code>Route</code> 类而不直接用 <code>Tile</code> 类来进行控制敌人移动呢？<br />\n<s>在该项目中，我个人更偏向于直接使用 <code>Tile</code> 类来直接控制敌人移动。</s><br />\n实际上，如果使用 <code>Route</code> 类而不直接使用 <code>Tile</code> 类一方面可以实现 <code>Tile</code> 类与 敌人类的解耦，而让与移动更有关联的 <code>Route</code> 类 来和敌人类进行关联。另一方面可以在不同的<code>Tile</code>类型或者直接手动编写<code>Route</code>来实现多层地图路径，也就是说在一条路径中即使经历过重复的点，可以在不同经历次数中有不同的移动方向。</p>\n<hr />\n<h1 id=\"三-游戏开发用到的设计模式\"><a class=\"markdownIt-Anchor\" href=\"#三-游戏开发用到的设计模式\"></a> 三. 游戏开发用到的设计模式</h1>\n<h2 id=\"1-单例设计模式\"><a class=\"markdownIt-Anchor\" href=\"#1-单例设计模式\"></a> 1. 单例设计模式</h2>\n<h3 id=\"介绍-3\"><a class=\"markdownIt-Anchor\" href=\"#介绍-3\"></a> 介绍</h3>\n<p>单例设计模式(Singleton Design Pattern)指的是使用该设计模式的类在进程中最多只有一个实例。<br />\n其最大的特点就是不允许外部来创建该类的实例，而是提供一个内部静态函数/方法来间接创建该类：</p>\n<ol>\n<li><strong>构造函数</strong> 的访问类型是私有的(private)或者保护的(protected)。</li>\n<li>赋值构造函数和 <code>=</code> 符号重载为 <code>delete</code> 的方式来防止子类使用基类的构造。</li>\n</ol>\n<p><em>具体内容可以参考 <code>VoidGameSpace</code> 这个文章: <a href=\"https://www.voidgame.space/articles/yang12342/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/\">点击跳转</a></em></p>\n<h3 id=\"游戏开发中使用样例\"><a class=\"markdownIt-Anchor\" href=\"#游戏开发中使用样例\"></a> 游戏开发中使用样例</h3>\n<p>一般游戏开发中的各种 <code>Manager</code> 会使用单例设计模式来实现。<br />\n可以使用 模板 + 继承 的方式实现各个衍生的 <code>Manager</code> 返回其指定的类而不是其基类。</p>\n<hr />\n<h1 id=\"四-笔者的内容扩展\"><a class=\"markdownIt-Anchor\" href=\"#四-笔者的内容扩展\"></a> 四. 笔者的内容扩展</h1>\n<p>除了课程中讲述的基础内容外，结合之前我大作业的经历以及对游戏引擎的理解 <s>(和对优雅实现的追求)</s>，我本人使用了下面的方法对该游戏项目进行了进一步扩展：</p>\n<h2 id=\"1-使用智能指针管理内存\"><a class=\"markdownIt-Anchor\" href=\"#1-使用智能指针管理内存\"></a> 1. 使用智能指针管理内存</h2>\n<h2 id=\"2-背景与前景分离\"><a class=\"markdownIt-Anchor\" href=\"#2-背景与前景分离\"></a> 2. 背景与前景分离</h2>\n<h2 id=\"3-游戏引擎类的虚函数\"><a class=\"markdownIt-Anchor\" href=\"#3-游戏引擎类的虚函数\"></a> 3. 游戏引擎类的虚函数</h2>\n<h2 id=\"4-使用观察者设计模式设计所有可更新-可绘制对象\"><a class=\"markdownIt-Anchor\" href=\"#4-使用观察者设计模式设计所有可更新-可绘制对象\"></a> 4. 使用观察者设计模式设计所有可更新、可绘制对象</h2>\n<p>与课程中的内容不同的是，我并不是将各自的 <code>Manager</code> 类直接在主循环的数据更新操作中一一调用进行更新，而是使用 <code>Updatable</code>、<code>Renderable</code> 接口和在引擎中定义该接口的容器来进行统一更新。而各自的 <code>Manager</code> 类进行的操作是在引擎类的接口容器中添加或删除自己管理的对象。</p>\n<p>该做法的优点是选择让底层代码去贴合高层代码（先确定高层代码的需求，是一种多态性的实现），降低了高层代码对底层代码的依赖性，增加了灵活性、可维护性和可测试性，也增加了引擎的可扩展性。</p>\n<p>该做法基于的思想是使用 <strong>观察者设计模式</strong>，其基本思想如下：</p>\n<p>观察者设计模式的本质实际上是一种观察者的容器，每当事件触发时就通知容器中的所有观察者进行更新。</p>\n<p>所有互动游戏都是时间性模拟的(游戏引擎架构（第二版）)。主循环中的数据更新部分就是一种基于时间对可更新对象进行更新数据的操作，大部分可更新对象都是随着时间自动进行更新的，那么就相当于这些可更新对象属于一种观察者，而被观察的事件是时间，即每当时间进行流动的时候（或者说是流动一定的时间后）进行更新。</p>\n<p>基于上述的理念，我将游戏主循环中的“数据更新”理解成 “因为时间进行流动，所以要对这些对象进行更新”，因此就有了这种将时间作为观察对象进行数据更新的观察者模型：当到达一定的时间后 (<code>1000 / FPS</code>毫秒)，通知所有观察者。而对于这些根据时间进行自动更新的对象来说，被通知的动作就是更新 <code>on_update()</code>。</p>\n<p>一般来说这些基于时间进行更新的对象包括正在移动的对象、主动更新的对象、计时器等。<br />\n除了基于时间进行更新的对象以外还有一些被动更新的对象，例如被其他对象杀死的对象、等待用户输入处理的对象等。</p>\n<p>此外，几乎所有的渲染都是根据数据进行绘制的，因此所有物体的渲染也可以被视为一种观察者模型，观察者是所有可绘制的对象，而被观察的事件是数据更新。即每次数据更新都需要通知物体进行渲染。</p>\n<p>综上所述，所有基于时间进行更新的对象是一种观察者模型，其观察的事件是时间；所有可绘制的对象是一种观察者模型，其观察的事件是数据更新。</p>\n<h2 id=\"5-将渲染功能丢给瓦片\"><a class=\"markdownIt-Anchor\" href=\"#5-将渲染功能丢给瓦片\"></a> 5. 将渲染功能丢给瓦片</h2>\n<p>与课程中 <code>Tile</code> 结构体只是储存数据不同，我使用</p>\n<hr />\n<h1 id=\"五-开发步骤\"><a class=\"markdownIt-Anchor\" href=\"#五-开发步骤\"></a> 五. 开发步骤</h1>\n<h2 id=\"1-构造基础的游戏框架-gamemanager类\"><a class=\"markdownIt-Anchor\" href=\"#1-构造基础的游戏框架-gamemanager类\"></a> 1. 构造基础的游戏框架 (<code>GameManager</code>类)：</h2>\n<ul>\n<li>初始化 <code>SDL</code> 组件，创建相关窗口、渲染器，并分析可能发生的错误。</li>\n<li>创建主循环函数。</li>\n</ul>\n<hr />\n<h1 id=\"六-补充\"><a class=\"markdownIt-Anchor\" href=\"#六-补充\"></a> 六. 补充：</h1>\n<h2 id=\"1-sdl-有关内容\"><a class=\"markdownIt-Anchor\" href=\"#1-sdl-有关内容\"></a> 1. SDL 有关内容</h2>\n<p>参考 <a href=\"/post/%E7%AC%94%E8%AE%B0%2F%E7%AC%94%E8%AE%B0-SDL%E7%9B%B8%E5%85%B3\">这篇笔记</a>。</p>\n<h2 id=\"2-cjson-有关内容\"><a class=\"markdownIt-Anchor\" href=\"#2-cjson-有关内容\"></a> 2. cJSON 有关内容</h2>\n<p><code>cJSON</code> 主要是包含 <code>cJSON</code> 结构体。<br />\n<code>cJSON</code> 结构体是一个类似于双向链表的树形结构，使用<code>next</code> 和 <code>prev</code> 指针指向相同层的前后数据，使用 <code>child</code> 指针指向下一层的数据(对象类型的子数据或者数组类型的成员，统称为子节点)。</p>\n<p>因为 <code>cJSON</code> 是使用c语言进行编写，所以其是一个面向过程的类型，不具有成员函数/方法。</p>\n<h3 id=\"cjson-结构体变量\"><a class=\"markdownIt-Anchor\" href=\"#cjson-结构体变量\"></a> &gt; cJSON 结构体变量</h3>\n<ul>\n<li><code>int type</code>：该节点的数据类型。\n<ul>\n<li><code>cJSON_Invalid</code>：不合理的类型</li>\n<li><code>cJSON_False</code>：布尔<code>false</code> 类型</li>\n<li><code>cJSON_True</code>：布尔<code>true</code> 类型</li>\n<li><code>cJSON_NULL</code>：<code>null</code> 类型</li>\n<li><code>cJSON_Number</code>：数字类型</li>\n<li><code>cJSON_String</code>：字符串类型</li>\n<li><code>cJSON_Array</code>：数组类型</li>\n<li><code>cJSON_Object</code>：对象类型</li>\n<li><code>cJSON_Raw</code>：<code>raw json</code>，生 <code>json</code> 类型</li>\n</ul>\n</li>\n<li><code>char* string</code>：如果该节点是一个内部节点，那么该变量储存该节点的名字。</li>\n<li><code>char* valuestring</code>：如果该节点是字符串类型或者<code>raw json</code>，那么该变量储存该字符串。</li>\n<li><code>int valueint</code>：如果该节点是数字的整型类型，那么该变量储存该整型。</li>\n<li><code>double valuedouble</code>：如果该节点是数字的浮点类型，那么该变量储存该浮点型。</li>\n<li><code>cJSON* next</code>：如果该节点是某个<strong>对象类型的子数据</strong> 或者 <strong>数组类型的成员</strong>，那么该变量指向下一个节点。</li>\n<li><code>cJSON* prev</code>：如果该节点是某个<strong>对象类型的子数据</strong> 或者 <strong>数组类型的成员</strong>，那么该变量指向上一个节点。</li>\n<li><code>cJSON* child</code>：如果节点是 <strong>对象类型</strong> 或者 <strong>数组类型</strong>，那么该变量指向其子节点。</li>\n</ul>\n<h3 id=\"cjson-函数\"><a class=\"markdownIt-Anchor\" href=\"#cjson-函数\"></a> &gt; cJSON 函数</h3>\n<ul>\n<li><code>cJSON* cJSON_Parse(char* str)</code>：将字符串<code>str</code>解析成 <code>cJSON</code> 类并返回该<strong>对象类型</strong>的指针。</li>\n<li><code>cJSON* cJSON_GetObjectItem(cJSON* object, char* string)</code>：返回<strong>对象类型</strong><code>object</code>中名字为 <code>string</code> 子数据。</li>\n</ul>\n<h3 id=\"cjson-宏定义\"><a class=\"markdownIt-Anchor\" href=\"#cjson-宏定义\"></a> &gt; cJSON 宏定义</h3>\n<ul>\n<li><code>#define cJSON_ArrayForEach(cJSON* element, cJSON* array)</code>：遍历<strong>数组类型</strong><code>array</code>的所有成员作为<code>element</code>。</li>\n</ul>\n<p>一般使用下面的代码来读取一个 <code>.json</code> 文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打开文件</span></span><br><span class=\"line\"><span class=\"function\">std::ifstream <span class=\"title\">file</span><span class=\"params\">(<span class=\"string\">&quot;文件名.json&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!file.<span class=\"built_in\">good</span>()) &#123; 报错 + 退出 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用stringstream来读取整个字符串</span></span><br><span class=\"line\">std::stringstream str_stream;</span><br><span class=\"line\">str_stream &lt;&lt; file.<span class=\"built_in\">rdbuf</span>();</span><br><span class=\"line\">file.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解析</span></span><br><span class=\"line\">cJSON* root = <span class=\"built_in\">cJSON_Parse</span>(str_stream.<span class=\"built_in\">str</span>().<span class=\"built_in\">c_str</span>());</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-项目创建和环境搭建\"><a class=\"markdownIt-Anchor\" href=\"#3-项目创建和环境搭建\"></a> 3. 项目创建和环境搭建</h2>\n<h3 id=\"下载相关库\"><a class=\"markdownIt-Anchor\" href=\"#下载相关库\"></a> 下载相关库</h3>\n<p><em>选择带 <code>VC</code> 的包下载</em></p>\n<ul>\n<li><a href=\"https://github.com/libsdl-org/SDL\">SDL 本体</a></li>\n<li><a href=\"https://github.com/libsdl-org/SDL_ttf\">SDL_ttf 文字渲染</a></li>\n<li><a href=\"https://github.com/libsdl-org/SDL_image\">SDL_image 图片渲染</a></li>\n<li><a href=\"https://github.com/libsdl-org/SDL_mixer\">SDL_mixer 音媒体</a></li>\n<li><a href=\"https://www.ferzkopp.net/wordpress/2016/01/02/sdl_gfx-sdl2_gfx/\">SDL_gfx 图形绘制</a></li>\n<li><a href=\"https://github.com/DaveGamble/cJSON\">cJSON</a></li>\n</ul>\n<h3 id=\"导入库\"><a class=\"markdownIt-Anchor\" href=\"#导入库\"></a> 导入库</h3>\n<p>在项目根目录中新增 <code>thirdparty</code> 文件夹，将下载的库解压放入其中。</p>\n<p>使用相对路径将库添加到项目中：<br />\n右键选择相应的解决方案资源管理器，如本项目中的 <code>TowerrDefenseGame_Copybat</code>，选择 <code>属性</code>：</p>\n<ul>\n<li>导入头文件：依次点击 <code>C/C++ → 常规 → 附加包含目录 → &lt;编辑...&gt; → 新行</code>，输入 <code>..\\thirdparty\\&lt;相关库&gt;\\include</code>。</li>\n<li>导入静态链接器：\n<ul>\n<li>目录：依次点击 <code>链接器 → 常规 → 附加库目录 → &lt;编辑...&gt; → 新行</code>，输入 <code>..\\thirdparty\\&lt;相关库&gt;\\lib\\x64</code></li>\n<li>输入：依次点击 <code>链接器 → 输入 → 附加依赖项 → &lt;编辑...&gt;</code>，输入所有 <code>thirdparty\\&lt;相关库&gt;\\lib\\x64</code> 路径下所有后缀 <code>.lib</code> 的文件名和后缀。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SDL2.lib</span><br><span class=\"line\">SDL2main.lib</span><br><span class=\"line\">SDL2_ttf.lib</span><br><span class=\"line\">SDL2_mixer.lib</span><br><span class=\"line\">SDL2_image.lib</span><br><span class=\"line\">SDL2_gfx.lib</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>导入动态链接器：将动态链接器 <code>dll后缀文件</code> 复制到相应的解决方案目录下。</li>\n<li>导入源码库：将源码库的 <code>.c</code> 文件直接拖拽到 <code>解决方案资源管理器 &gt; 解决方案 &gt; 源文件</code> 中。</li>\n</ul>\n","feature":false,"text":"这是关于 Voidmatrix 塔防游戏课程笔记。...","permalink":"/post/笔记/笔记-塔防游戏笔记","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"笔记","slug":"笔记","count":10,"path":"api/categories/笔记.json"}],"tags":[{"name":"Game Engine","slug":"Game-Engine","count":1,"path":"api/tags/Game-Engine.json"},{"name":"SDL","slug":"SDL","count":2,"path":"api/tags/SDL.json"},{"name":"CPP","slug":"CPP","count":2,"path":"api/tags/CPP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 🔖介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E\"><span class=\"toc-text\"> 一. 游戏引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 基本框架介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\"> 数据文件的概念和设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9C%B0%E5%9B%BE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\"> 1. 地图文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\"> 2. 配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%85%B3%E5%8D%A1%E6%96%87%E4%BB%B6\"><span class=\"toc-text\"> 3. 关卡文件</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\"> 引擎框架类及其作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-gamemanager-%E6%B8%B8%E6%88%8F%E7%AE%A1%E7%90%86%E5%99%A8\"><span class=\"toc-text\"> 1. GameManager 游戏管理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D-2\"><span class=\"toc-text\"> 介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%92%8C%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\"> 方法和功能</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\"> 二. 塔防游戏中用到的技术&#x2F;技巧</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%B4%8B%E6%B5%81%E5%9B%BE%E9%A2%84%E7%83%98%E7%84%99%E5%AF%BB%E8%B7%AF\"><span class=\"toc-text\"> 1. 洋流图预烘焙寻路</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 三. 游戏开发用到的设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\"> 1. 单例设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D-3\"><span class=\"toc-text\"> 介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B\"><span class=\"toc-text\"> 游戏开发中使用样例</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E7%AC%94%E8%80%85%E7%9A%84%E5%86%85%E5%AE%B9%E6%89%A9%E5%B1%95\"><span class=\"toc-text\"> 四. 笔者的内容扩展</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98\"><span class=\"toc-text\"> 1. 使用智能指针管理内存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%83%8C%E6%99%AF%E4%B8%8E%E5%89%8D%E6%99%AF%E5%88%86%E7%A6%BB\"><span class=\"toc-text\"> 2. 背景与前景分离</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\"> 3. 游戏引擎类的虚函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%89%80%E6%9C%89%E5%8F%AF%E6%9B%B4%E6%96%B0-%E5%8F%AF%E7%BB%98%E5%88%B6%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\"> 4. 使用观察者设计模式设计所有可更新、可绘制对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%B0%86%E6%B8%B2%E6%9F%93%E5%8A%9F%E8%83%BD%E4%B8%A2%E7%BB%99%E7%93%A6%E7%89%87\"><span class=\"toc-text\"> 5. 将渲染功能丢给瓦片</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94-%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\"> 五. 开发步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%9E%84%E9%80%A0%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6-gamemanager%E7%B1%BB\"><span class=\"toc-text\"> 1. 构造基础的游戏框架 (GameManager类)：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD-%E8%A1%A5%E5%85%85\"><span class=\"toc-text\"> 六. 补充：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-sdl-%E6%9C%89%E5%85%B3%E5%86%85%E5%AE%B9\"><span class=\"toc-text\"> 1. SDL 有关内容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-cjson-%E6%9C%89%E5%85%B3%E5%86%85%E5%AE%B9\"><span class=\"toc-text\"> 2. cJSON 有关内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cjson-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F\"><span class=\"toc-text\"> &gt; cJSON 结构体变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cjson-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\"> &gt; cJSON 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cjson-%E5%AE%8F%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\"> &gt; cJSON 宏定义</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\"> 3. 项目创建和环境搭建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%85%B3%E5%BA%93\"><span class=\"toc-text\"> 下载相关库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E5%BA%93\"><span class=\"toc-text\"> 导入库</span></a></li></ol></li></ol></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"SDL","uid":"359ddc0f0d8ca8ada4d26ac9b618d2df","slug":"笔记/笔记-SDL相关","date":"2024-07-01T16:05:30.000Z","updated":"2024-10-18T20:49:10.123Z","comments":true,"path":"api/articles/笔记/笔记-SDL相关.json","keywords":null,"cover":"\\img\\post\\笔记\\笔记-SDL相关\\cover.png","text":"关于SDL库相关的常用的类和接口的笔记。...","permalink":"/post/笔记/笔记-SDL相关","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"笔记","slug":"笔记","count":10,"path":"api/categories/笔记.json"}],"tags":[{"name":"SDL","slug":"SDL","count":2,"path":"api/tags/SDL.json"},{"name":"CPP","slug":"CPP","count":2,"path":"api/tags/CPP.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"feature":false},"next_post":{"title":"如何提交文章到VoidGameSpace上","uid":"f6a638c0d2b2761842a94c4b2e02a042","slug":"随笔/随笔-如何提交文章到VoidGameSpace上","date":"2024-05-28T14:06:44.000Z","updated":"2024-10-19T00:34:49.424Z","comments":true,"path":"api/articles/随笔/随笔-如何提交文章到VoidGameSpace上.json","keywords":null,"cover":"\\img\\post\\随笔\\随笔-如何提交文章到VoidGameSpace上\\cover.png","text":"关于如果提交文章到VoidGameSpace论坛上的git教程。...","permalink":"/post/随笔/随笔-如何提交文章到VoidGameSpace上","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"随笔","slug":"随笔","count":5,"path":"api/categories/随笔.json"}],"tags":[{"name":"VoidGameSpace","slug":"VoidGameSpace","count":1,"path":"api/tags/VoidGameSpace.json"},{"name":"Hexo","slug":"Hexo","count":2,"path":"api/tags/Hexo.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"feature":false}}