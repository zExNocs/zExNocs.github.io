{"title":"数据结构-二叉搜索树 BST","uid":"d887fe0c72dd8bd0586b67fecb09745c","slug":"笔记/算法和数据结构/数据结构/二叉搜索树","date":"2024-05-24T12:00:06.000Z","updated":"2025-10-30T16:36:48.446Z","comments":true,"path":"api/articles/笔记/算法和数据结构/数据结构/二叉搜索树.json","keywords":null,"cover":"img/post/笔记/算法和数据结构/数据结构/二叉搜索树/cover.png","content":"<p><a href=\"%E7%AC%94%E8%AE%B0%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%88%AA\">&lt;返回算法与数据结构导航</a></p>\n<hr />\n<h1 id=\"一-二叉搜索树的定义和-adt\"><a class=\"markdownIt-Anchor\" href=\"#一-二叉搜索树的定义和-adt\"></a> 一. 二叉搜索树的定义和 ADT</h1>\n<p>二叉搜索树是一个储存(key,value)值到节点的二叉树，并满足下面的性质：</p>\n<table>\n<thead>\n<tr>\n<th>性质</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对于任意一个内部节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>，拥有左子节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 和 右子节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span>，满足 <code>key(l) &lt;= key(v) &lt;= key(r)</code></td>\n</tr>\n<tr>\n<td>对于任意一个节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>，其左边子树节点的所有值都比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 小，右边子树节点的所有值都比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 大</td>\n</tr>\n<tr>\n<td>二叉搜索树的中序遍历(inorder traversal)返回的数组一定是根据key升序的</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"1-二叉搜索树的主要操作和初步实现方法\"><a class=\"markdownIt-Anchor\" href=\"#1-二叉搜索树的主要操作和初步实现方法\"></a> 1. 二叉搜索树的主要操作和初步实现方法</h2>\n<p>设二叉搜索树的高为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span>。对于平衡二叉树来说，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>=</mo><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">h = \\log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th>函数</th>\n<th>说明</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">查找</td>\n<td><code>search(Key): Value</code></td>\n<td>与当前节点储存的<code>key</code>比较：<br>如果等于就返回该值<br>如果比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">key</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 小则查找左节点<br>如果比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">key</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> 大则查找右节点<br>如果为空(或叶节点)，则返回 <code>null</code></td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入</td>\n<td><code>insert(Key, Value)</code></td>\n<td>类似于查找的方式找到合适的位置进行插入，作为新的叶节点</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除</td>\n<td><code>remove(Key): Value</code></td>\n<td>类似于查找的方式找到相应的节点，分为下面四个情况：<br>1. 没有找到该节点，此时返回 <code>null</code><br>2. 该节点是叶节点，直接删除并返回该节点并返回该节点的值<br>3. 节点具有一个子节点，将该子节点替换到被删除节点的位置<br>4. 节点具有两个子节点：<br><span style=\"margin-left: 20px\">i. 此时根据树的中序遍历找到当前 <code>key</code> 的下一个 <code>key</code> 节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> (称之为中序后继)<br><span style=\"margin-left: 20px\">ii. 使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 替代该节点<br><span style=\"margin-left: 20px\">iii. 同删除步骤尝试删除 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>，直到不符合被删除的节点具有两个子节点为止</td>\n<td><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>h</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(h)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-平衡二叉树balanced-trees\"><a class=\"markdownIt-Anchor\" href=\"#2-平衡二叉树balanced-trees\"></a> 2. 平衡二叉树(Balanced Trees)</h2>\n<p>平衡二叉树的任何节点的左子树和右子树高度最多相差 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<p>平衡二叉树的高度 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>=</mo><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">h = \\log(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"3-二叉树的旋转\"><a class=\"markdownIt-Anchor\" href=\"#3-二叉树的旋转\"></a> 3. 二叉树的旋转</h2>\n<p>一般使用旋转的方法让二叉搜索树逐步变成平衡二叉树。</p>\n<h3 id=\"i-一次旋转\"><a class=\"markdownIt-Anchor\" href=\"#i-一次旋转\"></a> i. 一次旋转</h3>\n<p>一次旋转适合三个高度节点之间呈现类似于 <code>\\</code> 或者 <code>/</code> 的直线型，也就是中间高度的节点是中间值的情况。</p>\n<p>此时可以将 <code>\\</code> 或者 <code>/</code> 旋转成 <code>^</code>。</p>\n<p>旋转的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>根据子节点的位置又分为左旋转和右旋转。</p>\n<h4 id=\"a-左旋转\"><a class=\"markdownIt-Anchor\" href=\"#a-左旋转\"></a> a. 左旋转</h4>\n<p>左旋转是旋转当前节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 和其右节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>，因此要求右节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 不为空。</p>\n<p>其主要有两个步骤：</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>伪代码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. 将右节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 的左节点变成节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 的新右节点 (给予左节点)</td>\n<td><code>V.right = R.left</code></td>\n</tr>\n<tr>\n<td>2. 将右节点的左节点变成该节点 (交换节点位置)</td>\n<td><code>R.left = V</code></td>\n</tr>\n<tr>\n<td>3. 将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 的父节点相应位置修改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>；或者修改 <code>root</code></td>\n<td><code>parent(V).left/right = R</code><br><code>root = R</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"b-右旋转\"><a class=\"markdownIt-Anchor\" href=\"#b-右旋转\"></a> b. 右旋转</h4>\n<p>右旋转是旋转当前节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 和其左节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>，因此要求左节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 不为空。</p>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>伪代码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1. 将左节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> 的右节点变成节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 的新左节点 (给予右节点)</td>\n<td><code>V.left = L.right</code></td>\n</tr>\n<tr>\n<td>2. 将左节点的右节点变成该节点 (交换节点位置)</td>\n<td><code>L.right = V</code></td>\n</tr>\n<tr>\n<td>3. 将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 的父节点相应位置修改为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>；或者修改 <code>root</code></td>\n<td><code>parent(V).left/right = L</code><br><code>root = L</code></td>\n</tr>\n</tbody>\n</table>\n<img src=\"/img/post/笔记/算法和数据结构/数据结构/二叉搜索树/平衡二叉树旋转.png\" alt=\"右旋转示意图\" width=\"500\">\n<h3 id=\"ii-二次旋转\"><a class=\"markdownIt-Anchor\" href=\"#ii-二次旋转\"></a> ii. 二次旋转</h3>\n<p>诸如图中的 <code>&gt;</code> 和 <code>&lt;</code> 形无法直接进行一次旋转。例如，将 <code>&gt;</code> 进行左旋转会变成 <code>&lt;</code>。</p>\n<p>此时需要将 <code>&gt;</code> 和 <code>&lt;</code> 形旋转成 <code>\\</code> 或者 <code>/</code> 形，就同上述一次旋转了。</p>\n<img src=\"/img/post/笔记/算法和数据结构/数据结构/二叉搜索树/平衡二叉树二次旋转.png\" alt=\"右旋转示意图\" width=\"500\">\n<h1 id=\"二-二叉搜索树-cdt\"><a class=\"markdownIt-Anchor\" href=\"#二-二叉搜索树-cdt\"></a> 二. 二叉搜索树 CDT</h1>\n<h2 id=\"1-avl-树\"><a class=\"markdownIt-Anchor\" href=\"#1-avl-树\"></a> 1. AVL 树</h2>\n<p>// todo</p>\n<hr />\n<p><a href=\"%E7%AC%94%E8%AE%B0%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%88%AA/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C%E6%AC%A1%E6%97%8B%E8%BD%AC.png\">&lt;返回算法与数据结构导航</a></p>\n","feature":false,"text":"有关二叉搜索树的CDT和部分ADT实现，例如AVL树。...","permalink":"/post/笔记/算法和数据结构/数据结构/二叉搜索树","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"笔记-数据结构","slug":"笔记-数据结构","count":7,"path":"api/categories/笔记-数据结构.json"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","count":9,"path":"api/tags/Data-Structures.json"},{"name":"Tree","slug":"Tree","count":2,"path":"api/tags/Tree.json"},{"name":"Binary Tree","slug":"Binary-Tree","count":2,"path":"api/tags/Binary-Tree.json"},{"name":"Binary Search Tree","slug":"Binary-Search-Tree","count":1,"path":"api/tags/Binary-Search-Tree.json"},{"name":"BST","slug":"BST","count":1,"path":"api/tags/BST.json"},{"name":"AVL Tree","slug":"AVL-Tree","count":1,"path":"api/tags/AVL-Tree.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C-adt\"><span class=\"toc-text\"> 一. 二叉搜索树的定义和 ADT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C%E5%92%8C%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\"> 1. 二叉搜索树的主要操作和初步实现方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91balanced-trees\"><span class=\"toc-text\"> 2. 平衡二叉树(Balanced Trees)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\"> 3. 二叉树的旋转</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#i-%E4%B8%80%E6%AC%A1%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\"> i. 一次旋转</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#a-%E5%B7%A6%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\"> a. 左旋转</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#b-%E5%8F%B3%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\"> b. 右旋转</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ii-%E4%BA%8C%E6%AC%A1%E6%97%8B%E8%BD%AC\"><span class=\"toc-text\"> ii. 二次旋转</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-cdt\"><span class=\"toc-text\"> 二. 二叉搜索树 CDT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-avl-%E6%A0%91\"><span class=\"toc-text\"> 1. AVL 树</span></a></li></ol></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"qq":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/cgi-bin/qm/qr?k=_glZz5Xy8An6DaliL38ZBfl7QhJGB_z9"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"算法基础理论和定义","uid":"2de2788f125fd3108d2350b3554e8f62","slug":"笔记/算法和数据结构/算法/算法基础理论和定义","date":"2024-05-24T12:00:08.000Z","updated":"2025-10-31T09:42:26.920Z","comments":true,"path":"api/articles/笔记/算法和数据结构/算法/算法基础理论和定义.json","keywords":null,"cover":"img/post/笔记/算法和数据结构/算法/算法基础理论和定义/cover.png","text":"有关算法的通用基础理论的笔记。包括启发式算法的经典问题例子介绍。...","permalink":"/post/笔记/算法和数据结构/算法/算法基础理论和定义","photos":[],"count_time":{"symbolsCount":607,"symbolsTime":"1 mins."},"categories":[{"name":"笔记-算法","slug":"笔记-算法","count":5,"path":"api/categories/笔记-算法.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":5,"path":"api/tags/Algorithm.json"},{"name":"Heuristics","slug":"Heuristics","count":1,"path":"api/tags/Heuristics.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"qq":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/cgi-bin/qm/qr?k=_glZz5Xy8An6DaliL38ZBfl7QhJGB_z9"}}}},"feature":false},"next_post":{"title":"数据结构-映射 Map","uid":"e0bbb840c83f55fe9b80bf1823d58d81","slug":"笔记/算法和数据结构/数据结构/映射map","date":"2024-05-24T12:00:05.000Z","updated":"2025-10-30T16:37:03.800Z","comments":true,"path":"api/articles/笔记/算法和数据结构/数据结构/映射map.json","keywords":null,"cover":"img/post/笔记/算法和数据结构/数据结构/映射map/cover.png","text":"有关映射 map 的笔记。包括其 CDT 和部分 ADT 实现，例如基于哈希表的哈希映射。...","permalink":"/post/笔记/算法和数据结构/数据结构/映射map","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"笔记-数据结构","slug":"笔记-数据结构","count":7,"path":"api/categories/笔记-数据结构.json"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","count":9,"path":"api/tags/Data-Structures.json"},{"name":"Map","slug":"Map","count":1,"path":"api/tags/Map.json"},{"name":"Hash Table","slug":"Hash-Table","count":1,"path":"api/tags/Hash-Table.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"qq":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/cgi-bin/qm/qr?k=_glZz5Xy8An6DaliL38ZBfl7QhJGB_z9"}}}},"feature":false}}