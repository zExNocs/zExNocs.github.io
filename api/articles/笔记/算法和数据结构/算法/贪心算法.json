{"title":"算法-贪心算法","uid":"b71aeb72416b4ad218769c37ddf1fec8","slug":"笔记/算法和数据结构/算法/贪心算法","date":"2024-05-24T12:00:10.000Z","updated":"2025-10-30T16:37:22.506Z","comments":true,"path":"api/articles/笔记/算法和数据结构/算法/贪心算法.json","keywords":null,"cover":"/img/post/笔记/算法和数据结构/算法/贪心算法/cover.jpg","content":"<p><a href=\"%E7%AC%94%E8%AE%B0%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%88%AA\">&lt;返回算法与数据结构导航</a></p>\n<hr />\n<h1 id=\"一-介绍\"><a class=\"markdownIt-Anchor\" href=\"#一-介绍\"></a> 一. 介绍</h1>\n<p>贪心(Greedy)算法是一种常见的启发式算法，其主要思想是做出短期内看起来最好的决定，而不考虑未来的策略。</p>\n<p>一些贪心算法可以得到最优解，例如解决最小生成树(Minimal Spanning Tree, MST)的算法。而大部分贪心算法无法给出最优解，但是可以给出接近最优的解。</p>\n<h1 id=\"二-贪心算法解决的问题\"><a class=\"markdownIt-Anchor\" href=\"#二-贪心算法解决的问题\"></a> 二. 贪心算法解决的问题</h1>\n<h2 id=\"1-最小生成树问题minimal-spanning-tre-mst\"><a class=\"markdownIt-Anchor\" href=\"#1-最小生成树问题minimal-spanning-tre-mst\"></a> 1. 最小生成树问题(Minimal Spanning Tre, MST)</h2>\n<p>问题输入：联通的、有边权值的无向图(connected, undirected, weighted graph)。<br />\n问题输出：一棵树，仅使用图中存在的边连接图中所有顶点，并且边权重的和是最小的。</p>\n<h3 id=\"a-prim-算法\"><a class=\"markdownIt-Anchor\" href=\"#a-prim-算法\"></a> a. Prim 算法</h3>\n<p>Prim 算法是一种贪心算法，其核心思想是从一个顶点开始，逐步将与当前树相连的边中权值最小的边加入树中，直到包含所有顶点为止，可视为一种“加点法”。</p>\n<p>实现思路：</p>\n<ol>\n<li>选择任意顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></li>\n<li>选择对外可以连接到的所有的点中最小的那个边，并将边加入到 MST中，将点加入到内部的点中</li>\n<li>是否全部连接，如果没有则返回步骤 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>。通过已连接的边个数判断，即 边的个数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">e = n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n</ol>\n<p>算法实现：</p>\n<ol>\n<li>初始化数组 <code>value[n] = inf</code>，数组大小为点的个数，表示表示内部点对未连接的点边权的最小值；初始化连接边的个数<code>m = 0</code></li>\n<li>随机选择一个点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></li>\n<li>使<code>value[M] = 0</code>，并根据 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 连接的所有边 <code>(M,V)</code> 更新 <code>value</code> 数组</li>\n<li>找到 <code>value[v] != 0</code> 中最小的点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>，使 <code>value[V] = 0</code>，<code>m++</code></li>\n<li>跟 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 一样根据 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 连接的所有边 <code>(V,U)</code> 更新 <code>value</code> 数组。</li>\n<li>判断是否所有的点已经连通，即 <code>(m - 1) == n</code>，如果没有则返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span></span></span></span></li>\n</ol>\n<p>其中步骤 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 的伪代码为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value[M] = 0              # 因为已经被连接，所以更新为0</span><br><span class=\"line\">forall e in edge(M)</span><br><span class=\"line\">  v = e.v                 # 获取边连接的另一个点</span><br><span class=\"line\">  if(e.value &lt; value[v])  # 根据边权值更新对外连接点的大小</span><br><span class=\"line\">    value[v] = e.value </span><br></pre></td></tr></table></figure>\n<h3 id=\"b-kruskal-算法\"><a class=\"markdownIt-Anchor\" href=\"#b-kruskal-算法\"></a> b. Kruskal 算法</h3>\n<p>Kruskal 算法是一种贪心算法，其核心思想是将图中的所有边按权值从小到大排序，然后依次选择边，如果添加的边不会形成环，则将其加入最小生成树中，直至生成树包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">V-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边（其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 是顶点数），可视为一种“加边法”。</p>\n<p>其中判断是否会形成环可以使用 并查集(Union-find Disjoint Sets) 来判断。</p>\n<p>实现思路：</p>\n<ol>\n<li>将边按权值从小到大排序</li>\n<li>选择当前最小的边，判断边的两个点是否已经联通(并查集判断是否是同一个根节点)</li>\n<li>如果没有联通，则将这个边加入答案，并将这两个点加入同一个并查集中</li>\n<li>如果联通，则跳过这个边</li>\n<li>是否已经包含 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">V-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边，如果没有则返回 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span></li>\n</ol>\n<hr />\n<p><a href=\"%E7%AC%94%E8%AE%B0%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%BC%E8%88%AA\">&lt;返回算法与数据结构导航</a></p>\n","feature":false,"text":"有关贪心算法的介绍和其解决的问题样例，例如最小生成树的 Prim 算法。...","permalink":"/post/笔记/算法和数据结构/算法/贪心算法","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"笔记-算法","slug":"笔记-算法","count":5,"path":"api/categories/笔记-算法.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":5,"path":"api/tags/Algorithm.json"},{"name":"Greedy","slug":"Greedy","count":1,"path":"api/tags/Greedy.json"},{"name":"Minimal Spanning Tre","slug":"Minimal-Spanning-Tre","count":1,"path":"api/tags/Minimal-Spanning-Tre.json"},{"name":"Prim Algorithm","slug":"Prim-Algorithm","count":1,"path":"api/tags/Prim-Algorithm.json"},{"name":"Kruskal Algorithm","slug":"Kruskal-Algorithm","count":1,"path":"api/tags/Kruskal-Algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 一. 介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\"> 二. 贪心算法解决的问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98minimal-spanning-tre-mst\"><span class=\"toc-text\"> 1. 最小生成树问题(Minimal Spanning Tre, MST)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-prim-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> a. Prim 算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-kruskal-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> b. Kruskal 算法</span></a></li></ol></li></ol></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"算法-简单动态规划","uid":"5c601e076c464576a9ec4bb975f50ec5","slug":"笔记/算法和数据结构/算法/简单动态规划","date":"2024-05-24T12:00:11.000Z","updated":"2025-10-31T09:10:08.437Z","comments":true,"path":"api/articles/笔记/算法和数据结构/算法/简单动态规划.json","keywords":null,"cover":"img/post/笔记/算法和数据结构/算法/简单动态规划/cover.png","text":"有关动态规划的介绍和性质，以及简单的动态规划问题和方法。...","permalink":"/post/笔记/算法和数据结构/算法/简单动态规划","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"笔记-算法","slug":"笔记-算法","count":5,"path":"api/categories/笔记-算法.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":5,"path":"api/tags/Algorithm.json"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","count":1,"path":"api/tags/Dynamic-Programming.json"},{"name":"DP","slug":"DP","count":1,"path":"api/tags/DP.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"feature":false},"next_post":{"title":"算法-排序算法","uid":"76a9d45b04968897c2ef95f634fdfd9b","slug":"笔记/算法和数据结构/算法/排序","date":"2024-05-24T12:00:09.000Z","updated":"2025-10-31T09:00:55.091Z","comments":true,"path":"api/articles/笔记/算法和数据结构/算法/排序.json","keywords":null,"cover":"img/post/笔记/算法和数据结构/算法/排序/cover.png","text":"有关排序算法的性质和简单的排序算法的实现和分析。...","permalink":"/post/笔记/算法和数据结构/算法/排序","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"笔记-算法","slug":"笔记-算法","count":5,"path":"api/categories/笔记-算法.json"}],"tags":[{"name":"Algorithm","slug":"Algorithm","count":5,"path":"api/tags/Algorithm.json"},{"name":"Sort","slug":"Sort","count":1,"path":"api/tags/Sort.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"feature":false}}