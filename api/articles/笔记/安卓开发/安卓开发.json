{"title":"安卓开发","uid":"6771626c94a6c99bb57f253564040531","slug":"笔记/安卓开发/安卓开发","date":"2024-12-01T10:00:00.000Z","updated":"2025-11-13T08:37:14.821Z","comments":true,"path":"api/articles/笔记/安卓开发/安卓开发.json","keywords":null,"cover":"/img/post/笔记/安卓开发/cover.png","content":"<h1 id=\"一安卓介绍\"><a class=\"markdownIt-Anchor\" href=\"#一安卓介绍\"></a> 一.安卓介绍</h1>\n<p>安卓(Android)是一个主要为手机和平板设计的操作系统(operating system)。其主要是基于 Linux 内核的修改版本构建，针对移动设备架构进行了优化，使用类似Java的环境进行应用开发（与传统Java平台不同）。</p>\n<p>其软件设计主要采用 Apache 许可证开源，鼓励社区开发和贡献。特定部分不是开源的。</p>\n<h2 id=\"0-平台架构\"><a class=\"markdownIt-Anchor\" href=\"#0-平台架构\"></a> 0. 平台架构：</h2>\n<p>从下到上：安卓内核(kernel)、硬件层、ART(Android Runtime)、Java API 架构、用户应用。</p>\n<h2 id=\"1-灵活性-flexibility\"><a class=\"markdownIt-Anchor\" href=\"#1-灵活性-flexibility\"></a> 1. 灵活性 (Flexibility)</h2>\n<p>其具有灵活性(Flexibility)和定制性(Customization)：</p>\n<ul>\n<li>允许硬件制造商进行定制，从而实现跨设备的多样化 Android 体验。</li>\n<li>支持自定义引导加载程序，实现更深层次的系统修改和 root 权限（在某些情况下）。</li>\n<li>root 权限提供 super 用户访问权限。</li>\n</ul>\n<h2 id=\"2-兼容性-compatibility\"><a class=\"markdownIt-Anchor\" href=\"#2-兼容性-compatibility\"></a> 2. 兼容性 (Compatibility)</h2>\n<p>具有向前和向后(Forward &amp; backward)兼容性支持。</p>\n<p>向后兼容性限制：</p>\n<ul>\n<li>无法使用早期版本中不存在的 API。</li>\n<li>开发人员可以为其应用指定最低 API 级别。</li>\n</ul>\n<p>许可和品牌：</p>\n<ul>\n<li>Android logo 已获得 Creative Commons (CC) 许可。</li>\n<li>标有“Android 手机”的设备必须：\n<ul>\n<li>通过特定的兼容性测试。</li>\n<li>支持 Android 设定的 API 标准。</li>\n</ul>\n</li>\n<li>Android”品牌仅授权给开放移动联盟(Open Mobile Alliance)成员。</li>\n</ul>\n<h2 id=\"3-安卓内核-kernel\"><a class=\"markdownIt-Anchor\" href=\"#3-安卓内核-kernel\"></a> 3. 安卓内核 (kernel)</h2>\n<p>安卓内核是基于 linux 的，但有一些特定的修改。</p>\n<ul>\n<li>电源管理增强(Power Management Enhancements)，包括唤醒锁(wakelock)。</li>\n<li>Binder IPC (进程间通信 Inter-Process Communication) 驱动程序：一种用于高效进程通信的自定义机制。</li>\n<li>Low Memory Killer：一种在内存不足的情况下优雅地终止进程的机制，根据重要性确定优先级。</li>\n<li>Ashmem (Anonymous Shared Memory 匿名共享内存)：</li>\n<li>Alarm Driver (警报驱动程序)：用于根据定时事件唤醒设备。</li>\n<li>OOM（Out of Memory 内存不足）调整：针对前台和后台进程采用不同的 OOM 处理方式。</li>\n</ul>\n<h2 id=\"4-安卓硬件-hardware\"><a class=\"markdownIt-Anchor\" href=\"#4-安卓硬件-hardware\"></a> 4. 安卓硬件 (hardware)</h2>\n<ul>\n<li>Bluetooth：BlueZ</li>\n<li>GPS：制造商提供的 <a href=\"http://libgps.so/\">libgps.so</a></li>\n<li>Wifi：wpa_supplicant</li>\n<li>Display：标准帧缓冲驱动程序 Standardframebuffer driver</li>\n<li>Keyboard：标准输入事件 Standardinput event</li>\n<li>Lights：制造商提供的 <a href=\"http://liblights.so/\">liblights.so</a></li>\n<li>Audio 音频：制造商提供的 <a href=\"http://libaudio.so/\">libaudio.so</a></li>\n<li>Camera：制造商提供的 <a href=\"http://libcamera.so/\">libcamera.so</a></li>\n<li>PowerManagement：“wakelocks” kernel patch</li>\n<li>Sensors：制造商提供的 <a href=\"http://libsensors.so/\">libsensors.so</a></li>\n<li>Radio 无线电：制造商提供的 <a href=\"http://libril.so/\">libril.so</a></li>\n</ul>\n<h2 id=\"5-安卓应用\"><a class=\"markdownIt-Anchor\" href=\"#5-安卓应用\"></a> 5. 安卓应用</h2>\n<p>安卓应用使用的是沙盒(sandboxing)模式：</p>\n<ul>\n<li>确保应用程序在隔离环境中运行，以确保安全。</li>\n<li>利用 Linux 多用户功能。\n<ul>\n<li>通常一部手机只有一个用户。</li>\n</ul>\n</li>\n<li>每一个应用都有自己的进程，运行在自己的虚拟机中，拥有独一无二的 UID/AID。</li>\n<li>确保应用程序无法访问其他应用程序的文件、数据或进程。</li>\n<li>利用内置的 Linux 安全措施，包括标准用户和 root 用户权限。\n<ul>\n<li>标准用户没有根访问权限。</li>\n<li>根访问权限涵盖整个系统，但通常拥有限制以增强安全性。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-安卓启动过程\"><a class=\"markdownIt-Anchor\" href=\"#6-安卓启动过程\"></a> 6. 安卓启动过程</h2>\n<ol>\n<li>启动 ROM/Bootloader：将引导加载程序加载到 RAM 中，检测外部 RAM、设置网络、内存等。</li>\n<li>启动内核：配置缓存、保护内存、调度并加载驱动程序。</li>\n<li>初始化：挂载 /sys、/dev 或 /proc 等目录，运行 init.rc 脚本。</li>\n<li>Zygote &amp; VM：允许在 Android VM 之间共享代码，以便快速启动不同应用的单独 VM。</li>\n<li>系统服务应用：电源管理器、活动管理器、电话、注册表、包管理器、上下文管理器、系统联系人提供程序等</li>\n</ol>\n<h2 id=\"7-zygote\"><a class=\"markdownIt-Anchor\" href=\"#7-zygote\"></a> 7. Zygote</h2>\n<p>Zygote 是 Android 启动序列的一部分，可帮助启动应用程序。系统通过 Zygote 进行初始化，从而在 Dalvik（旧版 Android）或 ART（新版 Android）上执行应用。</p>\n<p>出于安全和隔离的原因，Android 应用程序在单独的进程中运行。每次启动应用程序时，启动一个新进程并从头开始设置 Android runtime (ART) 的新实例效率很低。</p>\n<p>Zygote 是辅助其启动的一个系统进程，初始化时包含所有必要系统库的主进程，这可确保常用资源已预先加载并在应用程序之间共享。在系统启动时，它会加载基本 Java 和 Android 类（java.<em>、android.</em>）。此预加载可缩短后续应用的启动时间。</p>\n<p>Android应用在启动时会从Zygote进程派生一个新的进程，以减少应用启动时的初始化开销。减少了应用进程从零开始的初始化时间，提高了Android设备多任务或快速切换应用时的性能。</p>\n<p>安卓虚拟机创建依赖 Zygote:</p>\n<ul>\n<li>Single Instance: 系统启动后，Zygote 会创建 Android 虚拟机（Dalvik 或 ART，具体取决于版本）的单实例。</li>\n<li>Class Reference: 此 VM 已准备好在 Zygote 初始化期间加载的类，确保用户应用快速启动和响应。</li>\n</ul>\n<h2 id=\"8-art\"><a class=\"markdownIt-Anchor\" href=\"#8-art\"></a> 8. ART</h2>\n<p>ART是用来替代Dalvik虚拟机的东西，其特点如下：</p>\n<ul>\n<li>AOT 预编译（Ahead-Of-Time Compilation）：在应用安装时就会进行预编译，将应用的字节码（.dex 文件）编译为本地机器码并存储下来。这样在应用运行时，省去了重复的 JIT（Just-In-Time）编译过程，启动更快，性能更高。</li>\n<li>更高效的垃圾回收（Garbage Collection）：ART 采用分代式垃圾回收（Generational GC）或其他更先进的 GC 技术，减少卡顿并降低对应用运行的干扰。</li>\n<li>更好的调试工具和诊断能力：ART 提供了更丰富的调试选项和运行分析工具，如更详细的内存分析、线程分析等，方便开发者进行性能优化。</li>\n<li>兼容性：虽然 ART 采用的是与 Dalvik 不同的执行机制，但大多数应用无需进行改动就可在 ART 上运行，Google 在实现中保留了较高程度的向后兼容。</li>\n</ul>\n<h1 id=\"二-安卓硬件\"><a class=\"markdownIt-Anchor\" href=\"#二-安卓硬件\"></a> 二. 安卓硬件</h1>\n<h2 id=\"1-一芯片系统-system-on-a-chip-socs\"><a class=\"markdownIt-Anchor\" href=\"#1-一芯片系统-system-on-a-chip-socs\"></a> 1. 一芯片系统 (System On A Chip, SOCs)</h2>\n<ul>\n<li>仅使用芯片上的部分晶体管组成 CPU\n<ul>\n<li>使用其余晶体管构建系统的其他组件</li>\n<li>外部引脚直接连接到外围硬件</li>\n</ul>\n</li>\n<li>在芯片上集成多个异构组件\n<ul>\n<li>减少通信开销</li>\n<li>减少热量</li>\n</ul>\n</li>\n<li>晶体管提供计算、存储\n<ul>\n<li>将芯片划分为多个通信区域</li>\n</ul>\n</li>\n<li>通用架构\n<ul>\n<li>CPU 核心：ARM Cortex 系列（例如 Cortex-A78）</li>\n<li>用于 AI 任务的神经处理单元 (NPU)</li>\n</ul>\n</li>\n<li>差异\n<ul>\n<li>人工智能和机器学习的集成：SoC 越来越多地包含用于机器学习和人工智能的专用核心，从而增强了面部识别和增强现实等功能。</li>\n</ul>\n</li>\n<li>根据用例进行定制\n<ul>\n<li>不同的 SoC 针对不同的性能需求进行了优化，例如游戏、摄影或能效。可以拥有独特的配套模块。</li>\n</ul>\n</li>\n<li>封装层叠 (Package on Package, PoP)：\n<ul>\n<li>背景：传统 SoC 中的 RAM集成度各不相同，在现代 SoC 中，集成 RAM 更为常见，但配置可能因应用需求而异。</li>\n<li>定义：一种将内存封装直接安装在 SoC 顶部的封装技术。</li>\n<li>生产灵活性：允许独立生产和测试内存和逻辑组件。</li>\n<li>空间优化：垂直堆叠组件以节省水平空间，这对于紧凑型设备设计至关重要</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\"></a> <a href=\"#2-arm-cpu-vs-intel-cpu-x86\"></a>2. ARM CPU vs Intel CPU (x86)</h2>\n<p>约 95% 的智能手机使用 ARM CPU，其余设备使用 Intel、MIPS 等。</p>\n<ul>\n<li>为什么使用ARM？</li>\n<li>快速高效的操作。</li>\n<li>更高的代码密度可实现更紧凑的设计。</li>\n<li>减少组件堆积，提高空间利用率。</li>\n</ul>\n<p>ARM 指令的特点：</p>\n<ul>\n<li>每条指令尽可能只使用一个周期。</li>\n<li>每条指令的长度为 32bit</li>\n<li>几乎每条指令都具有条件执行功能。</li>\n<li>一般寄存器：\n<ul>\n<li>R0-R12：一般目的的寄存器</li>\n<li>R13：栈寄存器</li>\n<li>R14：链接寄存器</li>\n<li>R15：PC</li>\n</ul>\n</li>\n<li>并不是所有的指令都用到 32bit，这会导致潜在的低效率，因此使用 Thumb 指令：\n<ul>\n<li>Thumb 指令使用紧凑的 ARM 16-bit 指令集。</li>\n<li>使用可变长度指令集，保留最常用的ARM指令并将它们编码成16位。\n<ul>\n<li>通过减少指令大小，实现了更快的速度。</li>\n<li>一次32-bit内存可以检索两个16位 Thumb 指令。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>ARM bit.LITTLE：</p>\n<ul>\n<li>ARM 使用大小核，通过集成强大的 (big) 内核和高效的 (LITTLE) 内核，将高性能与能效相结合。</li>\n<li>系统可以根据当前任务的需求在核心之间无缝切换，确保最佳性能和效率。</li>\n</ul>\n<h1 id=\"-2\"><a class=\"markdownIt-Anchor\" href=\"#-2\"></a> <a href=\"#%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6\"></a>三. 安卓软件的核心组件</h1>\n<p>安卓与传统Java应用不同，可以有多个入口点。这些入口点定义了安卓系统可以与应用程序交互或者进入应用程序的方式，包括活动(Activity)、服务(Service)、广播收集器(Broadcast Receiver)和内容提供程序(Content Provider)。</p>\n<p>传统的操作系统通常只有一个 Main 入口点，并且操作系统将程序加载到进程中并执行，实例化 Java VM 加载应用程序使用的所有类 执行 main。</p>\n<p>而安卓中是基于component的模型，拥有多个应用程序入口点：</p>\n<ul>\n<li>Zygote fork 后仍执行 main 函数，但在此基础上进行抽象。</li>\n<li>并非所有都是用户的入口点。</li>\n<li>每个component都作为逻辑上独立的唯一实体存在</li>\n</ul>\n<p>一个 Android 应用程序应该包含多个组件，并且用户经常在短时间内与多个应用程序进行交互，因此应用程序需要适应不同类型的用户驱动的工作流程和任务。</p>\n<p>安卓的特定组件通常是由特定interface进行通信，在运行时进行绑定。每个组件都有特定的生命周期，根据需要动态加载和卸载。</p>\n<h2 id=\"-3\"><a class=\"markdownIt-Anchor\" href=\"#-3\"></a> <a href=\"#1-activity\"></a>1. Activity</h2>\n<p>包括UI组件，View。是 android.app.Activity 的子类。其提供一个虚拟的UI，每一个 Activity 都拥有自己的窗口。</p>\n<h3 id=\"-4\"><a class=\"markdownIt-Anchor\" href=\"#-4\"></a> <a href=\"#a-view\"></a>a. View</h3>\n<p>UI layout属于一个View，是一种资源，在单独的通过编程构建的XML文件中指定。</p>\n<ul>\n<li>View的子类包含：\n<ul>\n<li>Views: 用来显示一些内容</li>\n<li>Widgets: 执行某些操作</li>\n<li>ViewGroups：布局子视图</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-5\"><a class=\"markdownIt-Anchor\" href=\"#-5\"></a> <a href=\"#i-views\"></a>I. Views</h4>\n<ul>\n<li>设计规范：\n<ul>\n<li>首选浅布局层次结构。</li>\n<li>尽可能减少嵌套布局（遍历成本）。</li>\n<li>wide over deep。</li>\n</ul>\n</li>\n<li>编程方面：\n<ul>\n<li>可以使用使用 <code>setContentView()</code> 来指定Activity的View。</li>\n<li>可以使用 <code>addView()</code>、<code>removeView()</code> 来改变视图的层次结构。</li>\n<li>根据 XML 布局定义生成的ID，使用 <code>R.layout.ID</code> 来找到特定的视图。</li>\n<li>可以将 View 和数据绑定在一起。</li>\n</ul>\n</li>\n<li>策略：\n<ul>\n<li>手机很少是相同的，通常具有不同的屏幕尺寸和宽高比、各种分辨率。所以应该避免硬编码 UI 组件配置细节。</li>\n<li>布局应该适应其所填充的屏幕：\n<ul>\n<li>将布局定义为层次结构和关系。</li>\n<li>使用以密度无关像素 (density-independent pixels,dp) 而不是 px 定义测量值\n<ul>\n<li>1dp 相当于 160dpi 上的一个像素。</li>\n</ul>\n</li>\n<li>可以定义特定于配置的布局\n<ul>\n<li>Small, normal, large and extra large.</li>\n<li>使用最小宽度限定符</li>\n<li>使用方向限定符</li>\n<li>进行规划，例如 <code>res/layout-sw600dp/main_activity.xml</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-6\"><a class=\"markdownIt-Anchor\" href=\"#-6\"></a> <a href=\"#ii-viewgroups-layouts\"></a>II. ViewGroups - Layouts</h4>\n<p>Layouts通常包含：</p>\n<ul>\n<li>FrameLayout：最简单的layout，只包含一个物体。</li>\n<li>LinearLayout：根据方向属性，将所有子项对齐到单一方向。</li>\n<li>TableLayout：将子项定位到行和列中</li>\n<li>ConstraintLayout / RelativeLayout：让子视图指定它们相对于父视图或彼此的位置，使用对齐进行约束。</li>\n<li>ScrollView：垂直滚动视图。</li>\n<li>SwipeRefreshLayout：实现“下拉刷新”交互效果的控件。检测垂直滑动、显示进度条并触发回调方法。</li>\n</ul>\n<h4 id=\"-7\"><a class=\"markdownIt-Anchor\" href=\"#-7\"></a> <a href=\"#iii-widgets\"></a>III. Widgets</h4>\n<p>用于可以交互的子View：</p>\n<ul>\n<li>Button</li>\n<li>TextView</li>\n<li>EditText</li>\n<li>CalendarViewer</li>\n<li>ImageView</li>\n</ul>\n<p>这些组件可以处理UI事件：</p>\n<ul>\n<li>代码中，可以使用 <code>setOnClickListener()</code>。</li>\n<li>在XML中，可以设置 <code>android:onClick=&quot;&quot;</code> 参数。</li>\n</ul>\n<p>这些组件可以文字展示：</p>\n<ul>\n<li>代码中，可以使用 <code>.getText()</code> 和 <code>.setText()</code></li>\n<li>在XML中，设置 <code>android:text=&quot;&quot;</code> 参数，例如 <code>android:text=&quot;@string/hello_world&quot;</code></li>\n</ul>\n<h3 id=\"-8\"><a class=\"markdownIt-Anchor\" href=\"#-8\"></a> <a href=\"#b-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A\"></a>b. 数据绑定</h3>\n<p>传统model中，设计大量样本代码(boilerplate code)：</p>\n<ul>\n<li>Activity 和 Model 紧密耦合</li>\n<li>处理 Activity 中的 onClick 事件</li>\n<li>查找对相关视图的引用</li>\n<li>检索内容（例如文本字段的内容）</li>\n<li>将结果写回视图</li>\n</ul>\n<p>一个数据模型应该：</p>\n<ul>\n<li>将 POJO 绑定到View组件以进行初始填充</li>\n<li>使对象可观察，以便在更改时自动更新 UI\n<ul>\n<li>如继承&quot;BaseObservable&quot;，或者使用&quot;ViewModel + Livedata&quot;。</li>\n<li>使用可观察域，即 <code>@{}</code> 和 <code>@={}</code></li>\n<li>可观察的objects, fields and collections</li>\n</ul>\n</li>\n<li>Data Binding Library：\n<ul>\n<li>是一种直接在XML中与类的成员进行绑定的方法，减少了在Activity中进行初始化的方法。</li>\n<li>即从layout中引用model对象。</li>\n<li>会生成必要的绑定类。</li>\n<li>包括基本格式表达式。</li>\n</ul>\n</li>\n<li>双向数据绑定，允许从View更新Object，反之亦然</li>\n</ul>\n<p>数据绑定的实现方法：<br />\n引用数据：</p>\n<table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">variable</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">name</span>=<span class=\"string\">\"viewmodel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">\"com.example.myapplication.MyModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br></pre></td></tr></tbody></table>\n<p>可观察域：</p>\n<ul>\n<li><code>@{}</code>：接收数据变化，是单项绑定。</li>\n<li><code>@={}</code>：接收属性的数据更改并监听用户更新，是双向绑定。</li>\n</ul>\n<table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:progress = \"@={viewmodel.progress}\"</span><br></pre></td></tr></tbody></table>\n<h3 id=\"-9\"><a class=\"markdownIt-Anchor\" href=\"#-9\"></a> <a href=\"#c-manifest%E6%96%87%E4%BB%B6\"></a>c. Manifest文件</h3>\n<p>是应用的components列表，用于指定程序的入口点，通常包含应用的信息(需要什么、什么可以做)。不在这个列表的不能称之为 components。那么该组件无法作为入口点。</p>\n<p>通常要考虑：</p>\n<ul>\n<li>如何启动（默认的启动 activity）</li>\n<li>如何向其他人展示</li>\n<li>哪些内容可以访问它 （程序内部和外部）</li>\n<li>用户的权限。</li>\n</ul>\n<h3 id=\"-10\"><a class=\"markdownIt-Anchor\" href=\"#-10\"></a> <a href=\"#d-navigation\"></a>d. Navigation</h3>\n<p>Activity 可以启动其他的 Activity，此时新的Activity就在旧的Acitivity上方。Activity 类似于一个栈结构。</p>\n<h4 id=\"-11\"><a class=\"markdownIt-Anchor\" href=\"#-11\"></a> <a href=\"#i-%E5%88%86%E5%B1%82%E6%B4%BB%E5%8A%A8%E5%AF%BC%E8%88%AA-hierarchical-activity-navigation\"></a>i. 分层活动导航 (Hierarchical Activity Navigation)</h4>\n<p>种类：</p>\n<ul>\n<li>Descendant navigation 子级导航：指从一个层级（通常是父级）“深入”到下一个层级（子级）的导航方式。也可理解为“层级向下”或“钻取”式导航。</li>\n<li>Lateral navigation 横向导航：在同一层级内进行“左右”或“并列”切换的导航方式。也可理解为“同级别的兄弟页面之间”的移动。通常是同一父级下不同子页面之间的切换。</li>\n</ul>\n<p>形式：</p>\n<ul>\n<li>列出可选择的 activity</li>\n<li>屏幕之间 Tab</li>\n<li>在屏幕或页面之间滑动</li>\n<li>按钮切换</li>\n<li>导航（graphs, destinations）</li>\n</ul>\n<h4 id=\"-12\"><a class=\"markdownIt-Anchor\" href=\"#-12\"></a> <a href=\"#ii-back-%E5%92%8C-up-%E5%AF%BC%E8%88%AA\"></a>ii. Back 和 UP 导航</h4>\n<p>都属于撤消横向和后代导航。</p>\n<ul>\n<li>Back: 可以在同一级中返回。\n<ul>\n<li>关闭当前的 activity。</li>\n<li>恢复堆栈中的下一个活动\n<ul>\n<li>taps 和 swipes 会更改当前屏幕显示的信息，而不是activity，因此不会影响历史记录。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Up: 返回父级。\n<ul>\n<li>关闭当前的 activity。</li>\n<li>启动（或恢复）相应的父级活动。\n<ul>\n<li>在 manifest 中表示。一般使用 <code>android:parentActivityName=&quot;.ParentActivity&quot;</code> 表示。</li>\n<li>如果它在后台堆栈中，则将其移到最前面。</li>\n<li>可以创建一个“假”返回堆栈</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-13\"><a class=\"markdownIt-Anchor\" href=\"#-13\"></a> <a href=\"#e-fragments\"></a>e. Fragments</h3>\n<p>Fragments 是比 Activity 更小的 UI 单元。</p>\n<ul>\n<li>多个 Fragments 可以组成一个 Activity，这样可以支持大屏幕 （例如平板）。</li>\n<li>可以在多个 Activity 复用一个 Fragments。</li>\n<li>管理逻辑上属于堆栈中同一 Activity 的项目集合\n<ul>\n<li>例如翻阅照片。</li>\n</ul>\n</li>\n<li>在输入、事件、生命周期方面与宿主 Activity 的关系有些复杂</li>\n</ul>\n<h3 id=\"-14\"><a class=\"markdownIt-Anchor\" href=\"#-14\"></a> <a href=\"#f-intents\"></a>f. Intents</h3>\n<p>Intent用来描述一个操作(operator)，包括要执行的Action以及所要处理的数据（可以用 URI 表示）。</p>\n<p>Android 的设计理念是通过 Intent 在不同的组件（尤其是 Activity 之间）进行通信，而不是让我们手动去实例化 Activity。</p>\n<p>Intent 还可以实现延迟绑定（Late Runtime Binding），并能把多个 Activity 逻辑“黏合”到一起。</p>\n<p>系统会根据AndroidManifest.xml中注册的信息来确定该如何响应并处理 Intent。</p>\n<h4 id=\"-15\"><a class=\"markdownIt-Anchor\" href=\"#-15\"></a> <a href=\"#i-%E4%BD%BF%E7%94%A8-intent-%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA-activity\"></a>i. 使用 Intent 启动/停止一个 Activity</h4>\n<p>如何使用 Intent 启动一个 Activity：</p>\n<ul>\n<li>创建一个新的 Intent 对象。</li>\n<li>指定想要将 Intent 发送给谁（可以是显式或者隐式方式）。</li>\n<li>调用 <code>startActivity()</code> 函数，并把这个 Intent 传递进去。</li>\n<li>系统会根据传入的 Intent，启动一个新的 Activity（即由系统的运行时来负责真正的启动过程）。</li>\n</ul>\n<p>停止一个 Activity：</p>\n<ul>\n<li>被启动的 Activity 完成任务后，可以通过调用 finish() 方法来销毁自己，返回到原先的 Activity。</li>\n<li>当用户按下“返回”键时，系统也会销毁当前 Activity，将界面返回到上一个 Activity（或退出应用）。</li>\n</ul>\n<h4 id=\"-16\"><a class=\"markdownIt-Anchor\" href=\"#-16\"></a> <a href=\"#ii-%E6%98%BE%E5%BC%8F-vs-%E9%9A%90%E5%BC%8F-intent\"></a>ii. 显式 vs 隐式 Intent</h4>\n<p>显式(Explicit) Intent：</p>\n<ul>\n<li>提供要启动的 Activity 的完全类名。</li>\n<li>如 <code>Intent myIntent = new Intent(context, otherActivity.class);</code></li>\n</ul>\n<p>隐式(Implicit) Intent:</p>\n<ul>\n<li>只指定一个操作（Action）和数据类型（Data/Category/Type）。</li>\n<li>由系统或其他应用中符合条件的组件来响应。</li>\n<li>必须要在 manifest 中声明，具体看下面 Intent Filters</li>\n</ul>\n<h4 id=\"-17\"><a class=\"markdownIt-Anchor\" href=\"#-17\"></a> <a href=\"#iii-intent-filters-for-deep-linking\"></a>iii. Intent Filters for Deep Linking</h4>\n<p>Intent Filters 是在 AndroidManifest.xml 中为 Activity、Service 或 BroadcastReceiver 指定的过滤条件，用于匹配特定的 Intent。它们决定哪些 Intent 可以由某个组件（如 Activity）处理。</p>\n<p>匹配条件：</p>\n<ul>\n<li>Action：定义意图的操作（例如 android.intent.action.VIEW 表示“查看某个资源”）。</li>\n<li>Category：补充描述意图的分类（例如 android.intent.category.DEFAULT 是默认分类）。</li>\n<li>Data：指定数据 URI（例如 URL 的协议或路径）或 MIME 类型，用于匹配数据内容。</li>\n</ul>\n<p>通过在 AndroidManifest.xml 中声明 Intent Filters，可以：</p>\n<ul>\n<li>指定某个 Activity 可以处理的 Intent 类型。</li>\n<li>实现 Deep Linking：允许应用直接打开特定的内容（如通过 URL 直接跳转到应用内的某个界面）。</li>\n<li>支持隐式 Intent：当其他应用或系统发送隐式 Intent 时，只有符合声明的 Activity 会被匹配到。</li>\n</ul>\n<p>当多个应用或组件的 Intent Filters 都匹配某个 Intent 时，系统会弹出一个选择对话框，允许用户选择使用哪个应用来处理。</p>\n<p>例子：</p>\n<table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=\"com.example.martinactivities.ForthActivity\"&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;</span><br><span class=\"line\">        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;</span><br><span class=\"line\">        &lt;data android:scheme=\"http\" /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></tbody></table>\n<p>这个配置表示 ForthActivity 是一个可以处理特定 Intent 的 Activity。</p>\n<ul>\n<li>表示此 Activity 可以处理“查看某些内容”的操作，例如点击链接或打开文件。</li>\n<li>表示这个 Activity 是默认分类，用于普通的隐式 Intent 调用。</li>\n<li>表示此 Activity 能够处理 HTTP URL 的数据。</li>\n</ul>\n<h3 id=\"-18\"><a class=\"markdownIt-Anchor\" href=\"#-18\"></a> <a href=\"#g-activity-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1\"></a>g. Activity 之间的通信</h3>\n<ul>\n<li><code>startActivity()</code>的限制：\n<ul>\n<li>用于启动另一个 Activity，但不允许返回结果到启动它的 Activity。</li>\n<li>应用通常需要维持用户在多个 Activity 中的状态。</li>\n<li>在复杂的场景中，Activity 可能需要跨进程通信（IPC），或者作为其他应用的入口点。</li>\n</ul>\n</li>\n<li><em><code>startActivityForResult()</code></em> 已过时：\n<ul>\n<li>启动另一个 Activity，并允许子 Activity 在完成后将结果返回到启动它的 Activity。</li>\n<li><code>startActivityForResult()</code> 需要提供一个数值型的请求代码（requestCode），以便区分返回的结果来源。</li>\n<li>子类使用 <code>setRusult()</code> 和规定一个返回结果的 <code>intent</code> 来返回结果。</li>\n<li>父类使用重写 <code>onActivityResult(int requestCode, int resultCode, Intent)</code> 方法来处理结果。</li>\n</ul>\n</li>\n<li><code>registerForActivityResult()</code>\n<ul>\n<li>是 <code>startActivityForResult()</code> 的现代替代方法，更加简洁、安全，避免了旧方法中繁杂的 <code>onActivityResult()</code> 回调逻辑。</li>\n<li>基于合约：例如使用 <code>ActivityResultContracts.StartActivityForResult</code> 来指定启动的 Activity 和结果处理逻辑。</li>\n<li>回调处理：在启动 Activity 时注册一个回调函数，当子 Activity 结束后返回时，该回调会被调用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-19\"><a class=\"markdownIt-Anchor\" href=\"#-19\"></a> <a href=\"#h-tasks-vs-activities-vs-processes\"></a>h. Tasks vs Activities vs Processes</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名字</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Activities</td>\n<td>1. 定义一个应用组件(application component)中屏幕的信息<br>2. 应用是一个Activities的集合，包括创建的和从其他应用中复用的</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Tasks</td>\n<td>1. 为了实现一个目标而用到的一系列activity<br>2. 单个任务可以只使用一个app中的activity，也可以利用多个不同app中的activity。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Processes</td>\n<td>1. 创建特定应用的 host component<br>2. 一个任务可以跨越多个进程</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"-20\"><a class=\"markdownIt-Anchor\" href=\"#-20\"></a> <a href=\"#i-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86\"></a>i. 安卓开发中的任务管理。</h3>\n<p>为什么要管理任务？</p>\n<ul>\n<li>用户频繁切换任务/堆栈：比如从一应用跳转到另一个应用或在同一个应用的不同活动中切换。</li>\n<li>大多数任务由多个活动 (Activities) 组成：\n<ul>\n<li>调用另一个应用中的 Activity：\n<ul>\n<li>并不总是局限于一个应用，而是跨应用的任务。</li>\n<li>通过松散绑定的方式提供连贯的用户体验，依赖于 Intent 等机制。</li>\n</ul>\n</li>\n<li>非确定性的用户路径 (Non-deterministic User Journeys)：\n<ul>\n<li>应用的启动位置不一定相同。</li>\n<li>用户可能在一段时间内“离开”应用，然后返回。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>任务管理的好处</p>\n<ul>\n<li>利用其他应用的组件：\n<ul>\n<li>通过 Intent 调用其他应用的 Activity，简化复杂功能的实现。</li>\n</ul>\n</li>\n<li>细粒度的资源管理\n<ul>\n<li>单个任务的活动状态可以根据需求调整，以优化内存、CPU、存储、屏幕和电池的使用。</li>\n<li>例如，释放后台任务的资源来提高设备性能。</li>\n</ul>\n</li>\n</ul>\n<p>如何应对任务管理？</p>\n<ul>\n<li>组件具有生命周期 (Lifecycles)：\n<ul>\n<li>每个 Activity 和 Fragment 都有生命周期，通过管理生命周期事件（如 onCreate, onStart, onDestroy 等），可以更高效地控制任务和资源使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-21\"><a class=\"markdownIt-Anchor\" href=\"#-21\"></a> <a href=\"#activity-%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"></a>Activity 与进程管理的核心概念</h4>\n<ul>\n<li>系统不会直接杀死活动 (The OS never kills an Activity)：\n<ul>\n<li>Android 系统不会单独终止活动，而是会杀死托管这些活动的进程以释放内存。</li>\n<li>系统更倾向于通过终止后台进程来回收资源。</li>\n</ul>\n</li>\n<li>应用如何响应内存压力：\n<ul>\n<li><code>onTrimMemory</code> 回调：应用可以通过该回调管理自己的内存资源，例如清除缓存或释放不必要的数据。</li>\n</ul>\n</li>\n<li>进程被终止的可能性取决于其状态：\n<ul>\n<li>系统会选择对用户影响最小的进程进行终止。</li>\n<li>决策依据包括：\n<ul>\n<li>进程最近是否被使用。</li>\n<li>进程是否与主屏 (Home Activity) 相关联。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-22\"><a class=\"markdownIt-Anchor\" href=\"#-22\"></a> <a href=\"#j-activity-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86\"></a>j. Activity 的生命周期管理</h3>\n<h4 id=\"-23\"><a class=\"markdownIt-Anchor\" href=\"#-23\"></a> <a href=\"#i-activity-%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%8A%B6%E6%80%81\"></a>I. Activity 的三种主要状态：</h4>\n<ul>\n<li>Active (活跃状态)：\n<ul>\n<li>Activity 位于前台并获得焦点。</li>\n<li>用户正在与该 Activity 交互。</li>\n</ul>\n</li>\n<li>Paused (暂停状态)：\n<ul>\n<li>Activity 仍然可见，但不在顶部。</li>\n<li>例如，出现一个半透明窗口或分屏模式中另一个应用获得焦点时，Activity 进入暂停状态。</li>\n<li>Activity 处于活动状态但未获得焦点。</li>\n</ul>\n</li>\n<li>Stopped (停止状态)：\n<ul>\n<li>Activity 被其他 Activity 完全遮挡。</li>\n<li>此状态下，Activity 不再可见。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-24\"><a class=\"markdownIt-Anchor\" href=\"#-24\"></a> <a href=\"#ii-%E4%BC%98%E5%85%88%E7%BA%A7%E9%99%8D%E4%BD%8E%E7%9A%84-activity\"></a>II. 优先级降低的 Activity</h4>\n<p>Android 系统如何管理资源：</p>\n<ul>\n<li>当 Activity 进入 Paused 或 Stopped 状态时，系统可能会降低其资源分配优先级。</li>\n<li>具体表现：\n<ul>\n<li>停止状态的 Activity 被挂起 (Suspended)：不会主动执行任何代码，但其状态会被保留。</li>\n<li>非活动的 Activity 可能被销毁 (Destruction)：\n<ul>\n<li>如果系统需要额外内存，可能会销毁处于 Stopped 或 Paused 状态的 Activity 来回收资源。</li>\n<li>重要性：必须保存 Activity 的状态以便用户返回时恢复。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-25\"><a class=\"markdownIt-Anchor\" href=\"#-25\"></a> <a href=\"#iii-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"></a>III. 注意事项</h4>\n<p>状态转换会触发事件，确保避免以下问题：</p>\n<ul>\n<li>因为用户接听电话导致的崩溃：\n<ul>\n<li>当用户接听电话或应用失去焦点时，系统可能会暂停或停止当前的 Activity。</li>\n<li>如果没有妥善管理生命周期，可能会导致崩溃。</li>\n</ul>\n</li>\n<li>在用户不使用应用时消耗资源：\n<ul>\n<li>停止或暂停的 Activity 不应占用系统资源（如内存、CPU），以避免浪费和影响其他任务的性能。</li>\n</ul>\n</li>\n<li>丢失用户进度：\n<ul>\n<li>确保在 Activity 状态变化时保存用户数据（如输入内容、进度）。</li>\n<li>提供一致的用户体验非常重要。</li>\n</ul>\n</li>\n<li>在配置更改期间的崩溃（例如屏幕旋转）：\n<ul>\n<li>设备从纵向切换到横向或其他配置变化（如语言、屏幕大小）时，Activity 会重新创建。</li>\n<li>如果没有保存状态或正确处理生命周期事件，可能会导致崩溃或用户数据丢失。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"-26\"><a class=\"markdownIt-Anchor\" href=\"#-26\"></a> <a href=\"#iv-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"></a>IV. 生命周期</h4>\n<p><code>onCreate() → onStart() → onResume() → onPause() → onStop() → onDestroy()</code></p>\n<ul>\n<li><code>onCreate()</code>：Activity 的初始化方法，相当于组件的“构造函数”。用于执行基础设置，例如加载 UI 布局。</li>\n<li><code>onStart()</code>：Activity 对用户可见，但尚未获得焦点。此时 UI 已加载，但用户还不能与之交互。</li>\n<li><code>onResume()</code>：Activity 已进入前台，并可供用户交互。Activity 将一直处于此状态，直到被其他 Activity 遮挡或用户切换应用。</li>\n<li><code>onPause()</code>：Activity 不再是用户的焦点，但仍部分可见（如弹出窗口覆盖部分界面）。停止不需要运行的任务，例如暂停视频播放或相机预览。</li>\n<li><code>onStop()</code>：Activity 完全不可见，处于后台状态。应释放资源并保存持久数据（如数据库或文件）。</li>\n<li><code>onDestroy()</code>：Activity 被销毁时调用。可能不会正常调用，所以不要在这里保存状态。</li>\n</ul>\n<p>当一个活动启动另一个活动后，必然有一个活动进入 <code>onPause()</code>，另一个进入 <code>onResume()</code>。</p>\n<p>关于 <code>onDestroy()</code> 注意事项：</p>\n<ul>\n<li>配置更改时，例如设备的屏幕方向、语言或者输入设备发生变化时，当前 Activity 会被摧毁并重新创建。</li>\n<li>当一个 Activity 正常完成时，用户按下返回键或者调用 <code>finish()</code> 方法，<code>onDestroy()</code> 会被调用。</li>\n<li>如果系统因为资源不足终止后台进程，则不会调用。</li>\n<li>因此，应该在 <code>onPause()</code> 或 <code>onStop()</code> 中提前保存关键数据，避免因进程被杀死导致数据丢失。</li>\n</ul>\n<h4 id=\"-27\"><a class=\"markdownIt-Anchor\" href=\"#-27\"></a> <a href=\"#v-ui%E4%BF%9D%E5%AD%98\"></a>V. UI保存</h4>\n<p>主要在于如何使用 <code>onSaveInstanceState()</code> 方法。<br />\n该方法不应依赖 Activity 保存 UI 或状态，配置更改和进程终止都可以恢复。例如当设备旋转会导致配置更改。</p>\n<p>在 Activity 被停止 <code>onStop()</code> 之前，系统会调用 <code>onSaveInstanceState()</code>。目的是保存 UI 的瞬态状态（transient state），以便在 Activity 重新创建时恢复。</p>\n<p>例如：保存用户输入内容、滚动位置或临时选择项。</p>\n<ul>\n<li>保存瞬态 UI 状态：<br />\n在 Activity 被重新创建时，保存的状态会通过 Bundle 传递：</li>\n</ul>\n<table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onCreate(Bundle savedInstanceState)</span><br><span class=\"line\">onRestoreInstanceState(Bundle savedInstanceState)</span><br></pre></td></tr></tbody></table>\n<ul>\n<li>保存非瞬态 UI 状态：\n<ul>\n<li>使用 SQL 数据库。</li>\n<li>使用 SharedPreferences。</li>\n</ul>\n</li>\n</ul>\n<p>实例状态 Instance State：</p>\n<ul>\n<li>目的：\n<ul>\n<li>用于保存小型的、与 UI 相关的数据，这些数据易于序列化或反序列化。</li>\n<li>比如文本输入框的内容、滚动位置等。</li>\n</ul>\n</li>\n<li>序列化开销：\n<ul>\n<li>由于需要序列化和反序列化，存在一定的性能消耗。</li>\n<li>因此，数据量不宜过大，否则会影响性能。</li>\n</ul>\n</li>\n<li>快速存取需求：\n<ul>\n<li>状态保存需要足够快，否则会导致 UI 卡顿或帧丢失。</li>\n</ul>\n</li>\n</ul>\n<p>Bundle 特点：</p>\n<ul>\n<li>结构：Bundle 是一个键值对（Key/Value）的集合。</li>\n<li>适用场景：适合保存小型的瞬态状态（transient state），如当前页面索引、简单的用户数据。</li>\n<li>Bundle 中存储的数据量有限，过大的数据可能导致 TransactionTooLargeException。</li>\n<li>复杂类（如自定义对象）需要实现 Parcelable 接口以优化性能。</li>\n</ul>\n<p>建议：</p>\n<ul>\n<li>只适用于储存小数据，适用于 UI 瞬态状态的数据存储，避免存储复杂和大规模的数据。</li>\n<li>由于序列化过程的开销，建议尽量保持 Bundle 的存储简单、快速。</li>\n<li>对于复杂数据（如网络请求结果、列表数据），建议使用 ViewModel 或持久化存储（如数据库、SharedPreferences）。</li>\n</ul>\n<h4 id=\"-28\"><a class=\"markdownIt-Anchor\" href=\"#-28\"></a> <a href=\"#vi-viewmodel\"></a>VI. ViewModel：</h4>\n<p>ViewModel 可以在配置更改时保留状态，例如屏幕旋转不会导致数据丢失。</p>\n<p>ViewModel 设计用于与 Activity 或 Fragment 的生命周期绑定，但独立于 UI 控件。在配置更改（如屏幕旋转）中，Activity 或 Fragment 会被销毁并重新创建，而 ViewModel 不会被销毁，从而保持数据的一致性。</p>\n<p>局限性：</p>\n<ul>\n<li>对配置更改免疫：ViewModel 可以在配置更改时保留状态，例如屏幕旋转不会导致数据丢失。</li>\n<li>不对资源管理终止免疫：如果系统由于资源不足（如内存不足）终止整个应用进程，ViewModel 中的数据会丢失。此时需要储存在数据库中。</li>\n<li>不对导航操作免疫：当用户导航离开当前 Activity 或 Fragment 时，ViewModel 会被销毁。</li>\n</ul>\n<h4 id=\"-29\"><a class=\"markdownIt-Anchor\" href=\"#-29\"></a> <a href=\"#vii-livedata\"></a>VII. LiveData：</h4>\n<ul>\n<li>LifecycleOwner：Activity 或 Fragment 实现了 LifecycleOwner 接口。提供生命周期对象，用于跟踪当前的生命周期状态。</li>\n<li>LifecycleObserver：注册为观察者的对象会感知生命周期事件。开发者可以将逻辑放入观察者中，而不是直接嵌入生命周期回调。</li>\n</ul>\n<p>好处：</p>\n<ul>\n<li>逻辑分离：生命周期逻辑与核心业务逻辑分离。</li>\n<li>减少错误：通过系统管理的组件状态减少数据更新冲突。</li>\n</ul>\n<p>LiveData 是一种可观察的数据容器，专为生命周期感知设计。与 ViewModel 配合使用，提供数据驱动的 UI 更新。</p>\n<p>特点：</p>\n<ul>\n<li>自动管理观察者：\n<ul>\n<li>当 UI 组件处于非活动状态时，不会触发观察者回调，避免浪费资源或引发错误。</li>\n<li>当组件被销毁时，自动移除观察者。</li>\n</ul>\n</li>\n<li>提供活动数据：\n<ul>\n<li>只有当组件处于活动状态时，LiveData 才会分发数据更新。</li>\n</ul>\n</li>\n</ul>\n<p>适用场景：</p>\n<ul>\n<li>数据绑定：实时更新 UI，适合动态数据流。</li>\n<li>简化生命周期处理：减少因生命周期变化导致的数据不一致问题。</li>\n</ul>\n<h2 id=\"-30\"><a class=\"markdownIt-Anchor\" href=\"#-30\"></a> <a href=\"#2-service\"></a>2. Service</h2>\n<p>在后台执行长时间运行操作的机制。没有用户界面（UI），用于长时间运行的操作。服务不受限于某个活动（Activity）的生命周期。一个服务可以被多个应用程序使用，避免资源重复。</p>\n<p>服务运行在主线程。</p>\n<p>Activity 经常会从前台转到后台（如用户切换任务）。当 Activity 被停止或销毁时，运行中的任务可能会中断。那么就出现一个问题：如何在 Activity 的生命周期内，或超过其生命周期的情况下处理任务。</p>\n<p>处理方法：</p>\n<ul>\n<li>基于生命周期的处理：主要由 Activity 的生命周期（如 onStop() 和 onPause()）及其 UI 组件的回调函数驱动。</li>\n<li>线程执行：Android 使用单线程模型，所有 UI 操作都在主线程（UI 线程）上完成。当需要运行耗时操作（如网络请求或复杂计算）时，必须使用辅助线程来避免阻塞 UI。</li>\n</ul>\n<p>线程与 Activity 的关系：</p>\n<ul>\n<li>Activity 销毁时，未正确管理的线程可能继续运行，导致内存泄漏或应用崩溃。</li>\n</ul>\n<p>为了处理超过 Activity 生命周期的任务，那么需要用到 Service。Service 是一个独立于 Activity 的应用组件，专门用于处理长时间运行的任务。即使 Activity 被销毁，Service 仍然可以继续运行。</p>\n<p>例如：</p>\n<ul>\n<li>播放后台音乐。</li>\n<li>定期从网络获取数据。</li>\n<li>上传或下载文件。</li>\n</ul>\n<p>服务的限制（What Services are not）</p>\n<ul>\n<li>服务不是单独的进程，而是运行在声明它的应用进程中。</li>\n<li>服务不是线程，需要手动启动工作线程以处理后台任务。</li>\n</ul>\n<p>Android 的 WorkManager</p>\n<ul>\n<li>主要用于处理可延迟的后台任务，同时遵守系统的后台限制。</li>\n</ul>\n<p>任务、服务与活动的分工（Tasks, Services, and Activities）</p>\n<ul>\n<li>服务处理长时间运行或后台任务，例如检查邮件、播放音乐。</li>\n<li>活动负责用户交互，例如显示邮件列表或音乐播放界面。</li>\n</ul>\n<h3 id=\"-31\"><a class=\"markdownIt-Anchor\" href=\"#-31\"></a> <a href=\"#a-%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9Fservice-lifecycle\"></a>a. 服务的生命周期（Service Lifecycle）</h3>\n<ul>\n<li><code>onCreate()</code>：服务初始化时调用。</li>\n<li><code>onStartCommand()</code> 或 <code>onBind()</code>：根据启动方式调用。</li>\n<li><code>onDestroy()</code>：服务结束时调用。</li>\n</ul>\n<p>绑定服务（Bound Services）：与其他组件绑定，生命周期与绑定组件相关联。</p>\n<p>非绑定服务（Unbound Services）：独立运行直到被显式停止。</p>\n<h3 id=\"-32\"><a class=\"markdownIt-Anchor\" href=\"#-32\"></a> <a href=\"#b-%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%B1%BB%E5%9E%8B\"></a>b. 服务的类型</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n<th>生命周期</th>\n<th>启动方式</th>\n<th>是否绑定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前台服务</td>\n<td>用户可见的操作（如播放音乐）。</td>\n<td>操作或任务活动期间。</td>\n<td><code>startForegroundService()</code></td>\n<td>可绑定，也可独立运行。</td>\n</tr>\n<tr>\n<td>后台服务</td>\n<td>用户不可见。</td>\n<td>可能在系统内存不足时终止。</td>\n<td><code>startService()</code></td>\n<td>可绑定。</td>\n</tr>\n<tr>\n<td>绑定服务</td>\n<td>用于组件间通信。</td>\n<td>绑定的组件存在期间。</td>\n<td>使用 <code>bindService()</code></td>\n<td>必须绑定。</td>\n</tr>\n<tr>\n<td>IntentService</td>\n<td>处理异步任务，工作完成后停止。</td>\n<td>任务完成后自行终止。</td>\n<td><code>startService()</code></td>\n<td>很少绑定。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"-33\"><a class=\"markdownIt-Anchor\" href=\"#-33\"></a> <a href=\"#c-activity%E4%B8%8Eservice%E7%9A%84%E9%80%9A%E4%BF%A1\"></a>c. Activity与Service的通信</h3>\n<ul>\n<li>通过Intent通信：活动（Activity）可以通过发送Intent启动一个服务，触发<code>onStartCommand</code>。</li>\n<li>服务与用户通信：服务可以通过通知（Notifications）与用户交互，因为服务本身没有UI。</li>\n<li>服务与Activity通信：\n<ul>\n<li>服务无法通过Intent直接与Activity通信。</li>\n<li>例如，发送邮件或MP3播放任务可通过绑定（Binding）实现通信。</li>\n</ul>\n</li>\n<li>保证任务完成：服务的生命周期（Lifecycle）管理至关重要。</li>\n</ul>\n<h3 id=\"-34\"><a class=\"markdownIt-Anchor\" href=\"#-34\"></a> <a href=\"#d-notifications\"></a>d. Notifications</h3>\n<p>作用：</p>\n<ul>\n<li>提醒用户应用程序的事件，例如任务提醒或系统状态。</li>\n<li>需考虑用户的情绪和专注力，避免过度打扰。</li>\n</ul>\n<p>跨平台通知设计原则：</p>\n<ul>\n<li>遵循Material Design或Human Interface Guidelines。</li>\n<li>避免无意义通知，例如“很久没见到你了”。</li>\n<li>目标是创建简洁易读、用户友好的通知。</li>\n</ul>\n<p>与服务的关系：</p>\n<ul>\n<li>服务可以通过通知告知用户正在运行的任务。</li>\n<li><code>PendingIntent</code> 允许用户通过通知返回到 Activity。</li>\n<li>服务可以在通知中提供交互按钮，例如暂停/停止功能。</li>\n</ul>\n<h3 id=\"-35\"><a class=\"markdownIt-Anchor\" href=\"#-35\"></a> <a href=\"#e%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"></a>e.服务的生命周期</h3>\n<ul>\n<li>服务的启动方式：\n<ul>\n<li>Started Service（启动服务）：通过<code>startService</code>启动，会独立运行，直到显式调用<code>stopService</code>停止。</li>\n<li>Bound Service（绑定服务）：通过<code>bindService</code>绑定，运行于与之绑定的Activity之间的通信通道中。</li>\n</ul>\n</li>\n<li>生命周期的特点：\n<ul>\n<li>可以同时启动和绑定服务。</li>\n<li>不同的生命周期责任：\n<ul>\n<li>启动服务需要开发者管理生命周期。</li>\n<li>绑定服务的生命周期由系统自动管理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>终止服务：\n<ul>\n<li>自行调用<code>stopSelf</code>。</li>\n<li>通过Intent调用<code>stopService</code>。</li>\n<li>避免终止：\n<ul>\n<li>可将服务设置为前台服务（Foreground Service），通过startForeground提高优先级。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>onStartCommand</code>返回值决定服务重启行为：\n<ul>\n<li><code>START_NOT_STICKY</code>：服务不再自动重启。</li>\n<li><code>START_STICKY</code>：服务重启但不重新传递Intent。</li>\n<li><code>START_REDELIVER_INTENT</code>：重启服务并重新传递上一次的Intent。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-36\"><a class=\"markdownIt-Anchor\" href=\"#-36\"></a> <a href=\"#f-%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1-remote-service\"></a>f. 远程服务 Remote Service</h3>\n<ul>\n<li>Intent的作用：用于在应用或进程之间通信，但在远程服务中需要进一步扩展。</li>\n<li>跨进程通信的特点：\n<ul>\n<li>远程服务允许在不同应用/进程之间共享服务。</li>\n<li>需要将任务交给其他进程中的线程处理。</li>\n<li>可能被多个进程同时使用，因此必须声明为exported服务（在Manifest文件中定义）。</li>\n<li>隐式 <code>Intent</code> 在远程服务中不能使用（可能由于权限或安全性原因）。</li>\n</ul>\n</li>\n<li>通信方式：\n<ul>\n<li>使用<code>Messenger</code>：用于消息传递（异步）。</li>\n<li>定义接口：支持注册回调和将系统服务封装到API中以供客户端调用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-37\"><a class=\"markdownIt-Anchor\" href=\"#-37\"></a> <a href=\"#g-%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1communicating-with-services\"></a>g. 服务间通信（Communicating with Services）</h3>\n<ul>\n<li>Messenger 的角色：\n<ul>\n<li>Messenger 是服务的一个 IPC（进程间通信）接口。</li>\n<li>基于消息的通信模型，而不是直接的方法调用。</li>\n<li>支持异步通信，使用消息（Message）携带数据包。</li>\n</ul>\n</li>\n<li>消息队列与线程：\n<ul>\n<li>消息被排队到单个线程中，按顺序处理。</li>\n<li>使用 Handler 管理线程间的通信和并发。</li>\n<li>服务可以通过定义自己的 Handler 来响应不同类型的消息对象。</li>\n</ul>\n</li>\n<li>IBinder 的使用：\n<ul>\n<li>Messenger 实际上是一个带有“发送消息”功能的 IBinder。</li>\n<li>服务端通过 IBinder 共享与客户端的连接。</li>\n<li>客户端通过 IBinder 发送消息给服务。</li>\n</ul>\n</li>\n<li>双向通信（Bi-directional Communication）：\n<ul>\n<li>客户端也可以拥有自己的 Messenger。</li>\n<li>客户端在发送消息时提供一个返回的 Messenger 引用，以实现双向通信。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-38\"><a class=\"markdownIt-Anchor\" href=\"#-38\"></a> <a href=\"#h-messengerhandlerlooper-%E5%85%B3%E7%B3%BB\"></a>h. Messenger/Handler/Looper 关系</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>比喻</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Processes</td>\n<td>将每个应用程序类比为社区中的独立房子。</td>\n</tr>\n<tr>\n<td>Messenger</td>\n<td>如果一个房子（应用中的活动）需要向另一个房子（远程服务）发送消息，它会写信交给邮递员（Messenger），邮递员将其递送到目的地。</td>\n</tr>\n<tr>\n<td>Handler</td>\n<td>负责检查信箱的人，阅读信件并根据内容采取行动。</td>\n</tr>\n<tr>\n<td>Looper</td>\n<td>定期检查信箱的例行工作，确保不会遗漏重要邮件。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"-39\"><a class=\"markdownIt-Anchor\" href=\"#-39\"></a> <a href=\"#i-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92message-transfer-%E7%9A%84%E6%9C%BA%E5%88%B6\"></a>i. 消息传递（Message Transfer） 的机制</h3>\n<ul>\n<li>服务端的准备（Inside the Service House）\n<ul>\n<li>服务端在开始前，会通知邮递员（Messenger）：“如果有人要给我发送信件（消息），这是我的信箱地址，以及我喜欢的信件格式。”</li>\n<li>这一步相当于服务端设置了消息接收的规则和流程。</li>\n</ul>\n</li>\n<li>客户端的操作（Inside the Activity House）\n<ul>\n<li>当客户端（Activity House）想要向服务端（Service House）发送消息时：\n<ul>\n<li>客户端写好信件（消息）并交给邮递员（Messenger）。</li>\n<li>由于服务端之前提供了详细的地址和说明，邮递员能够准确地将信件送达。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>回复消息的机制\n<ul>\n<li>如果客户端希望收到服务端的回复，它需要在信件中附带回信地址（自己的 Messenger 信息）。</li>\n<li>这样，服务端可以通过回信地址，将响应（回复消息）送回客户端。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-40\"><a class=\"markdownIt-Anchor\" href=\"#-40\"></a> <a href=\"#g-parcelable\"></a>g. <code>Parcelable</code></h3>\n<p>如果服务是绑定到同一个进程内，它们共享相同的内存空间。在这种情况下，可以轻松调用方法并传递对象或引用，效率更高。</p>\n<p>那么需要跨进程通信，如何传递对象？</p>\n<ul>\n<li>使用<code>java.io.Serializable</code>\n<ul>\n<li>通过反射或自省技术写入对象ID和字段。</li>\n<li>如果类或变量名称发生变化，可能会导致错误。</li>\n<li>缺点：\n<ul>\n<li>慢：性能较低。</li>\n<li>脆弱：对类定义的修改敏感。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用 <code>Parcelable</code>\n<ul>\n<li>定义简单的协议用于写入基本数据类型。</li>\n<li>通过传递关键数据重新创建对象（类似深拷贝）。</li>\n<li>具有抗小改动能力（类定义发生小变化不会出错）。</li>\n<li>优点：\n<ul>\n<li>快速：比Serializable高效得多。</li>\n<li>由Android内核驱动提供支持。</li>\n</ul>\n</li>\n<li>适合在Android应用中使用，特别是涉及跨进程数据传递时。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-41\"><a class=\"markdownIt-Anchor\" href=\"#-41\"></a> <a href=\"#h-defining-remote-interface\"></a>h. Defining Remote Interface</h3>\n<p>通过 AIDL 定义远程接口</p>\n<ul>\n<li>主要功能：\n<ul>\n<li>为服务的功能指定一个接口</li>\n<li>AIDL 的作用：\n<ul>\n<li>生成一个 代理对象（Proxy Object），允许在本地使用，像远程服务是本地的一样。</li>\n<li>生成一个 存根实现（Stub Implementation）：负责处理远程事务的服务端。</li>\n<li>生成 通信协议：包括对象的序列化（parcelling）和反序列化（unparcelling）步骤，作为拷贝和重新创建对象的传输协议。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>与 Java 接口定义的相似性\n<ul>\n<li>方法参数标签：\n<ul>\n<li>in：传递到远程方法。</li>\n<li>out：返回给调用者。</li>\n<li>inout：既作为输入又作为输出。</li>\n<li>oneway：异步调用。</li>\n</ul>\n</li>\n<li>允许的数据类型：\n<ul>\n<li>Java 的基本数据类型：如 int, float, boolean。</li>\n<li>列表（List）、映射（Map）等集合。</li>\n<li>实现 Parcelable 协议的类。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>作用\n<ul>\n<li>AIDL 编译器自动为开发者生成 Java 代码。这些代码处理进程间通信（IPC）的细节，确保接口中的方法调用能够正确地分发并在目标远程进程中执行。</li>\n<li>当调用生成代码中的某个方法时，它会使用 Binder 框架 与远程进程通信。Binder 框架确保方法调用被正确传递到目标位置，并在需要时返回结果。</li>\n<li>Binder 提供了底层的 IPC 机制。AIDL 简化了 Binder 的使用，开发者通过定义熟悉的接口，而无需直接处理复杂的 IPC 细节。AIDL 自动处理大部分 IPC 的实现。</li>\n</ul>\n</li>\n<li>与 Messenger 相比：\n<ul>\n<li>支持复杂接口。</li>\n<li>性能高，多线程支持多客户端访问。</li>\n<li>支持自定义数据类型。</li>\n<li>支持双向通信和回调。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-42\"><a class=\"markdownIt-Anchor\" href=\"#-42\"></a> <a href=\"#j-ipc-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"></a>J. IPC 进程间通信</h3>\n<ul>\n<li>\n<p>每个进程有自己的地址空间，提供数据隔离。</p>\n</li>\n<li>\n<p>IPC 用于实现模块化，但需要克服跨进程直接交互的限制。</p>\n</li>\n<li>\n<p>Binder作为Android的IPC核心，支持远程过程调用和数据传输。</p>\n<ul>\n<li>Binder简化了进程间通信。Binder是Android的底层IPC机制，通过数据打包和解包实现安全通信。</li>\n<li>使用 AIDL 定义通信接口，通过代理 (proxy) 和存根 (stub) 实现高效的组件交互。</li>\n<li>内容：\n<ul>\n<li>调用 (Calls)： 支持一对一和一对多的简单进程消息传递（单向或双向）。</li>\n<li>身份识别 (Identifying)： 管理进程 ID（PID）和用户 ID（UID）。</li>\n<li>管理 (Managing)： 提供引用计数和跨进程对象映射功能。</li>\n<li>间接功能：\n<ul>\n<li>作为一个令牌（Token）。</li>\n<li>共享文件描述符（File Descriptor）以实现共享内存区域。</li>\n</ul>\n</li>\n<li>线程管理：控制工作线程的休眠和唤醒。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Binder 实现 (Binder Implementation)：</p>\n<ul>\n<li>API 层面：\n<ul>\n<li>使用 AIDL 和 Java API 暴露 IBinder 接口。</li>\n<li>提供 Parcelable 接口用于对象的序列化和反序列化。</li>\n</ul>\n</li>\n<li>中间件层：\n<ul>\n<li>管理用户空间的 Binder 框架功能。</li>\n<li>处理数据的序列化/反序列化以及与内核驱动的交互。</li>\n</ul>\n</li>\n<li>内核驱动层：\n<ul>\n<li>通过 ioctl 系统调用支持中间件。</li>\n<li>实现跨进程文件操作和内存映射。</li>\n<li>为每个服务应用程序提供线程池。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Binder 事务 (Binder Transactions)</p>\n<ul>\n<li>事务启动：进程 A 调用 <code>IBinder.transact()</code> 请求操作。</li>\n<li>事务处理：进程 B 的 Binder 对象通过 <code>onTransact()</code> 方法接收和处理请求。</li>\n<li>线程管理：每个进程的线程池处理所有 IPC 请求。</li>\n<li>阻塞与响应：发起请求的进程 A 在 <code>transact()</code> 调用期间阻塞，等待进程 B 返回结果。</li>\n</ul>\n</li>\n<li>\n<p>Binder 安全性</p>\n<ul>\n<li>Binder 本身不负责安全，但提供了可信执行环境。</li>\n<li>内核通过 UID/PID 管理客户端身份。</li>\n</ul>\n</li>\n<li>\n<p>Binder 性能</p>\n<ul>\n<li>显式限制：\n<ul>\n<li>每个进程的事务缓冲区大小为 1MB，限制了并发事务的数据量。</li>\n<li>建议保持事务数据较小。</li>\n</ul>\n</li>\n<li>隐式限制：\n<ul>\n<li>数据传输需要复制，增加了内存资源的重复使用。</li>\n<li>不适合传输大规模数据流。</li>\n</ul>\n</li>\n<li>优化方式：\n<ul>\n<li>使用共享内存（如 Ashmem）传递大数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-43\"><a class=\"markdownIt-Anchor\" href=\"#-43\"></a> <a href=\"#k-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1-system-services\"></a>k. 系统服务 (System Services)</h3>\n<ul>\n<li>电源管理 (Power Manager)。</li>\n<li>包管理器 (Package Manager)。</li>\n<li>位置服务 (Location Manager)。</li>\n<li>通知管理器 (Notification Manager)。</li>\n<li>蓝牙服务 (Bluetooth Service)。</li>\n<li>音频服务 (Audio Service)。</li>\n</ul>\n<h3 id=\"-44\"><a class=\"markdownIt-Anchor\" href=\"#-44\"></a> <a href=\"#l-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8\"></a>l. 服务管理器</h3>\n<ul>\n<li>功能：\n<ul>\n<li>跟踪和管理所有系统服务的引用。</li>\n<li>允许客户端通过服务名检索远程服务的 Binder 句柄。</li>\n</ul>\n</li>\n<li>特性：\n<ul>\n<li>首个通过 Binder 注册的服务。</li>\n<li>仅允许可信系统服务注册（如系统、媒体服务）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-45\"><a class=\"markdownIt-Anchor\" href=\"#-45\"></a> <a href=\"#3-broadcast-receiver\"></a>3. Broadcast Receiver</h2>\n<p>响应来自操作系统/其他应用程序的广播消息。</p>\n<h2 id=\"-46\"><a class=\"markdownIt-Anchor\" href=\"#-46\"></a> <a href=\"#4-content-provider\"></a>4. Content Provider</h2>\n<p>使数据可供其他应用程序使用/利用来自其他应用程序的数据。</p>\n<h1 id=\"-47\"><a class=\"markdownIt-Anchor\" href=\"#-47\"></a> <a href=\"#%E5%85%B6%E4%BB%96\"></a>三. 其他</h1>\n<h2 id=\"-48\"><a class=\"markdownIt-Anchor\" href=\"#-48\"></a> <a href=\"#1-kotlin\"></a>1. Kotlin</h2>\n<p>Kotlin 是 2011 年 JetBrains 创建的语言。</p>\n<h3 id=\"-49\"><a class=\"markdownIt-Anchor\" href=\"#-49\"></a> <a href=\"#i-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-kotlin\"></a>i. 为什么使用 Kotlin？</h3>\n<ul>\n<li>现代语言特性。</li>\n<li>与 Java 的互操作性。</li>\n<li>提高开发人员的工作效率。</li>\n</ul>\n<h3 id=\"-50\"><a class=\"markdownIt-Anchor\" href=\"#-50\"></a> <a href=\"#ii-%E4%B8%BA%E4%BB%80%E4%B9%88-kotlin-java\"></a>ii. 为什么 Kotlin &gt; Java？</h3>\n<ul>\n<li>简洁性 Conciseness\n<ul>\n<li>显著减少样板代码 (boilerplate code)。</li>\n<li>例如 数据类自动生成 getter、setter 和其他实用方法</li>\n</ul>\n</li>\n<li>安全功能 Safety Features\n<ul>\n<li>Null Safety 空安全：在编译时消除 NullPointerException。\n<ul>\n<li>默认情况下，变量不能为空值，除非显式声明为空。(加一个问号?)</li>\n</ul>\n</li>\n<li>Immutability 不可变的：鼓励使用不可变的数据结构。\n<ul>\n<li>默认情况下，Kotlin 提倡不可变性。</li>\n<li>被声明为 <code>val</code> 的变量是只读的，不能重新分配。</li>\n<li>这可以避免可变变量引起的意外副作用，从而使代码更安全。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>互操作性 Interoperability\n<ul>\n<li>与现有 Java 代码无缝集成。</li>\n<li>允许从 Java 逐步迁移到 Kotlin。</li>\n</ul>\n</li>\n<li>扩展方法\n<ul>\n<li>Kotlin 允许使用新功能扩展类，而无需从该类继承或使用 Decorator 等设计模式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-51\"><a class=\"markdownIt-Anchor\" href=\"#-51\"></a> <a href=\"#iii-coroutines-%E5%8D%8F%E7%A8%8B\"></a>iii. Coroutines 协程</h3>\n<p>协程本质上是轻量级线程 (Lightweight Threads)。它们允许我们执行后台任务，而无需与传统线程相关的大量资源成本。协程是实现异步的一种方式。</p>\n<p>线程是由操作系统管理和调度的，而协程则是由程序代码自身进行管理和调度。</p>\n<p>与线程不同，协程由 Kotlin 运行时而不是操作系统管理，从而使其效率更高。</p>\n<p>Sequential Asynchronous Code（顺序异步代码）：</p>\n<ul>\n<li>协程使异步代码看起来像同步代码，协程的特性允许我们以顺序的方式编写异步逻辑。</li>\n<li>这种顺序风格的代码更加直观，不会阻塞主线程，适用于高并发和 I/O 密集型任务。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>协程支持非阻塞操作 (Non-blocking Code Execution)：\n<ul>\n<li>在执行长时间运行的任务时，协程不会阻塞主线程，保持应用的响应能力</li>\n<li>非阻塞操作可以避免出现“应用无响应”（Application Not Responding，ANR）错误，这是移动应用开发中的常见问题。</li>\n</ul>\n</li>\n<li>简化代码结构：\n<ul>\n<li>避免嵌套回调和“回调地狱”（Callback Hell）。\n<ul>\n<li>协程提供了更直观的方式来处理异步操作，而不需要依赖复杂的嵌套回调。</li>\n</ul>\n</li>\n<li>以顺序方式编写代码：\n<ul>\n<li>协程的代码结构更接近同步代码，简化了逻辑流程，提升了可读性和维护性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>可扩展并发性 (Scalable Concurrency)\n<ul>\n<li>高效处理多任务并发：协程能够高效地管理和执行大量并发任务，且资源开销极小。</li>\n<li>便于应用扩展：相比传统线程，协程更容易管理并发任务，尤其适用于需要高并发的场景。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-52\"><a class=\"markdownIt-Anchor\" href=\"#-52\"></a> <a href=\"#2-jetpack-compose\"></a>2. Jetpack Compose</h2>\n<p>Jetpack Compose 是一个现代工具包，用于通过声明式方式构建原生 Android 用户界面。完全使用 Kotlin 构建，紧密集成，利用现代语言特性实现简洁和可表达的代码。</p>\n<p>是基于 Jetpack 的一个工具，基于模块化组件，组成成分有：</p>\n<ul>\n<li>Foundation：提供核心工具，例如AppCompat</li>\n<li>Architecture：提供生命周期感知组件，例如 ViewModel, LiveData 和 Room</li>\n<li>UI：包括用于导航、Fragment和动画的工具。</li>\n<li>Behavior：提供后台任务和数据处理的工具。</li>\n</ul>\n<p>特性：</p>\n<ul>\n<li>使用 Kotlin 编写 UI 和业务逻辑，无需切换上下文。</li>\n<li>支持 实时预览 (Live Previews) 和 热重载 (Hot Reloading)，在开发过程中实时更新 UI。</li>\n<li>使用Composable 函数：通过函数式组件减少冗余代码。</li>\n<li>无需 XML 布局和 findViewById，可直接引用 UI 组件。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>提高生产力 (Improved Productivity)\n<ul>\n<li>减少样板代码：减少开发中的重复性代码，提高应用质量。</li>\n<li>直观的 API：采用声明式编程风格，学习曲线平滑，更易于掌握和使用。</li>\n</ul>\n</li>\n<li>更高的性能 (Better Performance)：\n<ul>\n<li>高效的渲染 (Efficient Rendering)：仅更新受影响的组件，避免不必要的重绘，从而提升性能。</li>\n<li>异步处理 (Asynchronous Handling)：提供流畅的 UI 交互体验，适配现代异步工作流。</li>\n</ul>\n</li>\n<li>轻松集成 (Easy Integration)：\n<ul>\n<li>与现有视图兼容 (Interoperable with existing Android views)</li>\n<li>向后兼容：支持旧版本的 Android，同时提供生命周期感知的功能。</li>\n</ul>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>关注点分离减少 (Reduced Separation of Concerns)：\n<ul>\n<li>在 Composable 函数中将布局和逻辑结合在一起，可能会模糊 UI 结构与功能代码之间的界限。</li>\n<li>这可能会增加隔离特定部分的难度。</li>\n</ul>\n</li>\n<li>复杂 UI 中的复杂性增加 (Increased Complexity in Large UIs)：\n<ul>\n<li>对于复杂的用户界面，将布局和内容结合在同一代码中，可能会导致函数变得庞大且难以阅读。</li>\n<li>开发者需要将 UI 拆分成更小、更可重用的组件以提高可读性。</li>\n</ul>\n</li>\n<li>文件体积膨胀的可能性 (Potential for Large Files)：\n<ul>\n<li>由于将 UI 和逻辑放在一起，文件可能变得非常庞大，尤其是在大型应用中。</li>\n<li>查找特定组件或逻辑可能会变得困难。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-53\"><a class=\"markdownIt-Anchor\" href=\"#-53\"></a> <a href=\"#i-composable-function\"></a>i. Composable Function</h3>\n<p>使用 <code>@Composable</code> 注解，用于定义 UI 组件。</p>\n<ul>\n<li>声明式 UI 定义：描述 UI 应该显示什么，而不是如何构建。</li>\n<li>Composable 函数可以嵌套，并组合起来构建复杂的用户界面。</li>\n</ul>\n<p>Composables 中管理状态：</p>\n<ul>\n<li>维护状态以跨越多次重组 (recomposition)。</li>\n<li>响应用户交互和数据变化，动态更新 UI。</li>\n</ul>\n<p>状态管理工具：</p>\n<ul>\n<li>remember：用于在相同的 Composable 中保持状态，避免因重组丢失数据。</li>\n<li>mutableStateOf：持有一个可变的值，当值发生变化时会触发 UI 的重新绘制 (recomposition)。</li>\n</ul>\n<h2 id=\"-54\"><a class=\"markdownIt-Anchor\" href=\"#-54\"></a> <a href=\"#3-%E9%9B%B6%E6%97%A5%E6%94%BB%E5%87%BB-zero-day-attack\"></a>3. 零日攻击 (Zero-day Attack)</h2>\n<p>零日攻击是一种利用软件漏洞的攻击行为，这些漏洞对于供应商或开发者来说是未知的。“零日”意味着开发者在漏洞被利用之前，没有任何时间（0天）来修复这个问题。</p>\n<p>特点：</p>\n<ul>\n<li>未被发现的漏洞 (Undetected Vulnerabilities)：\n<ul>\n<li>攻击者利用在安全团队或开发人员发现之前存在的漏洞。</li>\n<li>这些漏洞通常处于未知状态，未被公开</li>\n</ul>\n</li>\n<li>高风险 (High Risk)：\n<ul>\n<li>在漏洞被修复之前，攻击者可能造成严重的损害。</li>\n<li>高危攻击可能泄露敏感信息、破坏系统或造成经济损失。</li>\n</ul>\n</li>\n<li>隐蔽性 (Stealthy Nature)：\n<ul>\n<li>零日攻击往往具有高度隐蔽性，通常在攻击发生后才被察觉。</li>\n<li>由于未被识别，受害者可能无法立即采取防御措施。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-55\"><a class=\"markdownIt-Anchor\" href=\"#-55\"></a> <a href=\"#4-%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C\"></a>4. 线程执行</h2>\n<h3 id=\"-56\"><a class=\"markdownIt-Anchor\" href=\"#-56\"></a> <a href=\"#i-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"></a>I. 单线程模型：</h3>\n<ul>\n<li>主线程 (Main Thread)：Android 应用程序默认使用单线程模型，所有组件（Activity、Service、BroadcastReceiver 等）都在主线程上运行。</li>\n<li>主线程启动时，负责处理：\n<ul>\n<li>用户界面的绘制。</li>\n<li>响应用户交互事件（如 onClick()）。</li>\n<li>处理 Activity 生命周期事件（如 onCreate()、onDestroy()）。</li>\n</ul>\n</li>\n<li>适合主线程的任务：\n<ul>\n<li>短时间的 UI 更新。</li>\n<li>生命周期事件的调度。</li>\n</ul>\n</li>\n<li>不适合主线程的任务：\n<ul>\n<li>网络请求。</li>\n<li>文件读写。</li>\n<li>数据库操作。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-57\"><a class=\"markdownIt-Anchor\" href=\"#-57\"></a> <a href=\"#ii-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86\"></a>II. 线程管理：</h3>\n<ul>\n<li>避免在主线程运行耗时任务：\n<ul>\n<li>Android 会抛出 NetworkOnMainThreadException，阻止在主线程上执行网络操作。</li>\n<li>耗时任务会导致应用卡顿甚至无响应（ANR：Application Not Responding）。</li>\n</ul>\n</li>\n<li>推荐的做法：\n<ul>\n<li>使用辅助线程（如 Thread 或 ExecutorService）。</li>\n<li>使用异步工具类（如 AsyncTask，但已被弃用）。</li>\n<li>使用现代 Android 框架（如 Coroutines 或 WorkManager）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"-58\"><a class=\"markdownIt-Anchor\" href=\"#-58\"></a> <a href=\"#iii-looper-and-handle\"></a>III. Looper and Handle</h3>\n<p>HandlerThread：HandlerThread 是对普通线程的扩展，支持 Looper。它是一个后台线程，与主线程分离。提供一个线程，并自动管理与该线程相关的 Looper 和消息队列（MessageQueue）。通常用于在后台线程中处理任务。</p>\n<p>Looper：每个 HandlerThread 都包含一个 Looper，Looper 维护了一个消息队列（MessageQueue），用于管理事件队列。<code>Looper.loop()</code> 运行循环，从队列中取出消息并调度执行。</p>\n<p>Message：消息是需要处理的任务，可以包含数据或者对某个 Runnable 对象的引用。是线程间通信的基础单元。消息队列中的每个消息会被 Looper 分发给相应的 Handler 进行处理。</p>\n<p>Handler：Handler 绑定到某个 Looper 上，负责与 Looper 的消息队列交互。用于向线程的消息队列发送消息或任务。常用于在辅助线程中执行任务后，将结果发送到主线程更新 UI。Handler 是线程安全的，可以从不同线程发送消息到绑定的 Looper。</p>\n<h1 id=\"-59\"><a class=\"markdownIt-Anchor\" href=\"#-59\"></a> <a href=\"#%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3\"></a>四. 代码相关</h1>\n<h2 id=\"-60\"><a class=\"markdownIt-Anchor\" href=\"#-60\"></a> <a href=\"#1-%E6%B4%BB%E5%8A%A8%E7%B1%BB-appcompatactivity\"></a>1. 活动类 <code>AppCompatActivity</code></h2>\n<ul>\n<li>生命周期管理：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>调用时机</th>\n<th>主要用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onCreate()</td>\n<td>创建时调用。是生命周期的起点。</td>\n<td>一般用于设计布局、初始化控件、配置数据等。</td>\n</tr>\n<tr>\n<td>onStart()</td>\n<td>启动时调用，即用户即将看到它，但还没有与用户互动时。</td>\n<td>即将于用户交互时调用。是活跃状态。</td>\n</tr>\n<tr>\n<td>onResume()</td>\n<td>即将于用户交互时调用。是活跃状态。</td>\n<td>常用于恢复onStop中被释放的资源。</td>\n</tr>\n<tr>\n<td>onPause()</td>\n<td>失去焦点时调用。</td>\n<td>一般用于暂停动画、保存数据或释放资源。</td>\n</tr>\n<tr>\n<td>onStop()</td>\n<td>完全不可见时调用。比如说被另一个Activity全屏覆盖或应用被最小化。</td>\n<td>可以释放更多资源。</td>\n</tr>\n<tr>\n<td>onRestart()</td>\n<td>从停止变回可见状态时调用。此方法在onStart()之前被调用。</td>\n<td>释放掉所有的资源。</td>\n</tr>\n<tr>\n<td>onDestroy()</td>\n<td>被摧毁之前调用。是生命周期的终点。</td>\n<td>释放掉所有的资源。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>子活动相关：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Intent getIntent()</td>\n<td>获取启动激活的intent。没有则返回Null。</td>\n<td>var intent = getIntent()</td>\n</tr>\n<tr>\n<td>registerForActivityResult(ActivityResultContracts&lt;T, O&gt;, Callback<O>)</td>\n<td>用于注册ActivityResultLauncher<Intent>。</td>\n<td></td>\n</tr>\n<tr>\n<td>setResult(RESULT, Intent)</td>\n<td>返回启动它的Activity，并返回结果</td>\n<td>RESULT_OK: 操作成功<br>RESULT_CANCELED: 操作取消<br>RESULT_FIRST_USER: 自定义结果代码</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>其他辅助类：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>View findViewById()</code></td>\n<td>根据控件id寻找控件</td>\n<td><code>var a = findViewById(R.id.a);</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-61\"><a class=\"markdownIt-Anchor\" href=\"#-61\"></a> <a href=\"#2-%E8%A7%86%E5%9B%BE%E7%B1%BB-view\"></a>2. 视图类 <code>View</code></h2>\n<h3 id=\"-62\"><a class=\"markdownIt-Anchor\" href=\"#-62\"></a> <a href=\"#%E5%88%97%E8%A1%A8%E8%A7%86%E5%9B%BE-listview\"></a>列表视图 <code>ListView</code></h3>\n<h3 id=\"-63\"><a class=\"markdownIt-Anchor\" href=\"#-63\"></a> <a href=\"#%E5%9B%9E%E6%94%B6%E8%A7%86%E5%9B%BE-recyclerview\"></a>回收视图 <code>RecyclerView</code></h3>\n<p>可以动态创建并回收视图，提升性能。</p>\n<h2 id=\"-64\"><a class=\"markdownIt-Anchor\" href=\"#-64\"></a> <a href=\"#3-%E8%B5%84%E6%BA%90%E7%B1%BB-r\"></a>3. 资源类 <code>R</code></h2>\n<table>\n<thead>\n<tr>\n<th>子类</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>layout</code></td>\n<td>当前布局相关信息</td>\n<td><code>R.layout.activity_main</code></td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>控件id相关</td>\n<td><code>R.id.buttonCalculate</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"-65\"><a class=\"markdownIt-Anchor\" href=\"#-65\"></a> <a href=\"#4-%E6%84%8F%E5%9B%BE%E7%B1%BB-intent\"></a>4. 意图类 <code>Intent</code></h2>\n<p>用于给其他的 <code>Activity</code> 传递参数。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>putExtra(key, value)</code></td>\n<td>传递数据。</td>\n<td><code>intent.putExtra(&quot;result&quot;, 10);</code></td>\n</tr>\n<tr>\n<td><code>getStringExtra(key)</code></td>\n<td>根据<code>key</code>获取字符串数据。</td>\n<td><code>name = intent.getStringExtra(&quot;name&quot;);</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>父类打开子类，并返回给子类信息。</li>\n<li>子类返回父类，并返回给父类信息。<br />\n需要用到 <code>startActivityForResult(Intent, int)</code>，或者 <code>Activity Result API</code> 的 <code>ActivityResultLauncher</code> 打开子活动。</li>\n</ul>\n","feature":false,"text":"有关 安卓开发 的笔记。...","permalink":"/post/笔记/安卓开发/安卓开发","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"笔记-安卓开发","slug":"笔记-安卓开发","count":1,"path":"api/categories/笔记-安卓开发.json"}],"tags":[{"name":"Android","slug":"Android","count":1,"path":"api/tags/Android.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E5%AE%89%E5%8D%93%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 一.安卓介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\"> 0. 平台架构：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%81%B5%E6%B4%BB%E6%80%A7-flexibility\"><span class=\"toc-text\"> 1. 灵活性 (Flexibility)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%BC%E5%AE%B9%E6%80%A7-compatibility\"><span class=\"toc-text\"> 2. 兼容性 (Compatibility)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AE%89%E5%8D%93%E5%86%85%E6%A0%B8-kernel\"><span class=\"toc-text\"> 3. 安卓内核 (kernel)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%AE%89%E5%8D%93%E7%A1%AC%E4%BB%B6-hardware\"><span class=\"toc-text\"> 4. 安卓硬件 (hardware)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8\"><span class=\"toc-text\"> 5. 安卓应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\"> 6. 安卓启动过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-zygote\"><span class=\"toc-text\"> 7. Zygote</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-art\"><span class=\"toc-text\"> 8. ART</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E5%AE%89%E5%8D%93%E7%A1%AC%E4%BB%B6\"><span class=\"toc-text\"> 二. 安卓硬件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%80%E8%8A%AF%E7%89%87%E7%B3%BB%E7%BB%9F-system-on-a-chip-socs\"><span class=\"toc-text\"> 1. 一芯片系统 (System On A Chip, SOCs)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"> 2. ARM CPU vs Intel CPU (x86)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#-2\"><span class=\"toc-text\"> 三. 安卓软件的核心组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-3\"><span class=\"toc-text\"> 1. Activity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-4\"><span class=\"toc-text\"> a. View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-5\"><span class=\"toc-text\"> I. Views</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-6\"><span class=\"toc-text\"> II. ViewGroups - Layouts</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-7\"><span class=\"toc-text\"> III. Widgets</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-8\"><span class=\"toc-text\"> b. 数据绑定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-9\"><span class=\"toc-text\"> c. Manifest文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-10\"><span class=\"toc-text\"> d. Navigation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-11\"><span class=\"toc-text\"> i. 分层活动导航 (Hierarchical Activity Navigation)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-12\"><span class=\"toc-text\"> ii. Back 和 UP 导航</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-13\"><span class=\"toc-text\"> e. Fragments</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-14\"><span class=\"toc-text\"> f. Intents</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-15\"><span class=\"toc-text\"> i. 使用 Intent 启动&#x2F;停止一个 Activity</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-16\"><span class=\"toc-text\"> ii. 显式 vs 隐式 Intent</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-17\"><span class=\"toc-text\"> iii. Intent Filters for Deep Linking</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-18\"><span class=\"toc-text\"> g. Activity 之间的通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-19\"><span class=\"toc-text\"> h. Tasks vs Activities vs Processes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-20\"><span class=\"toc-text\"> i. 安卓开发中的任务管理。</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-21\"><span class=\"toc-text\"> Activity 与进程管理的核心概念</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-22\"><span class=\"toc-text\"> j. Activity 的生命周期管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-23\"><span class=\"toc-text\"> I. Activity 的三种主要状态：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-24\"><span class=\"toc-text\"> II. 优先级降低的 Activity</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-25\"><span class=\"toc-text\"> III. 注意事项</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-26\"><span class=\"toc-text\"> IV. 生命周期</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-27\"><span class=\"toc-text\"> V. UI保存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-28\"><span class=\"toc-text\"> VI. ViewModel：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#-29\"><span class=\"toc-text\"> VII. LiveData：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-30\"><span class=\"toc-text\"> 2. Service</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-31\"><span class=\"toc-text\"> a. 服务的生命周期（Service Lifecycle）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-32\"><span class=\"toc-text\"> b. 服务的类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-33\"><span class=\"toc-text\"> c. Activity与Service的通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-34\"><span class=\"toc-text\"> d. Notifications</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-35\"><span class=\"toc-text\"> e.服务的生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-36\"><span class=\"toc-text\"> f. 远程服务 Remote Service</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-37\"><span class=\"toc-text\"> g. 服务间通信（Communicating with Services）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-38\"><span class=\"toc-text\"> h. Messenger&#x2F;Handler&#x2F;Looper 关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-39\"><span class=\"toc-text\"> i. 消息传递（Message Transfer） 的机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-40\"><span class=\"toc-text\"> g. Parcelable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-41\"><span class=\"toc-text\"> h. Defining Remote Interface</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-42\"><span class=\"toc-text\"> J. IPC 进程间通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-43\"><span class=\"toc-text\"> k. 系统服务 (System Services)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-44\"><span class=\"toc-text\"> l. 服务管理器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-45\"><span class=\"toc-text\"> 3. Broadcast Receiver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-46\"><span class=\"toc-text\"> 4. Content Provider</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#-47\"><span class=\"toc-text\"> 三. 其他</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-48\"><span class=\"toc-text\"> 1. Kotlin</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-49\"><span class=\"toc-text\"> i. 为什么使用 Kotlin？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-50\"><span class=\"toc-text\"> ii. 为什么 Kotlin &gt; Java？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-51\"><span class=\"toc-text\"> iii. Coroutines 协程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-52\"><span class=\"toc-text\"> 2. Jetpack Compose</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-53\"><span class=\"toc-text\"> i. Composable Function</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-54\"><span class=\"toc-text\"> 3. 零日攻击 (Zero-day Attack)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-55\"><span class=\"toc-text\"> 4. 线程执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-56\"><span class=\"toc-text\"> I. 单线程模型：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-57\"><span class=\"toc-text\"> II. 线程管理：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-58\"><span class=\"toc-text\"> III. Looper and Handle</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#-59\"><span class=\"toc-text\"> 四. 代码相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-60\"><span class=\"toc-text\"> 1. 活动类 AppCompatActivity</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-61\"><span class=\"toc-text\"> 2. 视图类 View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-62\"><span class=\"toc-text\"> 列表视图 ListView</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#-63\"><span class=\"toc-text\"> 回收视图 RecyclerView</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-64\"><span class=\"toc-text\"> 3. 资源类 R</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#-65\"><span class=\"toc-text\"> 4. 意图类 Intent</span></a></li></ol></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"qq":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/cgi-bin/qm/qr?k=_glZz5Xy8An6DaliL38ZBfl7QhJGB_z9"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"计算机安全","uid":"75f1311d03df0221199bcef8867d80d0","slug":"笔记/计算机安全/计算机安全","date":"2025-05-20T10:00:00.000Z","updated":"2025-11-13T08:37:14.822Z","comments":true,"path":"api/articles/笔记/计算机安全/计算机安全.json","keywords":null,"cover":"/img/post/笔记/计算机安全/cover.png","text":"有关 计算机安全 的笔记。...","permalink":"/post/笔记/计算机安全/计算机安全","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"笔记-计算机安全","slug":"笔记-计算机安全","count":1,"path":"api/categories/笔记-计算机安全.json"}],"tags":[{"name":"Computer Security","slug":"Computer-Security","count":1,"path":"api/tags/Computer-Security.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"qq":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/cgi-bin/qm/qr?k=_glZz5Xy8An6DaliL38ZBfl7QhJGB_z9"}}}},"feature":false},"next_post":{"title":"问题-图染色","uid":"394fd5a3335536c852ff71e4cfa7feb9","slug":"笔记/问题/图染色","date":"2024-10-18T10:00:53.000Z","updated":"2025-11-15T18:07:59.182Z","comments":true,"path":"api/articles/笔记/问题/图染色.json","keywords":null,"cover":"/img/post/笔记/问题/图染色/cover.png","text":"有关图染色的问题：让所有的顶点都拥有一个颜色，并且没有两个相邻的顶点颜色相同。...","permalink":"/post/笔记/问题/图染色","photos":[],"count_time":{"symbolsCount":176,"symbolsTime":"1 mins."},"categories":[{"name":"笔记-问题","slug":"笔记-问题","count":3,"path":"api/categories/笔记-问题.json"}],"tags":[{"name":"Vertex Colouring Problem","slug":"Vertex-Colouring-Problem","count":1,"path":"api/tags/Vertex-Colouring-Problem.json"},{"name":"Graph Theory","slug":"Graph-Theory","count":2,"path":"api/tags/Graph-Theory.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"qq":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/cgi-bin/qm/qr?k=_glZz5Xy8An6DaliL38ZBfl7QhJGB_z9"}}}},"feature":false}}