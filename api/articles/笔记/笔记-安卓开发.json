{"title":"笔记-安卓开发","uid":"3ae50ab4ba4da3b0252b141ce255837e","slug":"笔记/笔记-安卓开发","date":"2024-10-31T14:58:02.000Z","updated":"2025-01-17T07:07:36.413Z","comments":true,"path":"api/articles/笔记/笔记-安卓开发.json","keywords":null,"cover":"\\img\\post\\笔记\\笔记-安卓开发\\cover.png","content":"<h1 id=\"️背景\"><a class=\"markdownIt-Anchor\" href=\"#️背景\"></a> ✒️背景</h1>\n<p>暂时没有背景。</p>\n<h1 id=\"介绍\"><a class=\"markdownIt-Anchor\" href=\"#介绍\"></a> 🔖介绍</h1>\n<p>暂时没有介绍。</p>\n<h1 id=\"一-安卓介绍\"><a class=\"markdownIt-Anchor\" href=\"#一-安卓介绍\"></a> 一. 安卓介绍</h1>\n<p>安卓(Android)是一个主要为手机和平板设计的操作系统(operating system)。其主要是基于 Linux 内核的修改版本构建，针对移动设备架构进行了优化，使用类似Java的环境进行应用开发（与传统Java平台不同）。</p>\n<p>其软件设计主要采用 Apache 许可证开源，鼓励社区开发和贡献。特定部分不是开源的。</p>\n<h2 id=\"0-平台架构\"><a class=\"markdownIt-Anchor\" href=\"#0-平台架构\"></a> 0. 平台架构：</h2>\n<p>从下到上：安卓内核(kernel)、硬件层、ART(Android Runtime)、Java API 架构、用户应用。</p>\n<h2 id=\"1-灵活性-flexibility\"><a class=\"markdownIt-Anchor\" href=\"#1-灵活性-flexibility\"></a> 1. 灵活性 (Flexibility)</h2>\n<p>其具有灵活性(Flexibility)和定制性(Customization)：</p>\n<ul>\n<li>允许硬件制造商进行定制，从而实现跨设备的多样化 Android 体验。</li>\n<li>支持自定义引导加载程序，实现更深层次的系统修改和 root 权限（在某些情况下）。</li>\n<li>root 权限提供 super 用户访问权限。</li>\n</ul>\n<h2 id=\"2-兼容性-compatibility\"><a class=\"markdownIt-Anchor\" href=\"#2-兼容性-compatibility\"></a> 2. 兼容性 (Compatibility)</h2>\n<p>具有向前和向后(Forward &amp; backward)兼容性支持。</p>\n<p>向后兼容性限制：</p>\n<ul>\n<li>无法使用早期版本中不存在的 API。</li>\n<li>开发人员可以为其应用指定最低 API 级别。</li>\n</ul>\n<p>许可和品牌：</p>\n<ul>\n<li>Android logo 已获得 Creative Commons (CC) 许可。</li>\n<li>标有“Android 手机”的设备必须：\n<ul>\n<li>通过特定的兼容性测试。</li>\n<li>支持 Android 设定的 API 标准。</li>\n</ul>\n</li>\n<li>Android”品牌仅授权给开放移动联盟(Open Mobile Alliance)成员。</li>\n</ul>\n<h2 id=\"3-安卓内核-kernel\"><a class=\"markdownIt-Anchor\" href=\"#3-安卓内核-kernel\"></a> 3. 安卓内核 (kernel)</h2>\n<p>安卓内核是基于 linux 的，但有一些特定的修改。</p>\n<ul>\n<li>电源管理增强(Power Management Enhancements)，包括唤醒锁(wakelock)。</li>\n<li>Binder IPC (进程间通信 Inter-Process Communication) 驱动程序：一种用于高效进程通信的自定义机制。</li>\n<li>Low Memory Killer：一种在内存不足的情况下优雅地终止进程的机制，根据重要性确定优先级。</li>\n<li>Ashmem (Anonymous Shared Memory 匿名共享内存)：</li>\n<li>Alarm Driver (警报驱动程序)：用于根据定时事件唤醒设备。</li>\n<li>OOM（Out of Memory 内存不足）调整：针对前台和后台进程采用不同的 OOM 处理方式。</li>\n</ul>\n<h2 id=\"4-安卓硬件-hardware\"><a class=\"markdownIt-Anchor\" href=\"#4-安卓硬件-hardware\"></a> 4. 安卓硬件 (hardware)</h2>\n<ul>\n<li>Bluetooth：BlueZ</li>\n<li>GPS：制造商提供的 <a href=\"http://libgps.so\">libgps.so</a></li>\n<li>Wifi：wpa_supplicant</li>\n<li>Display：标准帧缓冲驱动程序 Standardframebuffer driver</li>\n<li>Keyboard：标准输入事件 Standardinput event</li>\n<li>Lights：制造商提供的 <a href=\"http://liblights.so\">liblights.so</a></li>\n<li>Audio 音频：制造商提供的 <a href=\"http://libaudio.so\">libaudio.so</a></li>\n<li>Camera：制造商提供的 <a href=\"http://libcamera.so\">libcamera.so</a></li>\n<li>PowerManagement：“wakelocks” kernel patch</li>\n<li>Sensors：制造商提供的 <a href=\"http://libsensors.so\">libsensors.so</a></li>\n<li>Radio 无线电：制造商提供的 <a href=\"http://libril.so\">libril.so</a></li>\n</ul>\n<h2 id=\"5-安卓应用\"><a class=\"markdownIt-Anchor\" href=\"#5-安卓应用\"></a> 5. 安卓应用</h2>\n<p>安卓应用使用的是沙盒(sandboxing)模式：</p>\n<ul>\n<li>确保应用程序在隔离环境中运行，以确保安全。</li>\n<li>利用 Linux 多用户功能。\n<ul>\n<li>通常一部手机只有一个用户。</li>\n</ul>\n</li>\n<li>每一个应用都有自己的进程，运行在自己的虚拟机中，拥有独一无二的 UID/AID。</li>\n<li>确保应用程序无法访问其他应用程序的文件、数据或进程。</li>\n<li>利用内置的 Linux 安全措施，包括标准用户和 root 用户权限。\n<ul>\n<li>标准用户没有根访问权限。</li>\n<li>根访问权限涵盖整个系统，但通常拥有限制以增强安全性。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-安卓启动过程\"><a class=\"markdownIt-Anchor\" href=\"#6-安卓启动过程\"></a> 6. 安卓启动过程</h2>\n<ol>\n<li>启动 ROM/Bootloader：将引导加载程序加载到 RAM 中，检测外部 RAM、设置网络、内存等。</li>\n<li>启动内核：配置缓存、保护内存、调度并加载驱动程序。</li>\n<li>初始化：挂载 /sys、/dev 或 /proc 等目录，运行 init.rc 脚本。</li>\n<li>Zygote &amp; VM：允许在 Android VM 之间共享代码，以便快速启动不同应用的单独 VM。</li>\n<li>系统服务应用：电源管理器、活动管理器、电话、注册表、包管理器、上下文管理器、系统联系人提供程序等</li>\n</ol>\n<h2 id=\"7-zygote\"><a class=\"markdownIt-Anchor\" href=\"#7-zygote\"></a> 7. Zygote</h2>\n<p>Zygote 是 Android 启动序列的一部分，可帮助启动应用程序。系统通过 Zygote 进行初始化，从而在 Dalvik（旧版 Android）或 ART（新版 Android）上执行应用。</p>\n<p>出于安全和隔离的原因，Android 应用程序在单独的进程中运行。每次启动应用程序时，启动一个新进程并从头开始设置 Android runtime (ART) 的新实例效率很低。</p>\n<p>Zygote 是辅助其启动的一个系统进程，初始化时包含所有必要系统库的主进程，这可确保常用资源已预先加载并在应用程序之间共享。在系统启动时，它会加载基本 Java 和 Android 类（java.<em>、android.</em>）。此预加载可缩短后续应用的启动时间。</p>\n<p>Android应用在启动时会从Zygote进程派生一个新的进程，以减少应用启动时的初始化开销。减少了应用进程从零开始的初始化时间，提高了Android设备多任务或快速切换应用时的性能。</p>\n<p>安卓虚拟机创建依赖 Zygote:</p>\n<ul>\n<li>Single Instance: 系统启动后，Zygote 会创建 Android 虚拟机（Dalvik 或 ART，具体取决于版本）的单实例。</li>\n<li>Class Reference: 此 VM 已准备好在 Zygote 初始化期间加载的类，确保用户应用快速启动和响应。</li>\n</ul>\n<h2 id=\"8-art\"><a class=\"markdownIt-Anchor\" href=\"#8-art\"></a> 8. ART</h2>\n<p>ART是用来替代Dalvik虚拟机的东西，其特点如下：</p>\n<ul>\n<li>AOT 预编译（Ahead-Of-Time Compilation）：在应用安装时就会进行预编译，将应用的字节码（.dex 文件）编译为本地机器码并存储下来。这样在应用运行时，省去了重复的 JIT（Just-In-Time）编译过程，启动更快，性能更高。</li>\n<li>更高效的垃圾回收（Garbage Collection）：ART 采用分代式垃圾回收（Generational GC）或其他更先进的 GC 技术，减少卡顿并降低对应用运行的干扰。</li>\n<li>更好的调试工具和诊断能力：ART 提供了更丰富的调试选项和运行分析工具，如更详细的内存分析、线程分析等，方便开发者进行性能优化。</li>\n<li>兼容性：虽然 ART 采用的是与 Dalvik 不同的执行机制，但大多数应用无需进行改动就可在 ART 上运行，Google 在实现中保留了较高程度的向后兼容。</li>\n</ul>\n<h1 id=\"安卓硬件\"><a class=\"markdownIt-Anchor\" href=\"#安卓硬件\"></a> 安卓硬件</h1>\n<h2 id=\"1-一芯片系统-system-on-a-chip-socs\"><a class=\"markdownIt-Anchor\" href=\"#1-一芯片系统-system-on-a-chip-socs\"></a> 1. 一芯片系统 (System On A Chip, SOCs)</h2>\n<ul>\n<li>仅使用芯片上的部分晶体管组成 CPU\n<ul>\n<li>使用其余晶体管构建系统的其他组件</li>\n<li>外部引脚直接连接到外围硬件</li>\n</ul>\n</li>\n<li>在芯片上集成多个异构组件\n<ul>\n<li>减少通信开销</li>\n<li>减少热量</li>\n</ul>\n</li>\n<li>晶体管提供计算、存储\n<ul>\n<li>将芯片划分为多个通信区域</li>\n</ul>\n</li>\n<li>通用架构\n<ul>\n<li>CPU 核心：ARM Cortex 系列（例如 Cortex-A78）</li>\n<li>用于 AI 任务的神经处理单元 (NPU)</li>\n</ul>\n</li>\n<li>差异\n<ul>\n<li>人工智能和机器学习的集成：SoC 越来越多地包含用于机器学习和人工智能的专用核心，从而增强了面部识别和增强现实等功能。</li>\n</ul>\n</li>\n<li>根据用例进行定制\n<ul>\n<li>不同的 SoC 针对不同的性能需求进行了优化，例如游戏、摄影或能效。可以拥有独特的配套模块。</li>\n</ul>\n</li>\n<li>封装层叠 (Package on Package, PoP)：\n<ul>\n<li>背景：传统 SoC 中的 RAM集成度各不相同，在现代 SoC 中，集成 RAM 更为常见，但配置可能因应用需求而异。</li>\n<li>定义：一种将内存封装直接安装在 SoC 顶部的封装技术。</li>\n<li>生产灵活性：允许独立生产和测试内存和逻辑组件。</li>\n<li>空间优化：垂直堆叠组件以节省水平空间，这对于紧凑型设备设计至关重要</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-arm-cpu-vs-intel-cpu-x86\"><a class=\"markdownIt-Anchor\" href=\"#2-arm-cpu-vs-intel-cpu-x86\"></a> 2. ARM CPU vs Intel CPU (x86)</h2>\n<p>约 95% 的智能手机使用 ARM CPU，其余设备使用 Intel、MIPS 等。</p>\n<ul>\n<li>为什么使用ARM？</li>\n<li>快速高效的操作。</li>\n<li>更高的代码密度可实现更紧凑的设计。</li>\n<li>减少组件堆积，提高空间利用率。</li>\n</ul>\n<p>ARM 指令的特点：</p>\n<ul>\n<li>每条指令尽可能只使用一个周期。</li>\n<li>每条指令的长度为 32bit</li>\n<li>几乎每条指令都具有条件执行功能。</li>\n<li>一般寄存器：\n<ul>\n<li>R0-R12：一般目的的寄存器</li>\n<li>R13：栈寄存器</li>\n<li>R14：链接寄存器</li>\n<li>R15：PC</li>\n</ul>\n</li>\n<li>并不是所有的指令都用到 32bit，这会导致潜在的低效率，因此使用 Thumb 指令：\n<ul>\n<li>Thumb 指令使用紧凑的 ARM 16-bit 指令集。</li>\n<li>使用可变长度指令集，保留最常用的ARM指令并将它们编码成16位。\n<ul>\n<li>通过减少指令大小，实现了更快的速度。</li>\n<li>一次32-bit内存可以检索两个16位 Thumb 指令。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>ARM bit.LITTLE：</p>\n<ul>\n<li>ARM 使用大小核，通过集成强大的 (big) 内核和高效的 (LITTLE) 内核，将高性能与能效相结合。</li>\n<li>系统可以根据当前任务的需求在核心之间无缝切换，确保最佳性能和效率。</li>\n</ul>\n<h1 id=\"安卓软件的核心组件\"><a class=\"markdownIt-Anchor\" href=\"#安卓软件的核心组件\"></a> 安卓软件的核心组件</h1>\n<p>安卓与传统Java应用不同，可以有多个入口点。这些入口点定义了安卓系统可以与应用程序交互或者进入应用程序的方式，包括活动(Activity)、服务(Service)、广播收集器(Broadcast Receiver)和内容提供程序(Content Provider)。</p>\n<p>传统的操作系统通常只有一个 Main 入口点，并且操作系统将程序加载到进程中并执行，实例化 Java VM 加载应用程序使用的所有类 执行 main。</p>\n<p>而安卓中是基于component的模型，拥有多个应用程序入口点：</p>\n<ul>\n<li>Zygote fork 后仍执行 main 函数，但在此基础上进行抽象。</li>\n<li>并非所有都是用户的入口点。</li>\n<li>每个component都作为逻辑上独立的唯一实体存在</li>\n</ul>\n<p>一个 Android 应用程序应该包含多个组件，并且用户经常在短时间内与多个应用程序进行交互，因此应用程序需要适应不同类型的用户驱动的工作流程和任务。</p>\n<p>安卓的特定组件通常是由特定interface进行通信，在运行时进行绑定。每个组件都有特定的生命周期，根据需要动态加载和卸载。</p>\n<h2 id=\"1-activity\"><a class=\"markdownIt-Anchor\" href=\"#1-activity\"></a> 1. Activity</h2>\n<p>包括UI组件，View。是 android.app.Activity 的子类。其提供一个虚拟的UI，每一个 Activity 都拥有自己的窗口。</p>\n<h3 id=\"a-view\"><a class=\"markdownIt-Anchor\" href=\"#a-view\"></a> a. View</h3>\n<p>UI layout属于一个View，是一种资源，在单独的通过编程构建的XML文件中指定。</p>\n<ul>\n<li>View的子类包含：\n<ul>\n<li>Views: 用来显示一些内容</li>\n<li>Widgets: 执行某些操作</li>\n<li>ViewGroups：布局子视图</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"i-views\"><a class=\"markdownIt-Anchor\" href=\"#i-views\"></a> I. Views</h4>\n<ul>\n<li>设计规范：\n<ul>\n<li>首选浅布局层次结构。</li>\n<li>尽可能减少嵌套布局（遍历成本）。</li>\n<li>wide over deep。</li>\n</ul>\n</li>\n<li>编程方面：\n<ul>\n<li>可以使用使用 <code>setContentView()</code> 来指定Activity的View。</li>\n<li>可以使用 <code>addView()</code>、<code>removeView()</code> 来改变视图的层次结构。</li>\n<li>根据 XML 布局定义生成的ID，使用 <code>R.layout.ID</code> 来找到特定的视图。</li>\n<li>可以将 View 和数据绑定在一起。</li>\n</ul>\n</li>\n<li>策略：\n<ul>\n<li>手机很少是相同的，通常具有不同的屏幕尺寸和宽高比、各种分辨率。所以应该避免硬编码 UI 组件配置细节。</li>\n<li>布局应该适应其所填充的屏幕：\n<ul>\n<li>将布局定义为层次结构和关系。</li>\n<li>使用以密度无关像素 (density-independent pixels,dp) 而不是 px 定义测量值\n<ul>\n<li>1dp 相当于 160dpi 上的一个像素。</li>\n</ul>\n</li>\n<li>可以定义特定于配置的布局\n<ul>\n<li>Small, normal, large and extra large.</li>\n<li>使用最小宽度限定符</li>\n<li>使用方向限定符</li>\n<li>进行规划，例如 <code>res/layout-sw600dp/main_activity.xml</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ii-viewgroups-layouts\"><a class=\"markdownIt-Anchor\" href=\"#ii-viewgroups-layouts\"></a> II. ViewGroups - Layouts</h4>\n<p>Layouts通常包含：</p>\n<ul>\n<li>FrameLayout：最简单的layout，只包含一个物体。</li>\n<li>LinearLayout：根据方向属性，将所有子项对齐到单一方向。</li>\n<li>TableLayout：将子项定位到行和列中</li>\n<li>ConstraintLayout / RelativeLayout：让子视图指定它们相对于父视图或彼此的位置，使用对齐进行约束。</li>\n<li>ScrollView：垂直滚动视图。</li>\n<li>SwipeRefreshLayout：实现“下拉刷新”交互效果的控件。检测垂直滑动、显示进度条并触发回调方法。</li>\n</ul>\n<h4 id=\"iii-widgets\"><a class=\"markdownIt-Anchor\" href=\"#iii-widgets\"></a> III. Widgets</h4>\n<p>用于可以交互的子View：</p>\n<ul>\n<li>Button</li>\n<li>TextView</li>\n<li>EditText</li>\n<li>CalendarViewer</li>\n<li>ImageView</li>\n</ul>\n<p>这些组件可以处理UI事件：</p>\n<ul>\n<li>代码中，可以使用 <code>setOnClickListener()</code>。</li>\n<li>在XML中，可以设置 <code>android:onClick=&quot;&quot;</code> 参数。</li>\n</ul>\n<p>这些组件可以文字展示：</p>\n<ul>\n<li>代码中，可以使用 <code>.getText()</code> 和 <code>.setText()</code></li>\n<li>在XML中，设置 <code>android:text=&quot;&quot;</code> 参数，例如 <code>android:text=&quot;@string/hello_world&quot;</code></li>\n</ul>\n<h3 id=\"b-数据绑定\"><a class=\"markdownIt-Anchor\" href=\"#b-数据绑定\"></a> b. 数据绑定</h3>\n<p>传统model中，设计大量样本代码(boilerplate code)：</p>\n<ul>\n<li>Activity 和 Model 紧密耦合</li>\n<li>处理 Activity 中的 onClick 事件</li>\n<li>查找对相关视图的引用</li>\n<li>检索内容（例如文本字段的内容）</li>\n<li>将结果写回视图</li>\n</ul>\n<p>一个数据模型应该：</p>\n<ul>\n<li>将 POJO 绑定到View组件以进行初始填充</li>\n<li>使对象可观察，以便在更改时自动更新 UI\n<ul>\n<li>如继承&quot;BaseObservable&quot;，或者使用&quot;ViewModel + Livedata&quot;。</li>\n<li>使用可观察域，即 <code>@&#123;&#125;</code> 和 <code>@=&#123;&#125;</code></li>\n<li>可观察的objects, fields and collections</li>\n</ul>\n</li>\n<li>Data Binding Library：\n<ul>\n<li>是一种直接在XML中与类的成员进行绑定的方法，减少了在Activity中进行初始化的方法。</li>\n<li>即从layout中引用model对象。</li>\n<li>会生成必要的绑定类。</li>\n<li>包括基本格式表达式。</li>\n</ul>\n</li>\n<li>双向数据绑定，允许从View更新Object，反之亦然</li>\n</ul>\n<p>数据绑定的实现方法：<br />\n引用数据：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">variable</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewmodel&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.example.myapplication.MyModel&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可观察域：</p>\n<ul>\n<li><code>@&#123;&#125;</code>：接收数据变化，是单项绑定。</li>\n<li><code>@=&#123;&#125;</code>：接收属性的数据更改并监听用户更新，是双向绑定。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:progress = &quot;@=&#123;viewmodel.progress&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-service\"><a class=\"markdownIt-Anchor\" href=\"#2-service\"></a> 2. Service</h2>\n<p>在后台执行长时间运行操作的机制。</p>\n<h2 id=\"3-broadcast-receiver\"><a class=\"markdownIt-Anchor\" href=\"#3-broadcast-receiver\"></a> 3. Broadcast Receiver</h2>\n<p>响应来自操作系统/其他应用程序的广播消息。</p>\n<h2 id=\"4-content-provider\"><a class=\"markdownIt-Anchor\" href=\"#4-content-provider\"></a> 4. Content Provider</h2>\n<p>使数据可供其他应用程序使用/利用来自其他应用程序的数据。</p>\n<h2 id=\"5-intent\"><a class=\"markdownIt-Anchor\" href=\"#5-intent\"></a> 5. Intent</h2>\n<h1 id=\"代码相关\"><a class=\"markdownIt-Anchor\" href=\"#代码相关\"></a> 代码相关</h1>\n<h2 id=\"1-活动类-appcompatactivity\"><a class=\"markdownIt-Anchor\" href=\"#1-活动类-appcompatactivity\"></a> 1. 活动类 <code>AppCompatActivity</code></h2>\n<ul>\n<li>生命周期管理：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>重写方法</th>\n<th>说明</th>\n<th>使用补充</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onCreate()</code></td>\n<td>创建时调用。<br>是生命周期的起点。</td>\n<td>一般用于设计布局、初始化控件、配置数据等。</td>\n</tr>\n<tr>\n<td><code>onStart()</code></td>\n<td>启动时调用，即用户即将看到它，但还没有与用户互动时。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>onResume()</code></td>\n<td>即将于用户交互时调用。是活跃状态。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>onPause()</code></td>\n<td>失去焦点时调用。</td>\n<td>一般用于暂停动画、保存数据或释放资源。</td>\n</tr>\n<tr>\n<td><code>onStop()</code></td>\n<td>完全不可见时调用。<br>比如说被另一个<code>Activity</code>全屏覆盖或应用被最小化。</td>\n<td>可以释放更多资源。</td>\n</tr>\n<tr>\n<td><code>onRestart()</code></td>\n<td>从停止变回可见状态时调用。<br>此方法在<code>onStart()</code>之前被调用。</td>\n<td>常用于恢复<code>onStop</code>中被释放的资源。</td>\n</tr>\n<tr>\n<td><code>onDestory()</code></td>\n<td>被摧毁之前调用。<br>是生命周期的终点。</td>\n<td>释放掉所有的资源.</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>子活动相关：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Intent getIntent()</code></td>\n<td>获取启动该活动的intent。没有则返回<code>Null</code>。</td>\n<td><code>var intent = getIntent()</code></td>\n</tr>\n<tr>\n<td><code>registerForActivityResult(ActivityResultContracts&lt;I, O&gt;, Callback&lt;O&gt;)</code></td>\n<td>用于注册<code>ActivityResultLauncher&lt;Intent&gt;</code>。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>setRusult(RESULT, Intent)</code></td>\n<td>返回启动它的 <code>Activity</code>，并返回结果</td>\n<td><code>RESULT_OK</code>: 操作成功<br><code>RESULT_CANCELED</code>：操作取消<br><code>RESULT_FIRST_USER</code>：自动定义结果代码</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>其他辅助类：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>View findViewById()</code></td>\n<td>根据控件id寻找控件</td>\n<td><code>var a = findViewById(R.id.a);</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-视图类-view\"><a class=\"markdownIt-Anchor\" href=\"#2-视图类-view\"></a> 2. 视图类 <code>View</code></h2>\n<h3 id=\"列表视图-listview\"><a class=\"markdownIt-Anchor\" href=\"#列表视图-listview\"></a> 列表视图 <code>ListView</code></h3>\n<h3 id=\"回收视图-recyclerview\"><a class=\"markdownIt-Anchor\" href=\"#回收视图-recyclerview\"></a> 回收视图 <code>RecyclerView</code></h3>\n<p>可以动态创建并回收视图，提升性能。</p>\n<h2 id=\"3-资源类-r\"><a class=\"markdownIt-Anchor\" href=\"#3-资源类-r\"></a> 3. 资源类 <code>R</code></h2>\n<table>\n<thead>\n<tr>\n<th>子类</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>layout</code></td>\n<td>当前布局相关信息</td>\n<td><code>R.layout.activity_main</code></td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>控件id相关</td>\n<td><code>R.id.buttonCalculate</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"4-意图类-intent\"><a class=\"markdownIt-Anchor\" href=\"#4-意图类-intent\"></a> 4. 意图类 <code>Intent</code></h2>\n<p>用于给其他的 <code>Activity</code> 传递参数。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>putExtra(key, value)</code></td>\n<td>传递数据。</td>\n<td><code>intent.putExtra(&quot;result&quot;, 10);</code></td>\n</tr>\n<tr>\n<td><code>getStringExtra(key)</code></td>\n<td>根据<code>key</code>获取字符串数据。</td>\n<td><code>name = intent.getStringExtra(&quot;name&quot;);</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>父类打开子类，并返回给子类信息。</li>\n<li>子类返回父类，并返回给父类信息。<br />\n需要用到 <code>startActivityForResult(Intent, int)</code>，或者 <code>Activity Result API</code> 的 <code>ActivityResultLauncher</code> 打开子活动。</li>\n</ul>\n","feature":false,"text":"关于安卓开发的笔记。...","permalink":"/post/笔记/笔记-安卓开发","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"笔记","slug":"笔记","count":9,"path":"api/categories/笔记.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":1,"path":"api/tags/JAVA.json"},{"name":"Android","slug":"Android","count":1,"path":"api/tags/Android.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%B8%8F%E8%83%8C%E6%99%AF\"><span class=\"toc-text\"> ✒️背景</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 🔖介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%AE%89%E5%8D%93%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 一. 安卓介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\"> 0. 平台架构：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%81%B5%E6%B4%BB%E6%80%A7-flexibility\"><span class=\"toc-text\"> 1. 灵活性 (Flexibility)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%BC%E5%AE%B9%E6%80%A7-compatibility\"><span class=\"toc-text\"> 2. 兼容性 (Compatibility)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AE%89%E5%8D%93%E5%86%85%E6%A0%B8-kernel\"><span class=\"toc-text\"> 3. 安卓内核 (kernel)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%AE%89%E5%8D%93%E7%A1%AC%E4%BB%B6-hardware\"><span class=\"toc-text\"> 4. 安卓硬件 (hardware)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8\"><span class=\"toc-text\"> 5. 安卓应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\"> 6. 安卓启动过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-zygote\"><span class=\"toc-text\"> 7. Zygote</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-art\"><span class=\"toc-text\"> 8. ART</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%8D%93%E7%A1%AC%E4%BB%B6\"><span class=\"toc-text\"> 安卓硬件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%80%E8%8A%AF%E7%89%87%E7%B3%BB%E7%BB%9F-system-on-a-chip-socs\"><span class=\"toc-text\"> 1. 一芯片系统 (System On A Chip, SOCs)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-arm-cpu-vs-intel-cpu-x86\"><span class=\"toc-text\"> 2. ARM CPU vs Intel CPU (x86)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\"> 安卓软件的核心组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-activity\"><span class=\"toc-text\"> 1. Activity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-view\"><span class=\"toc-text\"> a. View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#i-views\"><span class=\"toc-text\"> I. Views</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ii-viewgroups-layouts\"><span class=\"toc-text\"> II. ViewGroups - Layouts</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#iii-widgets\"><span class=\"toc-text\"> III. Widgets</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\"> b. 数据绑定</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-service\"><span class=\"toc-text\"> 2. Service</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-broadcast-receiver\"><span class=\"toc-text\"> 3. Broadcast Receiver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-content-provider\"><span class=\"toc-text\"> 4. Content Provider</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-intent\"><span class=\"toc-text\"> 5. Intent</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\"> 代码相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%B4%BB%E5%8A%A8%E7%B1%BB-appcompatactivity\"><span class=\"toc-text\"> 1. 活动类 AppCompatActivity</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%A7%86%E5%9B%BE%E7%B1%BB-view\"><span class=\"toc-text\"> 2. 视图类 View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E8%A7%86%E5%9B%BE-listview\"><span class=\"toc-text\"> 列表视图 ListView</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%94%B6%E8%A7%86%E5%9B%BE-recyclerview\"><span class=\"toc-text\"> 回收视图 RecyclerView</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%B5%84%E6%BA%90%E7%B1%BB-r\"><span class=\"toc-text\"> 3. 资源类 R</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%84%8F%E5%9B%BE%E7%B1%BB-intent\"><span class=\"toc-text\"> 4. 意图类 Intent</span></a></li></ol></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"语言学习导航","uid":"625e3e920d4d18f0b54366f772b38b35","slug":"导航/导航-语言学习导航","date":"2024-05-24T10:44:53.000Z","updated":"2024-05-27T18:02:00.416Z","comments":true,"path":"api/articles/导航/导航-语言学习导航.json","keywords":null,"cover":"\\img\\post\\导航\\导航-语言学习导航\\cover.jpg","text":"关于语言学习的导航。...","permalink":"/post/导航/导航-语言学习导航","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"导航","slug":"导航","count":4,"path":"api/categories/导航.json"}],"tags":[{"name":"Languaue","slug":"Languaue","count":1,"path":"api/tags/Languaue.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"feature":true},"next_post":{"title":"笔记-LaTeX","uid":"24ad0055d0e4d9377d4df87cbfd9108d","slug":"笔记/笔记-LaTeX","date":"2024-10-25T23:33:20.000Z","updated":"2024-10-26T00:16:19.616Z","comments":true,"path":"api/articles/笔记/笔记-LaTeX.json","keywords":null,"cover":"\\img\\post\\笔记\\笔记-LaTeX\\cover.png","text":"关于LaTeX的笔记...","permalink":"/post/笔记/笔记-LaTeX","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"笔记","slug":"笔记","count":9,"path":"api/categories/笔记.json"}],"tags":[{"name":"LaTeX","slug":"LaTeX","count":1,"path":"api/tags/LaTeX.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"feature":false}}