{"title":"笔记-安卓开发","uid":"3ae50ab4ba4da3b0252b141ce255837e","slug":"笔记/笔记-安卓开发","date":"2024-10-31T22:58:02.000Z","updated":"2025-01-20T17:51:55.341Z","comments":true,"path":"api/articles/笔记/笔记-安卓开发.json","keywords":null,"cover":"\\img\\post\\笔记\\笔记-安卓开发\\cover.png","content":"<h1 id=\"️背景\"><a class=\"markdownIt-Anchor\" href=\"#️背景\"></a> ✒️背景</h1>\n<p>暂时没有背景。</p>\n<h1 id=\"介绍\"><a class=\"markdownIt-Anchor\" href=\"#介绍\"></a> 🔖介绍</h1>\n<p>暂时没有介绍。</p>\n<h1 id=\"一-安卓介绍\"><a class=\"markdownIt-Anchor\" href=\"#一-安卓介绍\"></a> 一. 安卓介绍</h1>\n<p>安卓(Android)是一个主要为手机和平板设计的操作系统(operating system)。其主要是基于 Linux 内核的修改版本构建，针对移动设备架构进行了优化，使用类似Java的环境进行应用开发（与传统Java平台不同）。</p>\n<p>其软件设计主要采用 Apache 许可证开源，鼓励社区开发和贡献。特定部分不是开源的。</p>\n<h2 id=\"0-平台架构\"><a class=\"markdownIt-Anchor\" href=\"#0-平台架构\"></a> 0. 平台架构：</h2>\n<p>从下到上：安卓内核(kernel)、硬件层、ART(Android Runtime)、Java API 架构、用户应用。</p>\n<h2 id=\"1-灵活性-flexibility\"><a class=\"markdownIt-Anchor\" href=\"#1-灵活性-flexibility\"></a> 1. 灵活性 (Flexibility)</h2>\n<p>其具有灵活性(Flexibility)和定制性(Customization)：</p>\n<ul>\n<li>允许硬件制造商进行定制，从而实现跨设备的多样化 Android 体验。</li>\n<li>支持自定义引导加载程序，实现更深层次的系统修改和 root 权限（在某些情况下）。</li>\n<li>root 权限提供 super 用户访问权限。</li>\n</ul>\n<h2 id=\"2-兼容性-compatibility\"><a class=\"markdownIt-Anchor\" href=\"#2-兼容性-compatibility\"></a> 2. 兼容性 (Compatibility)</h2>\n<p>具有向前和向后(Forward &amp; backward)兼容性支持。</p>\n<p>向后兼容性限制：</p>\n<ul>\n<li>无法使用早期版本中不存在的 API。</li>\n<li>开发人员可以为其应用指定最低 API 级别。</li>\n</ul>\n<p>许可和品牌：</p>\n<ul>\n<li>Android logo 已获得 Creative Commons (CC) 许可。</li>\n<li>标有“Android 手机”的设备必须：\n<ul>\n<li>通过特定的兼容性测试。</li>\n<li>支持 Android 设定的 API 标准。</li>\n</ul>\n</li>\n<li>Android”品牌仅授权给开放移动联盟(Open Mobile Alliance)成员。</li>\n</ul>\n<h2 id=\"3-安卓内核-kernel\"><a class=\"markdownIt-Anchor\" href=\"#3-安卓内核-kernel\"></a> 3. 安卓内核 (kernel)</h2>\n<p>安卓内核是基于 linux 的，但有一些特定的修改。</p>\n<ul>\n<li>电源管理增强(Power Management Enhancements)，包括唤醒锁(wakelock)。</li>\n<li>Binder IPC (进程间通信 Inter-Process Communication) 驱动程序：一种用于高效进程通信的自定义机制。</li>\n<li>Low Memory Killer：一种在内存不足的情况下优雅地终止进程的机制，根据重要性确定优先级。</li>\n<li>Ashmem (Anonymous Shared Memory 匿名共享内存)：</li>\n<li>Alarm Driver (警报驱动程序)：用于根据定时事件唤醒设备。</li>\n<li>OOM（Out of Memory 内存不足）调整：针对前台和后台进程采用不同的 OOM 处理方式。</li>\n</ul>\n<h2 id=\"4-安卓硬件-hardware\"><a class=\"markdownIt-Anchor\" href=\"#4-安卓硬件-hardware\"></a> 4. 安卓硬件 (hardware)</h2>\n<ul>\n<li>Bluetooth：BlueZ</li>\n<li>GPS：制造商提供的 <a href=\"http://libgps.so\">libgps.so</a></li>\n<li>Wifi：wpa_supplicant</li>\n<li>Display：标准帧缓冲驱动程序 Standardframebuffer driver</li>\n<li>Keyboard：标准输入事件 Standardinput event</li>\n<li>Lights：制造商提供的 <a href=\"http://liblights.so\">liblights.so</a></li>\n<li>Audio 音频：制造商提供的 <a href=\"http://libaudio.so\">libaudio.so</a></li>\n<li>Camera：制造商提供的 <a href=\"http://libcamera.so\">libcamera.so</a></li>\n<li>PowerManagement：“wakelocks” kernel patch</li>\n<li>Sensors：制造商提供的 <a href=\"http://libsensors.so\">libsensors.so</a></li>\n<li>Radio 无线电：制造商提供的 <a href=\"http://libril.so\">libril.so</a></li>\n</ul>\n<h2 id=\"5-安卓应用\"><a class=\"markdownIt-Anchor\" href=\"#5-安卓应用\"></a> 5. 安卓应用</h2>\n<p>安卓应用使用的是沙盒(sandboxing)模式：</p>\n<ul>\n<li>确保应用程序在隔离环境中运行，以确保安全。</li>\n<li>利用 Linux 多用户功能。\n<ul>\n<li>通常一部手机只有一个用户。</li>\n</ul>\n</li>\n<li>每一个应用都有自己的进程，运行在自己的虚拟机中，拥有独一无二的 UID/AID。</li>\n<li>确保应用程序无法访问其他应用程序的文件、数据或进程。</li>\n<li>利用内置的 Linux 安全措施，包括标准用户和 root 用户权限。\n<ul>\n<li>标准用户没有根访问权限。</li>\n<li>根访问权限涵盖整个系统，但通常拥有限制以增强安全性。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-安卓启动过程\"><a class=\"markdownIt-Anchor\" href=\"#6-安卓启动过程\"></a> 6. 安卓启动过程</h2>\n<ol>\n<li>启动 ROM/Bootloader：将引导加载程序加载到 RAM 中，检测外部 RAM、设置网络、内存等。</li>\n<li>启动内核：配置缓存、保护内存、调度并加载驱动程序。</li>\n<li>初始化：挂载 /sys、/dev 或 /proc 等目录，运行 init.rc 脚本。</li>\n<li>Zygote &amp; VM：允许在 Android VM 之间共享代码，以便快速启动不同应用的单独 VM。</li>\n<li>系统服务应用：电源管理器、活动管理器、电话、注册表、包管理器、上下文管理器、系统联系人提供程序等</li>\n</ol>\n<h2 id=\"7-zygote\"><a class=\"markdownIt-Anchor\" href=\"#7-zygote\"></a> 7. Zygote</h2>\n<p>Zygote 是 Android 启动序列的一部分，可帮助启动应用程序。系统通过 Zygote 进行初始化，从而在 Dalvik（旧版 Android）或 ART（新版 Android）上执行应用。</p>\n<p>出于安全和隔离的原因，Android 应用程序在单独的进程中运行。每次启动应用程序时，启动一个新进程并从头开始设置 Android runtime (ART) 的新实例效率很低。</p>\n<p>Zygote 是辅助其启动的一个系统进程，初始化时包含所有必要系统库的主进程，这可确保常用资源已预先加载并在应用程序之间共享。在系统启动时，它会加载基本 Java 和 Android 类（java.<em>、android.</em>）。此预加载可缩短后续应用的启动时间。</p>\n<p>Android应用在启动时会从Zygote进程派生一个新的进程，以减少应用启动时的初始化开销。减少了应用进程从零开始的初始化时间，提高了Android设备多任务或快速切换应用时的性能。</p>\n<p>安卓虚拟机创建依赖 Zygote:</p>\n<ul>\n<li>Single Instance: 系统启动后，Zygote 会创建 Android 虚拟机（Dalvik 或 ART，具体取决于版本）的单实例。</li>\n<li>Class Reference: 此 VM 已准备好在 Zygote 初始化期间加载的类，确保用户应用快速启动和响应。</li>\n</ul>\n<h2 id=\"8-art\"><a class=\"markdownIt-Anchor\" href=\"#8-art\"></a> 8. ART</h2>\n<p>ART是用来替代Dalvik虚拟机的东西，其特点如下：</p>\n<ul>\n<li>AOT 预编译（Ahead-Of-Time Compilation）：在应用安装时就会进行预编译，将应用的字节码（.dex 文件）编译为本地机器码并存储下来。这样在应用运行时，省去了重复的 JIT（Just-In-Time）编译过程，启动更快，性能更高。</li>\n<li>更高效的垃圾回收（Garbage Collection）：ART 采用分代式垃圾回收（Generational GC）或其他更先进的 GC 技术，减少卡顿并降低对应用运行的干扰。</li>\n<li>更好的调试工具和诊断能力：ART 提供了更丰富的调试选项和运行分析工具，如更详细的内存分析、线程分析等，方便开发者进行性能优化。</li>\n<li>兼容性：虽然 ART 采用的是与 Dalvik 不同的执行机制，但大多数应用无需进行改动就可在 ART 上运行，Google 在实现中保留了较高程度的向后兼容。</li>\n</ul>\n<h1 id=\"安卓硬件\"><a class=\"markdownIt-Anchor\" href=\"#安卓硬件\"></a> 安卓硬件</h1>\n<h2 id=\"1-一芯片系统-system-on-a-chip-socs\"><a class=\"markdownIt-Anchor\" href=\"#1-一芯片系统-system-on-a-chip-socs\"></a> 1. 一芯片系统 (System On A Chip, SOCs)</h2>\n<ul>\n<li>仅使用芯片上的部分晶体管组成 CPU\n<ul>\n<li>使用其余晶体管构建系统的其他组件</li>\n<li>外部引脚直接连接到外围硬件</li>\n</ul>\n</li>\n<li>在芯片上集成多个异构组件\n<ul>\n<li>减少通信开销</li>\n<li>减少热量</li>\n</ul>\n</li>\n<li>晶体管提供计算、存储\n<ul>\n<li>将芯片划分为多个通信区域</li>\n</ul>\n</li>\n<li>通用架构\n<ul>\n<li>CPU 核心：ARM Cortex 系列（例如 Cortex-A78）</li>\n<li>用于 AI 任务的神经处理单元 (NPU)</li>\n</ul>\n</li>\n<li>差异\n<ul>\n<li>人工智能和机器学习的集成：SoC 越来越多地包含用于机器学习和人工智能的专用核心，从而增强了面部识别和增强现实等功能。</li>\n</ul>\n</li>\n<li>根据用例进行定制\n<ul>\n<li>不同的 SoC 针对不同的性能需求进行了优化，例如游戏、摄影或能效。可以拥有独特的配套模块。</li>\n</ul>\n</li>\n<li>封装层叠 (Package on Package, PoP)：\n<ul>\n<li>背景：传统 SoC 中的 RAM集成度各不相同，在现代 SoC 中，集成 RAM 更为常见，但配置可能因应用需求而异。</li>\n<li>定义：一种将内存封装直接安装在 SoC 顶部的封装技术。</li>\n<li>生产灵活性：允许独立生产和测试内存和逻辑组件。</li>\n<li>空间优化：垂直堆叠组件以节省水平空间，这对于紧凑型设备设计至关重要</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-arm-cpu-vs-intel-cpu-x86\"><a class=\"markdownIt-Anchor\" href=\"#2-arm-cpu-vs-intel-cpu-x86\"></a> 2. ARM CPU vs Intel CPU (x86)</h2>\n<p>约 95% 的智能手机使用 ARM CPU，其余设备使用 Intel、MIPS 等。</p>\n<ul>\n<li>为什么使用ARM？</li>\n<li>快速高效的操作。</li>\n<li>更高的代码密度可实现更紧凑的设计。</li>\n<li>减少组件堆积，提高空间利用率。</li>\n</ul>\n<p>ARM 指令的特点：</p>\n<ul>\n<li>每条指令尽可能只使用一个周期。</li>\n<li>每条指令的长度为 32bit</li>\n<li>几乎每条指令都具有条件执行功能。</li>\n<li>一般寄存器：\n<ul>\n<li>R0-R12：一般目的的寄存器</li>\n<li>R13：栈寄存器</li>\n<li>R14：链接寄存器</li>\n<li>R15：PC</li>\n</ul>\n</li>\n<li>并不是所有的指令都用到 32bit，这会导致潜在的低效率，因此使用 Thumb 指令：\n<ul>\n<li>Thumb 指令使用紧凑的 ARM 16-bit 指令集。</li>\n<li>使用可变长度指令集，保留最常用的ARM指令并将它们编码成16位。\n<ul>\n<li>通过减少指令大小，实现了更快的速度。</li>\n<li>一次32-bit内存可以检索两个16位 Thumb 指令。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>ARM bit.LITTLE：</p>\n<ul>\n<li>ARM 使用大小核，通过集成强大的 (big) 内核和高效的 (LITTLE) 内核，将高性能与能效相结合。</li>\n<li>系统可以根据当前任务的需求在核心之间无缝切换，确保最佳性能和效率。</li>\n</ul>\n<h1 id=\"安卓软件的核心组件\"><a class=\"markdownIt-Anchor\" href=\"#安卓软件的核心组件\"></a> 安卓软件的核心组件</h1>\n<p>安卓与传统Java应用不同，可以有多个入口点。这些入口点定义了安卓系统可以与应用程序交互或者进入应用程序的方式，包括活动(Activity)、服务(Service)、广播收集器(Broadcast Receiver)和内容提供程序(Content Provider)。</p>\n<p>传统的操作系统通常只有一个 Main 入口点，并且操作系统将程序加载到进程中并执行，实例化 Java VM 加载应用程序使用的所有类 执行 main。</p>\n<p>而安卓中是基于component的模型，拥有多个应用程序入口点：</p>\n<ul>\n<li>Zygote fork 后仍执行 main 函数，但在此基础上进行抽象。</li>\n<li>并非所有都是用户的入口点。</li>\n<li>每个component都作为逻辑上独立的唯一实体存在</li>\n</ul>\n<p>一个 Android 应用程序应该包含多个组件，并且用户经常在短时间内与多个应用程序进行交互，因此应用程序需要适应不同类型的用户驱动的工作流程和任务。</p>\n<p>安卓的特定组件通常是由特定interface进行通信，在运行时进行绑定。每个组件都有特定的生命周期，根据需要动态加载和卸载。</p>\n<h2 id=\"1-activity\"><a class=\"markdownIt-Anchor\" href=\"#1-activity\"></a> 1. Activity</h2>\n<p>包括UI组件，View。是 android.app.Activity 的子类。其提供一个虚拟的UI，每一个 Activity 都拥有自己的窗口。</p>\n<h3 id=\"a-view\"><a class=\"markdownIt-Anchor\" href=\"#a-view\"></a> a. View</h3>\n<p>UI layout属于一个View，是一种资源，在单独的通过编程构建的XML文件中指定。</p>\n<ul>\n<li>View的子类包含：\n<ul>\n<li>Views: 用来显示一些内容</li>\n<li>Widgets: 执行某些操作</li>\n<li>ViewGroups：布局子视图</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"i-views\"><a class=\"markdownIt-Anchor\" href=\"#i-views\"></a> I. Views</h4>\n<ul>\n<li>设计规范：\n<ul>\n<li>首选浅布局层次结构。</li>\n<li>尽可能减少嵌套布局（遍历成本）。</li>\n<li>wide over deep。</li>\n</ul>\n</li>\n<li>编程方面：\n<ul>\n<li>可以使用使用 <code>setContentView()</code> 来指定Activity的View。</li>\n<li>可以使用 <code>addView()</code>、<code>removeView()</code> 来改变视图的层次结构。</li>\n<li>根据 XML 布局定义生成的ID，使用 <code>R.layout.ID</code> 来找到特定的视图。</li>\n<li>可以将 View 和数据绑定在一起。</li>\n</ul>\n</li>\n<li>策略：\n<ul>\n<li>手机很少是相同的，通常具有不同的屏幕尺寸和宽高比、各种分辨率。所以应该避免硬编码 UI 组件配置细节。</li>\n<li>布局应该适应其所填充的屏幕：\n<ul>\n<li>将布局定义为层次结构和关系。</li>\n<li>使用以密度无关像素 (density-independent pixels,dp) 而不是 px 定义测量值\n<ul>\n<li>1dp 相当于 160dpi 上的一个像素。</li>\n</ul>\n</li>\n<li>可以定义特定于配置的布局\n<ul>\n<li>Small, normal, large and extra large.</li>\n<li>使用最小宽度限定符</li>\n<li>使用方向限定符</li>\n<li>进行规划，例如 <code>res/layout-sw600dp/main_activity.xml</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ii-viewgroups-layouts\"><a class=\"markdownIt-Anchor\" href=\"#ii-viewgroups-layouts\"></a> II. ViewGroups - Layouts</h4>\n<p>Layouts通常包含：</p>\n<ul>\n<li>FrameLayout：最简单的layout，只包含一个物体。</li>\n<li>LinearLayout：根据方向属性，将所有子项对齐到单一方向。</li>\n<li>TableLayout：将子项定位到行和列中</li>\n<li>ConstraintLayout / RelativeLayout：让子视图指定它们相对于父视图或彼此的位置，使用对齐进行约束。</li>\n<li>ScrollView：垂直滚动视图。</li>\n<li>SwipeRefreshLayout：实现“下拉刷新”交互效果的控件。检测垂直滑动、显示进度条并触发回调方法。</li>\n</ul>\n<h4 id=\"iii-widgets\"><a class=\"markdownIt-Anchor\" href=\"#iii-widgets\"></a> III. Widgets</h4>\n<p>用于可以交互的子View：</p>\n<ul>\n<li>Button</li>\n<li>TextView</li>\n<li>EditText</li>\n<li>CalendarViewer</li>\n<li>ImageView</li>\n</ul>\n<p>这些组件可以处理UI事件：</p>\n<ul>\n<li>代码中，可以使用 <code>setOnClickListener()</code>。</li>\n<li>在XML中，可以设置 <code>android:onClick=&quot;&quot;</code> 参数。</li>\n</ul>\n<p>这些组件可以文字展示：</p>\n<ul>\n<li>代码中，可以使用 <code>.getText()</code> 和 <code>.setText()</code></li>\n<li>在XML中，设置 <code>android:text=&quot;&quot;</code> 参数，例如 <code>android:text=&quot;@string/hello_world&quot;</code></li>\n</ul>\n<h3 id=\"b-数据绑定\"><a class=\"markdownIt-Anchor\" href=\"#b-数据绑定\"></a> b. 数据绑定</h3>\n<p>传统model中，设计大量样本代码(boilerplate code)：</p>\n<ul>\n<li>Activity 和 Model 紧密耦合</li>\n<li>处理 Activity 中的 onClick 事件</li>\n<li>查找对相关视图的引用</li>\n<li>检索内容（例如文本字段的内容）</li>\n<li>将结果写回视图</li>\n</ul>\n<p>一个数据模型应该：</p>\n<ul>\n<li>将 POJO 绑定到View组件以进行初始填充</li>\n<li>使对象可观察，以便在更改时自动更新 UI\n<ul>\n<li>如继承&quot;BaseObservable&quot;，或者使用&quot;ViewModel + Livedata&quot;。</li>\n<li>使用可观察域，即 <code>@&#123;&#125;</code> 和 <code>@=&#123;&#125;</code></li>\n<li>可观察的objects, fields and collections</li>\n</ul>\n</li>\n<li>Data Binding Library：\n<ul>\n<li>是一种直接在XML中与类的成员进行绑定的方法，减少了在Activity中进行初始化的方法。</li>\n<li>即从layout中引用model对象。</li>\n<li>会生成必要的绑定类。</li>\n<li>包括基本格式表达式。</li>\n</ul>\n</li>\n<li>双向数据绑定，允许从View更新Object，反之亦然</li>\n</ul>\n<p>数据绑定的实现方法：<br />\n引用数据：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">data</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">variable</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewmodel&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.example.myapplication.MyModel&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可观察域：</p>\n<ul>\n<li><code>@&#123;&#125;</code>：接收数据变化，是单项绑定。</li>\n<li><code>@=&#123;&#125;</code>：接收属性的数据更改并监听用户更新，是双向绑定。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:progress = &quot;@=&#123;viewmodel.progress&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"c-manifest文件\"><a class=\"markdownIt-Anchor\" href=\"#c-manifest文件\"></a> c. Manifest文件</h3>\n<p>是应用的components列表，用于指定程序的入口点，通常包含应用的信息(需要什么、什么可以做)。不在这个列表的不能称之为 components。那么该组件无法作为入口点。</p>\n<p>通常要考虑：</p>\n<ul>\n<li>如何启动（默认的启动 activity）</li>\n<li>如何向其他人展示</li>\n<li>哪些内容可以访问它 （程序内部和外部）</li>\n<li>用户的权限。</li>\n</ul>\n<h3 id=\"d-navigation\"><a class=\"markdownIt-Anchor\" href=\"#d-navigation\"></a> d. Navigation</h3>\n<p>Activity 可以启动其他的 Activity，此时新的Activity就在旧的Acitivity上方。Activity 类似于一个栈结构。</p>\n<h4 id=\"i-分层活动导航-hierarchical-activity-navigation\"><a class=\"markdownIt-Anchor\" href=\"#i-分层活动导航-hierarchical-activity-navigation\"></a> i. 分层活动导航 (Hierarchical Activity Navigation)</h4>\n<p>种类：</p>\n<ul>\n<li>Descendant navigation 子级导航：指从一个层级（通常是父级）“深入”到下一个层级（子级）的导航方式。也可理解为“层级向下”或“钻取”式导航。</li>\n<li>Lateral navigation 横向导航：在同一层级内进行“左右”或“并列”切换的导航方式。也可理解为“同级别的兄弟页面之间”的移动。通常是同一父级下不同子页面之间的切换。</li>\n</ul>\n<p>形式：</p>\n<ul>\n<li>列出可选择的 activity</li>\n<li>屏幕之间 Tab</li>\n<li>在屏幕或页面之间滑动</li>\n<li>按钮切换</li>\n<li>导航（graphs, destinations）</li>\n</ul>\n<h4 id=\"ii-back-和-up-导航\"><a class=\"markdownIt-Anchor\" href=\"#ii-back-和-up-导航\"></a> ii. Back 和 UP 导航</h4>\n<p>都属于撤消横向和后代导航。</p>\n<ul>\n<li>Back: 可以在同一级中返回。\n<ul>\n<li>关闭当前的 activity。</li>\n<li>恢复堆栈中的下一个活动\n<ul>\n<li>taps 和 swipes 会更改当前屏幕显示的信息，而不是activity，因此不会影响历史记录。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Up: 返回父级。\n<ul>\n<li>关闭当前的 activity。</li>\n<li>启动（或恢复）相应的父级活动。\n<ul>\n<li>在 manifest 中表示。一般使用 <code>android:parentActivityName=&quot;.ParentActivity&quot;</code> 表示。</li>\n<li>如果它在后台堆栈中，则将其移到最前面。</li>\n<li>可以创建一个“假”返回堆栈</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"e-fragments\"><a class=\"markdownIt-Anchor\" href=\"#e-fragments\"></a> e. Fragments</h3>\n<p>Fragments 是比 Activity 更小的 UI 单元。</p>\n<ul>\n<li>多个 Fragments 可以组成一个 Activity，这样可以支持大屏幕 （例如平板）。</li>\n<li>可以在多个 Activity 复用一个 Fragments。</li>\n<li>管理逻辑上属于堆栈中同一 Activity 的项目集合\n<ul>\n<li>例如翻阅照片。</li>\n</ul>\n</li>\n<li>在输入、事件、生命周期方面与宿主 Activity 的关系有些复杂</li>\n</ul>\n<h3 id=\"f-intents\"><a class=\"markdownIt-Anchor\" href=\"#f-intents\"></a> f. Intents</h3>\n<p>Intent用来描述一个操作(operator)，包括要执行的Action以及所要处理的数据（可以用 URI 表示）。</p>\n<p>Android 的设计理念是通过 Intent 在不同的组件（尤其是 Activity 之间）进行通信，而不是让我们手动去实例化 Activity。</p>\n<p>Intent 还可以实现延迟绑定（Late Runtime Binding），并能把多个 Activity 逻辑“黏合”到一起。</p>\n<p>系统会根据AndroidManifest.xml中注册的信息来确定该如何响应并处理 Intent。</p>\n<h4 id=\"i-使用-intent-启动停止一个-activity\"><a class=\"markdownIt-Anchor\" href=\"#i-使用-intent-启动停止一个-activity\"></a> i. 使用 Intent 启动/停止一个 Activity</h4>\n<p>如何使用 Intent 启动一个 Activity：</p>\n<ul>\n<li>创建一个新的 Intent 对象。</li>\n<li>指定想要将 Intent 发送给谁（可以是显式或者隐式方式）。</li>\n<li>调用 <code>startActivity()</code> 函数，并把这个 Intent 传递进去。</li>\n<li>系统会根据传入的 Intent，启动一个新的 Activity（即由系统的运行时来负责真正的启动过程）。</li>\n</ul>\n<p>停止一个 Activity：</p>\n<ul>\n<li>被启动的 Activity 完成任务后，可以通过调用 finish() 方法来销毁自己，返回到原先的 Activity。</li>\n<li>当用户按下“返回”键时，系统也会销毁当前 Activity，将界面返回到上一个 Activity（或退出应用）。</li>\n</ul>\n<h4 id=\"ii-显式-vs-隐式-intent\"><a class=\"markdownIt-Anchor\" href=\"#ii-显式-vs-隐式-intent\"></a> ii. 显式 vs 隐式 Intent</h4>\n<p>显式(Explicit) Intent：</p>\n<ul>\n<li>提供要启动的 Activity 的完全类名。</li>\n<li>如 <code>Intent myIntent = new Intent(context, otherActivity.class);</code></li>\n</ul>\n<p>隐式(Implicit) Intent:</p>\n<ul>\n<li>只指定一个操作（Action）和数据类型（Data/Category/Type）。</li>\n<li>由系统或其他应用中符合条件的组件来响应。</li>\n<li>必须要在 manifest 中声明，具体看下面 Intent Filters</li>\n</ul>\n<h4 id=\"iii-intent-filters-for-deep-linking\"><a class=\"markdownIt-Anchor\" href=\"#iii-intent-filters-for-deep-linking\"></a> iii. Intent Filters for Deep Linking</h4>\n<p>Intent Filters 是在 AndroidManifest.xml 中为 Activity、Service 或 BroadcastReceiver 指定的过滤条件，用于匹配特定的 Intent。它们决定哪些 Intent 可以由某个组件（如 Activity）处理。</p>\n<p>匹配条件：</p>\n<ul>\n<li>Action：定义意图的操作（例如 android.intent.action.VIEW 表示“查看某个资源”）。</li>\n<li>Category：补充描述意图的分类（例如 android.intent.category.DEFAULT 是默认分类）。</li>\n<li>Data：指定数据 URI（例如 URL 的协议或路径）或 MIME 类型，用于匹配数据内容。</li>\n</ul>\n<p>通过在 AndroidManifest.xml 中声明 Intent Filters，可以：</p>\n<ul>\n<li>指定某个 Activity 可以处理的 Intent 类型。</li>\n<li>实现 Deep Linking：允许应用直接打开特定的内容（如通过 URL 直接跳转到应用内的某个界面）。</li>\n<li>支持隐式 Intent：当其他应用或系统发送隐式 Intent 时，只有符合声明的 Activity 会被匹配到。</li>\n</ul>\n<p>当多个应用或组件的 Intent Filters 都匹配某个 Intent 时，系统会弹出一个选择对话框，允许用户选择使用哪个应用来处理。</p>\n<p>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=&quot;com.example.martinactivities.ForthActivity&quot;&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class=\"line\">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class=\"line\">        &lt;data android:scheme=&quot;http&quot; /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n<p>这个配置表示 ForthActivity 是一个可以处理特定 Intent 的 Activity。</p>\n<ul>\n<li>表示此 Activity 可以处理“查看某些内容”的操作，例如点击链接或打开文件。</li>\n<li>表示这个 Activity 是默认分类，用于普通的隐式 Intent 调用。</li>\n<li>表示此 Activity 能够处理 HTTP URL 的数据。</li>\n</ul>\n<h3 id=\"g-activity-之间的通信\"><a class=\"markdownIt-Anchor\" href=\"#g-activity-之间的通信\"></a> g. Activity 之间的通信</h3>\n<ul>\n<li><code>startActivity()</code>的限制：\n<ul>\n<li>用于启动另一个 Activity，但不允许返回结果到启动它的 Activity。</li>\n<li>应用通常需要维持用户在多个 Activity 中的状态。</li>\n<li>在复杂的场景中，Activity 可能需要跨进程通信（IPC），或者作为其他应用的入口点。</li>\n</ul>\n</li>\n<li><em><code>startActivityForResult()</code></em> 已过时：\n<ul>\n<li>启动另一个 Activity，并允许子 Activity 在完成后将结果返回到启动它的 Activity。</li>\n<li><code>startActivityForResult()</code> 需要提供一个数值型的请求代码（requestCode），以便区分返回的结果来源。</li>\n<li>子类使用 <code>setRusult()</code> 和规定一个返回结果的 <code>intent</code> 来返回结果。</li>\n<li>父类使用重写 <code>onActivityResult(int requestCode, int resultCode, Intent)</code> 方法来处理结果。</li>\n</ul>\n</li>\n<li><code>registerForActivityResult()</code>\n<ul>\n<li>是 <code>startActivityForResult()</code> 的现代替代方法，更加简洁、安全，避免了旧方法中繁杂的 <code>onActivityResult()</code> 回调逻辑。</li>\n<li>基于合约：例如使用 <code>ActivityResultContracts.StartActivityForResult</code> 来指定启动的 Activity 和结果处理逻辑。</li>\n<li>回调处理：在启动 Activity 时注册一个回调函数，当子 Activity 结束后返回时，该回调会被调用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"h-tasks-vs-activities-vs-processes\"><a class=\"markdownIt-Anchor\" href=\"#h-tasks-vs-activities-vs-processes\"></a> h. Tasks vs Activities vs Processes</h3>\n<table>\n<thead>\n<tr>\n<th>名字</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Activities</td>\n<td>定义一个应用组件(application component)中屏幕的信息。<br>应用是一个Activities的集合，包括创建的和从其他应用中复用的。</td>\n</tr>\n<tr>\n<td>Tasks</td>\n<td>为了实现一个目标而用到的一系列activity。<br>单个任务可以只使用一个app中的activity，也可以利用多个不同app中的activity。</td>\n</tr>\n<tr>\n<td>Processes</td>\n<td>创建特定应用的 host component 。<br>一个任务可以跨越多个进程</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"i-安卓开发中的任务管理\"><a class=\"markdownIt-Anchor\" href=\"#i-安卓开发中的任务管理\"></a> i. 安卓开发中的任务管理。</h3>\n<p>为什么要管理任务？</p>\n<ul>\n<li>用户频繁切换任务/堆栈：比如从一应用跳转到另一个应用或在同一个应用的不同活动中切换。</li>\n<li>大多数任务由多个活动 (Activities) 组成：\n<ul>\n<li>调用另一个应用中的 Activity：\n<ul>\n<li>并不总是局限于一个应用，而是跨应用的任务。</li>\n<li>通过松散绑定的方式提供连贯的用户体验，依赖于 Intent 等机制。</li>\n</ul>\n</li>\n<li>非确定性的用户路径 (Non-deterministic User Journeys)：\n<ul>\n<li>应用的启动位置不一定相同。</li>\n<li>用户可能在一段时间内“离开”应用，然后返回。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>任务管理的好处</p>\n<ul>\n<li>利用其他应用的组件：\n<ul>\n<li>通过 Intent 调用其他应用的 Activity，简化复杂功能的实现。</li>\n</ul>\n</li>\n<li>细粒度的资源管理\n<ul>\n<li>单个任务的活动状态可以根据需求调整，以优化内存、CPU、存储、屏幕和电池的使用。</li>\n<li>例如，释放后台任务的资源来提高设备性能。</li>\n</ul>\n</li>\n</ul>\n<p>如何应对任务管理？</p>\n<ul>\n<li>组件具有生命周期 (Lifecycles)：\n<ul>\n<li>每个 Activity 和 Fragment 都有生命周期，通过管理生命周期事件（如 onCreate, onStart, onDestroy 等），可以更高效地控制任务和资源使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"activity-与进程管理的核心概念\"><a class=\"markdownIt-Anchor\" href=\"#activity-与进程管理的核心概念\"></a> Activity 与进程管理的核心概念</h4>\n<ul>\n<li>系统不会直接杀死活动 (The OS never kills an Activity)：\n<ul>\n<li>Android 系统不会单独终止活动，而是会杀死托管这些活动的进程以释放内存。</li>\n<li>系统更倾向于通过终止后台进程来回收资源。</li>\n</ul>\n</li>\n<li>应用如何响应内存压力：\n<ul>\n<li><code>onTrimMemory</code> 回调：应用可以通过该回调管理自己的内存资源，例如清除缓存或释放不必要的数据。</li>\n</ul>\n</li>\n<li>进程被终止的可能性取决于其状态：\n<ul>\n<li>系统会选择对用户影响最小的进程进行终止。</li>\n<li>决策依据包括：\n<ul>\n<li>进程最近是否被使用。</li>\n<li>进程是否与主屏 (Home Activity) 相关联。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"j-activity-的生命周期管理\"><a class=\"markdownIt-Anchor\" href=\"#j-activity-的生命周期管理\"></a> j. Activity 的生命周期管理</h4>\n<h5 id=\"i-activity-的三种主要状态\"><a class=\"markdownIt-Anchor\" href=\"#i-activity-的三种主要状态\"></a> I. Activity 的三种主要状态：</h5>\n<ul>\n<li>Active (活跃状态)：\n<ul>\n<li>Activity 位于前台并获得焦点。</li>\n<li>用户正在与该 Activity 交互。</li>\n</ul>\n</li>\n<li>Paused (暂停状态)：\n<ul>\n<li>Activity 仍然可见，但不在顶部。</li>\n<li>例如，出现一个半透明窗口或分屏模式中另一个应用获得焦点时，Activity 进入暂停状态。</li>\n<li>Activity 处于活动状态但未获得焦点。</li>\n</ul>\n</li>\n<li>Stopped (停止状态)：\n<ul>\n<li>Activity 被其他 Activity 完全遮挡。</li>\n<li>此状态下，Activity 不再可见。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"ii-优先级降低的-activity\"><a class=\"markdownIt-Anchor\" href=\"#ii-优先级降低的-activity\"></a> II. 优先级降低的 Activity</h5>\n<p>Android 系统如何管理资源：</p>\n<ul>\n<li>当 Activity 进入 Paused 或 Stopped 状态时，系统可能会降低其资源分配优先级。</li>\n<li>具体表现：\n<ul>\n<li>停止状态的 Activity 被挂起 (Suspended)：不会主动执行任何代码，但其状态会被保留。</li>\n<li>非活动的 Activity 可能被销毁 (Destruction)：\n<ul>\n<li>如果系统需要额外内存，可能会销毁处于 Stopped 或 Paused 状态的 Activity 来回收资源。</li>\n<li>重要性：必须保存 Activity 的状态以便用户返回时恢复。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"iii-注意事项\"><a class=\"markdownIt-Anchor\" href=\"#iii-注意事项\"></a> III. 注意事项</h5>\n<p>状态转换会触发事件，确保避免以下问题：</p>\n<ul>\n<li>因为用户接听电话导致的崩溃：\n<ul>\n<li>当用户接听电话或应用失去焦点时，系统可能会暂停或停止当前的 Activity。</li>\n<li>如果没有妥善管理生命周期，可能会导致崩溃。</li>\n</ul>\n</li>\n<li>在用户不使用应用时消耗资源：\n<ul>\n<li>停止或暂停的 Activity 不应占用系统资源（如内存、CPU），以避免浪费和影响其他任务的性能。</li>\n</ul>\n</li>\n<li>丢失用户进度：\n<ul>\n<li>确保在 Activity 状态变化时保存用户数据（如输入内容、进度）。</li>\n<li>提供一致的用户体验非常重要。</li>\n</ul>\n</li>\n<li>在配置更改期间的崩溃（例如屏幕旋转）：\n<ul>\n<li>设备从纵向切换到横向或其他配置变化（如语言、屏幕大小）时，Activity 会重新创建。</li>\n<li>如果没有保存状态或正确处理生命周期事件，可能会导致崩溃或用户数据丢失。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"iv-生命周期\"><a class=\"markdownIt-Anchor\" href=\"#iv-生命周期\"></a> IV. 生命周期</h5>\n<p><code>onCreate() → onStart() → onResume() → onPause() → onStop() → onDestroy()</code></p>\n<ul>\n<li><code>onCreate()</code>：Activity 的初始化方法，相当于组件的“构造函数”。用于执行基础设置，例如加载 UI 布局。</li>\n<li><code>onStart()</code>：Activity 对用户可见，但尚未获得焦点。此时 UI 已加载，但用户还不能与之交互。</li>\n<li><code>onResume()</code>：Activity 已进入前台，并可供用户交互。Activity 将一直处于此状态，直到被其他 Activity 遮挡或用户切换应用。</li>\n<li><code>onPause()</code>：Activity 不再是用户的焦点，但仍部分可见（如弹出窗口覆盖部分界面）。停止不需要运行的任务，例如暂停视频播放或相机预览。</li>\n<li><code>onStop()</code>：Activity 完全不可见，处于后台状态。应释放资源并保存持久数据（如数据库或文件）。</li>\n<li><code>onDestroy()</code>：Activity 被销毁时调用。可能不会正常调用，所以不要在这里保存状态。</li>\n</ul>\n<p>当一个活动启动另一个活动后，必然有一个活动进入 <code>onPause()</code>，另一个进入 <code>onResume()</code>。</p>\n<p>关于 <code>onDestroy()</code> 注意事项：</p>\n<ul>\n<li>配置更改时，例如设备的屏幕方向、语言或者输入设备发生变化时，当前 Activity 会被摧毁并重新创建。</li>\n<li>当一个 Activity 正常完成时，用户按下返回键或者调用 <code>finish()</code> 方法，<code>onDestroy()</code> 会被调用。</li>\n<li>如果系统因为资源不足终止后台进程，则不会调用。</li>\n<li>因此，应该在 <code>onPause()</code> 或 <code>onStop()</code> 中提前保存关键数据，避免因进程被杀死导致数据丢失。</li>\n</ul>\n<h5 id=\"v-ui保存\"><a class=\"markdownIt-Anchor\" href=\"#v-ui保存\"></a> V. UI保存</h5>\n<p>主要在于如何使用 <code>onSaveInstanceState()</code> 方法。<br />\n该方法不应依赖 Activity 保存 UI 或状态，配置更改和进程终止都可以恢复。例如当设备旋转会导致配置更改。</p>\n<p>在 Activity 被停止 <code>onStop()</code> 之前，系统会调用 <code>onSaveInstanceState()</code>。目的是保存 UI 的瞬态状态（transient state），以便在 Activity 重新创建时恢复。</p>\n<p>例如：保存用户输入内容、滚动位置或临时选择项。</p>\n<ul>\n<li>保存瞬态 UI 状态：<br />\n在 Activity 被重新创建时，保存的状态会通过 Bundle 传递：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onCreate(Bundle savedInstanceState)</span><br><span class=\"line\">onRestoreInstanceState(Bundle savedInstanceState)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>保存非瞬态 UI 状态：\n<ul>\n<li>使用 SQL 数据库。</li>\n<li>使用 SharedPreferences。</li>\n</ul>\n</li>\n</ul>\n<p>实例状态 Instance State：</p>\n<ul>\n<li>目的：\n<ul>\n<li>用于保存小型的、与 UI 相关的数据，这些数据易于序列化或反序列化。</li>\n<li>比如文本输入框的内容、滚动位置等。</li>\n</ul>\n</li>\n<li>序列化开销：\n<ul>\n<li>由于需要序列化和反序列化，存在一定的性能消耗。</li>\n<li>因此，数据量不宜过大，否则会影响性能。</li>\n</ul>\n</li>\n<li>快速存取需求：\n<ul>\n<li>状态保存需要足够快，否则会导致 UI 卡顿或帧丢失。</li>\n</ul>\n</li>\n</ul>\n<p>Bundle 特点：</p>\n<ul>\n<li>结构：Bundle 是一个键值对（Key/Value）的集合。</li>\n<li>适用场景：适合保存小型的瞬态状态（transient state），如当前页面索引、简单的用户数据。</li>\n<li>Bundle 中存储的数据量有限，过大的数据可能导致 TransactionTooLargeException。</li>\n<li>复杂类（如自定义对象）需要实现 Parcelable 接口以优化性能。</li>\n</ul>\n<p>建议：</p>\n<ul>\n<li>只适用于储存小数据，适用于 UI 瞬态状态的数据存储，避免存储复杂和大规模的数据。</li>\n<li>由于序列化过程的开销，建议尽量保持 Bundle 的存储简单、快速。</li>\n<li>对于复杂数据（如网络请求结果、列表数据），建议使用 ViewModel 或持久化存储（如数据库、SharedPreferences）。</li>\n</ul>\n<h5 id=\"vi-viewmodel\"><a class=\"markdownIt-Anchor\" href=\"#vi-viewmodel\"></a> VI. ViewModel：</h5>\n<p>ViewModel 可以在配置更改时保留状态，例如屏幕旋转不会导致数据丢失。</p>\n<p>ViewModel 设计用于与 Activity 或 Fragment 的生命周期绑定，但独立于 UI 控件。在配置更改（如屏幕旋转）中，Activity 或 Fragment 会被销毁并重新创建，而 ViewModel 不会被销毁，从而保持数据的一致性。</p>\n<p>局限性：</p>\n<ul>\n<li>对配置更改免疫：ViewModel 可以在配置更改时保留状态，例如屏幕旋转不会导致数据丢失。</li>\n<li>不对资源管理终止免疫：如果系统由于资源不足（如内存不足）终止整个应用进程，ViewModel 中的数据会丢失。此时需要储存在数据库中。</li>\n<li>不对导航操作免疫：当用户导航离开当前 Activity 或 Fragment 时，ViewModel 会被销毁。</li>\n</ul>\n<h5 id=\"vii-livedata\"><a class=\"markdownIt-Anchor\" href=\"#vii-livedata\"></a> VII. LiveData：</h5>\n<h2 id=\"2-service\"><a class=\"markdownIt-Anchor\" href=\"#2-service\"></a> 2. Service</h2>\n<p>在后台执行长时间运行操作的机制。</p>\n<h2 id=\"3-broadcast-receiver\"><a class=\"markdownIt-Anchor\" href=\"#3-broadcast-receiver\"></a> 3. Broadcast Receiver</h2>\n<p>响应来自操作系统/其他应用程序的广播消息。</p>\n<h2 id=\"4-content-provider\"><a class=\"markdownIt-Anchor\" href=\"#4-content-provider\"></a> 4. Content Provider</h2>\n<p>使数据可供其他应用程序使用/利用来自其他应用程序的数据。</p>\n<h1 id=\"其他\"><a class=\"markdownIt-Anchor\" href=\"#其他\"></a> 其他</h1>\n<h2 id=\"1-kotlin\"><a class=\"markdownIt-Anchor\" href=\"#1-kotlin\"></a> 1. Kotlin</h2>\n<p>Kotlin 是 2011 年 JetBrains 创建的语言。</p>\n<h3 id=\"i-为什么使用-kotlin\"><a class=\"markdownIt-Anchor\" href=\"#i-为什么使用-kotlin\"></a> i. 为什么使用 Kotlin？</h3>\n<ul>\n<li>现代语言特性。</li>\n<li>与 Java 的互操作性。</li>\n<li>提高开发人员的工作效率。</li>\n</ul>\n<h3 id=\"ii-为什么-kotlin-java\"><a class=\"markdownIt-Anchor\" href=\"#ii-为什么-kotlin-java\"></a> ii. 为什么 Kotlin &gt; Java？</h3>\n<ul>\n<li>简洁性 Conciseness\n<ul>\n<li>显著减少样板代码 (boilerplate code)。</li>\n<li>例如 数据类自动生成 getter、setter 和其他实用方法</li>\n</ul>\n</li>\n<li>安全功能 Safety Features\n<ul>\n<li>Null Safety 空安全：在编译时消除 NullPointerException。\n<ul>\n<li>默认情况下，变量不能为空值，除非显式声明为空。(加一个问号?)</li>\n</ul>\n</li>\n<li>Immutability 不可变的：鼓励使用不可变的数据结构。\n<ul>\n<li>默认情况下，Kotlin 提倡不可变性。</li>\n<li>被声明为 <code>val</code> 的变量是只读的，不能重新分配。</li>\n<li>这可以避免可变变量引起的意外副作用，从而使代码更安全。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>互操作性 Interoperability\n<ul>\n<li>与现有 Java 代码无缝集成。</li>\n<li>允许从 Java 逐步迁移到 Kotlin。</li>\n</ul>\n</li>\n<li>扩展方法\n<ul>\n<li>Kotlin 允许使用新功能扩展类，而无需从该类继承或使用 Decorator 等设计模式。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"iii-coroutines-协程\"><a class=\"markdownIt-Anchor\" href=\"#iii-coroutines-协程\"></a> iii. Coroutines 协程</h3>\n<p>协程本质上是轻量级线程 (Lightweight Threads)。它们允许我们执行后台任务，而无需与传统线程相关的大量资源成本。协程是实现异步的一种方式。</p>\n<p>线程是由操作系统管理和调度的，而协程则是由程序代码自身进行管理和调度。</p>\n<p>与线程不同，协程由 Kotlin 运行时而不是操作系统管理，从而使其效率更高。</p>\n<p>Sequential Asynchronous Code（顺序异步代码）：</p>\n<ul>\n<li>协程使异步代码看起来像同步代码，协程的特性允许我们以顺序的方式编写异步逻辑。</li>\n<li>这种顺序风格的代码更加直观，不会阻塞主线程，适用于高并发和 I/O 密集型任务。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>协程支持非阻塞操作 (Non-blocking Code Execution)：\n<ul>\n<li>在执行长时间运行的任务时，协程不会阻塞主线程，保持应用的响应能力</li>\n<li>非阻塞操作可以避免出现“应用无响应”（Application Not Responding，ANR）错误，这是移动应用开发中的常见问题。</li>\n</ul>\n</li>\n<li>简化代码结构：\n<ul>\n<li>避免嵌套回调和“回调地狱”（Callback Hell）。\n<ul>\n<li>协程提供了更直观的方式来处理异步操作，而不需要依赖复杂的嵌套回调。</li>\n</ul>\n</li>\n<li>以顺序方式编写代码：\n<ul>\n<li>协程的代码结构更接近同步代码，简化了逻辑流程，提升了可读性和维护性。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>可扩展并发性 (Scalable Concurrency)\n<ul>\n<li>高效处理多任务并发：协程能够高效地管理和执行大量并发任务，且资源开销极小。</li>\n<li>便于应用扩展：相比传统线程，协程更容易管理并发任务，尤其适用于需要高并发的场景。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-jetpack-compose\"><a class=\"markdownIt-Anchor\" href=\"#2-jetpack-compose\"></a> 2. Jetpack Compose</h2>\n<p>Jetpack Compose 是一个现代工具包，用于通过声明式方式构建原生 Android 用户界面。完全使用 Kotlin 构建，紧密集成，利用现代语言特性实现简洁和可表达的代码。</p>\n<p>是基于 Jetpack 的一个工具，基于模块化组件，组成成分有：</p>\n<ul>\n<li>Foundation：提供核心工具，例如AppCompat</li>\n<li>Architecture：提供生命周期感知组件，例如 ViewModel, LiveData 和 Room</li>\n<li>UI：包括用于导航、Fragment和动画的工具。</li>\n<li>Behavior：提供后台任务和数据处理的工具。</li>\n</ul>\n<p>特性：</p>\n<ul>\n<li>使用 Kotlin 编写 UI 和业务逻辑，无需切换上下文。</li>\n<li>支持 实时预览 (Live Previews) 和 热重载 (Hot Reloading)，在开发过程中实时更新 UI。</li>\n<li>使用Composable 函数：通过函数式组件减少冗余代码。</li>\n<li>无需 XML 布局和 findViewById，可直接引用 UI 组件。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>提高生产力 (Improved Productivity)\n<ul>\n<li>减少样板代码：减少开发中的重复性代码，提高应用质量。</li>\n<li>直观的 API：采用声明式编程风格，学习曲线平滑，更易于掌握和使用。</li>\n</ul>\n</li>\n<li>更高的性能 (Better Performance)：\n<ul>\n<li>高效的渲染 (Efficient Rendering)：仅更新受影响的组件，避免不必要的重绘，从而提升性能。</li>\n<li>异步处理 (Asynchronous Handling)：提供流畅的 UI 交互体验，适配现代异步工作流。</li>\n</ul>\n</li>\n<li>轻松集成 (Easy Integration)：\n<ul>\n<li>与现有视图兼容 (Interoperable with existing Android views)</li>\n<li>向后兼容：支持旧版本的 Android，同时提供生命周期感知的功能。</li>\n</ul>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>关注点分离减少 (Reduced Separation of Concerns)：\n<ul>\n<li>在 Composable 函数中将布局和逻辑结合在一起，可能会模糊 UI 结构与功能代码之间的界限。</li>\n<li>这可能会增加隔离特定部分的难度。</li>\n</ul>\n</li>\n<li>复杂 UI 中的复杂性增加 (Increased Complexity in Large UIs)：\n<ul>\n<li>对于复杂的用户界面，将布局和内容结合在同一代码中，可能会导致函数变得庞大且难以阅读。</li>\n<li>开发者需要将 UI 拆分成更小、更可重用的组件以提高可读性。</li>\n</ul>\n</li>\n<li>文件体积膨胀的可能性 (Potential for Large Files)：\n<ul>\n<li>由于将 UI 和逻辑放在一起，文件可能变得非常庞大，尤其是在大型应用中。</li>\n<li>查找特定组件或逻辑可能会变得困难。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"i-composable-function\"><a class=\"markdownIt-Anchor\" href=\"#i-composable-function\"></a> i. Composable Function</h3>\n<p>使用 @Composable 注解，用于定义 UI 组件。</p>\n<ul>\n<li>声明式 UI 定义：描述 UI 应该显示什么，而不是如何构建。</li>\n<li>Composable 函数可以嵌套，并组合起来构建复杂的用户界面。</li>\n</ul>\n<p>Composables 中管理状态：</p>\n<ul>\n<li>维护状态以跨越多次重组 (recomposition)。</li>\n<li>响应用户交互和数据变化，动态更新 UI。</li>\n</ul>\n<p>状态管理工具：</p>\n<ul>\n<li>remember：用于在相同的 Composable 中保持状态，避免因重组丢失数据。</li>\n<li>mutableStateOf：持有一个可变的值，当值发生变化时会触发 UI 的重新绘制 (recomposition)。</li>\n</ul>\n<h2 id=\"3-零日攻击-zero-day-attack\"><a class=\"markdownIt-Anchor\" href=\"#3-零日攻击-zero-day-attack\"></a> 3. 零日攻击 (Zero-day Attack)</h2>\n<p>零日攻击是一种利用软件漏洞的攻击行为，这些漏洞对于供应商或开发者来说是未知的。“零日”意味着开发者在漏洞被利用之前，没有任何时间（0天）来修复这个问题。</p>\n<p>特点：</p>\n<ul>\n<li>未被发现的漏洞 (Undetected Vulnerabilities)：\n<ul>\n<li>攻击者利用在安全团队或开发人员发现之前存在的漏洞。</li>\n<li>这些漏洞通常处于未知状态，未被公开</li>\n</ul>\n</li>\n<li>高风险 (High Risk)：\n<ul>\n<li>在漏洞被修复之前，攻击者可能造成严重的损害。</li>\n<li>高危攻击可能泄露敏感信息、破坏系统或造成经济损失。</li>\n</ul>\n</li>\n<li>隐蔽性 (Stealthy Nature)：\n<ul>\n<li>零日攻击往往具有高度隐蔽性，通常在攻击发生后才被察觉。</li>\n<li>由于未被识别，受害者可能无法立即采取防御措施。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"代码相关\"><a class=\"markdownIt-Anchor\" href=\"#代码相关\"></a> 代码相关</h1>\n<h2 id=\"1-活动类-appcompatactivity\"><a class=\"markdownIt-Anchor\" href=\"#1-活动类-appcompatactivity\"></a> 1. 活动类 <code>AppCompatActivity</code></h2>\n<ul>\n<li>生命周期管理：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>重写方法</th>\n<th>说明</th>\n<th>使用补充</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>onCreate()</code></td>\n<td>创建时调用。<br>是生命周期的起点。</td>\n<td>一般用于设计布局、初始化控件、配置数据等。</td>\n</tr>\n<tr>\n<td><code>onStart()</code></td>\n<td>启动时调用，即用户即将看到它，但还没有与用户互动时。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>onResume()</code></td>\n<td>即将于用户交互时调用。是活跃状态。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>onPause()</code></td>\n<td>失去焦点时调用。</td>\n<td>一般用于暂停动画、保存数据或释放资源。</td>\n</tr>\n<tr>\n<td><code>onStop()</code></td>\n<td>完全不可见时调用。<br>比如说被另一个<code>Activity</code>全屏覆盖或应用被最小化。</td>\n<td>可以释放更多资源。</td>\n</tr>\n<tr>\n<td><code>onRestart()</code></td>\n<td>从停止变回可见状态时调用。<br>此方法在<code>onStart()</code>之前被调用。</td>\n<td>常用于恢复<code>onStop</code>中被释放的资源。</td>\n</tr>\n<tr>\n<td><code>onDestory()</code></td>\n<td>被摧毁之前调用。<br>是生命周期的终点。</td>\n<td>释放掉所有的资源.</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>子活动相关：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Intent getIntent()</code></td>\n<td>获取启动该活动的intent。没有则返回<code>Null</code>。</td>\n<td><code>var intent = getIntent()</code></td>\n</tr>\n<tr>\n<td><code>registerForActivityResult(ActivityResultContracts&lt;I, O&gt;, Callback&lt;O&gt;)</code></td>\n<td>用于注册<code>ActivityResultLauncher&lt;Intent&gt;</code>。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>setRusult(RESULT, Intent)</code></td>\n<td>返回启动它的 <code>Activity</code>，并返回结果</td>\n<td><code>RESULT_OK</code>: 操作成功<br><code>RESULT_CANCELED</code>：操作取消<br><code>RESULT_FIRST_USER</code>：自动定义结果代码</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>其他辅助类：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>View findViewById()</code></td>\n<td>根据控件id寻找控件</td>\n<td><code>var a = findViewById(R.id.a);</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-视图类-view\"><a class=\"markdownIt-Anchor\" href=\"#2-视图类-view\"></a> 2. 视图类 <code>View</code></h2>\n<h3 id=\"列表视图-listview\"><a class=\"markdownIt-Anchor\" href=\"#列表视图-listview\"></a> 列表视图 <code>ListView</code></h3>\n<h3 id=\"回收视图-recyclerview\"><a class=\"markdownIt-Anchor\" href=\"#回收视图-recyclerview\"></a> 回收视图 <code>RecyclerView</code></h3>\n<p>可以动态创建并回收视图，提升性能。</p>\n<h2 id=\"3-资源类-r\"><a class=\"markdownIt-Anchor\" href=\"#3-资源类-r\"></a> 3. 资源类 <code>R</code></h2>\n<table>\n<thead>\n<tr>\n<th>子类</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>layout</code></td>\n<td>当前布局相关信息</td>\n<td><code>R.layout.activity_main</code></td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td>控件id相关</td>\n<td><code>R.id.buttonCalculate</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"4-意图类-intent\"><a class=\"markdownIt-Anchor\" href=\"#4-意图类-intent\"></a> 4. 意图类 <code>Intent</code></h2>\n<p>用于给其他的 <code>Activity</code> 传递参数。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n<th>样例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>putExtra(key, value)</code></td>\n<td>传递数据。</td>\n<td><code>intent.putExtra(&quot;result&quot;, 10);</code></td>\n</tr>\n<tr>\n<td><code>getStringExtra(key)</code></td>\n<td>根据<code>key</code>获取字符串数据。</td>\n<td><code>name = intent.getStringExtra(&quot;name&quot;);</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>父类打开子类，并返回给子类信息。</li>\n<li>子类返回父类，并返回给父类信息。<br />\n需要用到 <code>startActivityForResult(Intent, int)</code>，或者 <code>Activity Result API</code> 的 <code>ActivityResultLauncher</code> 打开子活动。</li>\n</ul>\n","feature":false,"text":"关于安卓开发的笔记。...","permalink":"/post/笔记/笔记-安卓开发","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"笔记","slug":"笔记","count":9,"path":"api/categories/笔记.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":1,"path":"api/tags/JAVA.json"},{"name":"Android","slug":"Android","count":1,"path":"api/tags/Android.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%EF%B8%8F%E8%83%8C%E6%99%AF\"><span class=\"toc-text\"> ✒️背景</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 🔖介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%AE%89%E5%8D%93%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 一. 安卓介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0-%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\"> 0. 平台架构：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%81%B5%E6%B4%BB%E6%80%A7-flexibility\"><span class=\"toc-text\"> 1. 灵活性 (Flexibility)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%BC%E5%AE%B9%E6%80%A7-compatibility\"><span class=\"toc-text\"> 2. 兼容性 (Compatibility)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AE%89%E5%8D%93%E5%86%85%E6%A0%B8-kernel\"><span class=\"toc-text\"> 3. 安卓内核 (kernel)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%AE%89%E5%8D%93%E7%A1%AC%E4%BB%B6-hardware\"><span class=\"toc-text\"> 4. 安卓硬件 (hardware)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8\"><span class=\"toc-text\"> 5. 安卓应用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%AE%89%E5%8D%93%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\"> 6. 安卓启动过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-zygote\"><span class=\"toc-text\"> 7. Zygote</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-art\"><span class=\"toc-text\"> 8. ART</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%8D%93%E7%A1%AC%E4%BB%B6\"><span class=\"toc-text\"> 安卓硬件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%80%E8%8A%AF%E7%89%87%E7%B3%BB%E7%BB%9F-system-on-a-chip-socs\"><span class=\"toc-text\"> 1. 一芯片系统 (System On A Chip, SOCs)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-arm-cpu-vs-intel-cpu-x86\"><span class=\"toc-text\"> 2. ARM CPU vs Intel CPU (x86)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\"> 安卓软件的核心组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-activity\"><span class=\"toc-text\"> 1. Activity</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-view\"><span class=\"toc-text\"> a. View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#i-views\"><span class=\"toc-text\"> I. Views</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ii-viewgroups-layouts\"><span class=\"toc-text\"> II. ViewGroups - Layouts</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#iii-widgets\"><span class=\"toc-text\"> III. Widgets</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\"> b. 数据绑定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-manifest%E6%96%87%E4%BB%B6\"><span class=\"toc-text\"> c. Manifest文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-navigation\"><span class=\"toc-text\"> d. Navigation</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#i-%E5%88%86%E5%B1%82%E6%B4%BB%E5%8A%A8%E5%AF%BC%E8%88%AA-hierarchical-activity-navigation\"><span class=\"toc-text\"> i. 分层活动导航 (Hierarchical Activity Navigation)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ii-back-%E5%92%8C-up-%E5%AF%BC%E8%88%AA\"><span class=\"toc-text\"> ii. Back 和 UP 导航</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-fragments\"><span class=\"toc-text\"> e. Fragments</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#f-intents\"><span class=\"toc-text\"> f. Intents</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#i-%E4%BD%BF%E7%94%A8-intent-%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA-activity\"><span class=\"toc-text\"> i. 使用 Intent 启动&#x2F;停止一个 Activity</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ii-%E6%98%BE%E5%BC%8F-vs-%E9%9A%90%E5%BC%8F-intent\"><span class=\"toc-text\"> ii. 显式 vs 隐式 Intent</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#iii-intent-filters-for-deep-linking\"><span class=\"toc-text\"> iii. Intent Filters for Deep Linking</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#g-activity-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\"> g. Activity 之间的通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#h-tasks-vs-activities-vs-processes\"><span class=\"toc-text\"> h. Tasks vs Activities vs Processes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#i-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\"> i. 安卓开发中的任务管理。</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#activity-%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\"> Activity 与进程管理的核心概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#j-activity-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86\"><span class=\"toc-text\"> j. Activity 的生命周期管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#i-activity-%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%8A%B6%E6%80%81\"><span class=\"toc-text\"> I. Activity 的三种主要状态：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ii-%E4%BC%98%E5%85%88%E7%BA%A7%E9%99%8D%E4%BD%8E%E7%9A%84-activity\"><span class=\"toc-text\"> II. 优先级降低的 Activity</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#iii-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\"> III. 注意事项</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#iv-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\"> IV. 生命周期</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#v-ui%E4%BF%9D%E5%AD%98\"><span class=\"toc-text\"> V. UI保存</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vi-viewmodel\"><span class=\"toc-text\"> VI. ViewModel：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#vii-livedata\"><span class=\"toc-text\"> VII. LiveData：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-service\"><span class=\"toc-text\"> 2. Service</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-broadcast-receiver\"><span class=\"toc-text\"> 3. Broadcast Receiver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-content-provider\"><span class=\"toc-text\"> 4. Content Provider</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\"> 其他</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-kotlin\"><span class=\"toc-text\"> 1. Kotlin</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#i-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-kotlin\"><span class=\"toc-text\"> i. 为什么使用 Kotlin？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ii-%E4%B8%BA%E4%BB%80%E4%B9%88-kotlin-java\"><span class=\"toc-text\"> ii. 为什么 Kotlin &gt; Java？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#iii-coroutines-%E5%8D%8F%E7%A8%8B\"><span class=\"toc-text\"> iii. Coroutines 协程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-jetpack-compose\"><span class=\"toc-text\"> 2. Jetpack Compose</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#i-composable-function\"><span class=\"toc-text\"> i. Composable Function</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%9B%B6%E6%97%A5%E6%94%BB%E5%87%BB-zero-day-attack\"><span class=\"toc-text\"> 3. 零日攻击 (Zero-day Attack)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\"> 代码相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%B4%BB%E5%8A%A8%E7%B1%BB-appcompatactivity\"><span class=\"toc-text\"> 1. 活动类 AppCompatActivity</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%A7%86%E5%9B%BE%E7%B1%BB-view\"><span class=\"toc-text\"> 2. 视图类 View</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8%E8%A7%86%E5%9B%BE-listview\"><span class=\"toc-text\"> 列表视图 ListView</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%94%B6%E8%A7%86%E5%9B%BE-recyclerview\"><span class=\"toc-text\"> 回收视图 RecyclerView</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%B5%84%E6%BA%90%E7%B1%BB-r\"><span class=\"toc-text\"> 3. 资源类 R</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%84%8F%E5%9B%BE%E7%B1%BB-intent\"><span class=\"toc-text\"> 4. 意图类 Intent</span></a></li></ol></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"语言学习导航","uid":"625e3e920d4d18f0b54366f772b38b35","slug":"导航/导航-语言学习导航","date":"2024-05-24T10:44:53.000Z","updated":"2024-05-27T18:02:00.416Z","comments":true,"path":"api/articles/导航/导航-语言学习导航.json","keywords":null,"cover":"\\img\\post\\导航\\导航-语言学习导航\\cover.jpg","text":"关于语言学习的导航。...","permalink":"/post/导航/导航-语言学习导航","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"导航","slug":"导航","count":4,"path":"api/categories/导航.json"}],"tags":[{"name":"Languaue","slug":"Languaue","count":1,"path":"api/tags/Languaue.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"feature":true},"next_post":{"title":"笔记-LaTeX","uid":"24ad0055d0e4d9377d4df87cbfd9108d","slug":"笔记/笔记-LaTeX","date":"2024-10-25T23:33:20.000Z","updated":"2024-10-26T00:16:19.616Z","comments":true,"path":"api/articles/笔记/笔记-LaTeX.json","keywords":null,"cover":"\\img\\post\\笔记\\笔记-LaTeX\\cover.png","text":"关于LaTeX的笔记...","permalink":"/post/笔记/笔记-LaTeX","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"笔记","slug":"笔记","count":9,"path":"api/categories/笔记.json"}],"tags":[{"name":"LaTeX","slug":"LaTeX","count":1,"path":"api/tags/LaTeX.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"一个喜欢摸鱼的人。<p>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"},"QQ":{"icon":"/img/svg/QQ.svg","link":"https://qm.qq.com/q/XtwuUQpNCg"}}}},"feature":false}}