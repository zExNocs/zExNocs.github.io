{"title":"随笔-面向LLM的现代AI Agent","uid":"005711d4677049d5d52aeb7b3ad8d4d3","slug":"随笔/面向LLM的现代AI Agent","date":"2026-01-31T10:01:03.000Z","updated":"2026-02-01T19:12:22.973Z","comments":true,"path":"api/articles/随笔/面向LLM的现代AI Agent.json","keywords":null,"cover":"img/post/随笔/面向LLM的现代AI Agent/cover.png","content":"<h1 id=\"零-总结概述\"><a class=\"markdownIt-Anchor\" href=\"#零-总结概述\"></a> 零. 总结概述</h1>\n<h2 id=\"1-技术栈\"><a class=\"markdownIt-Anchor\" href=\"#1-技术栈\"></a> 1. 技术栈</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">技术栈</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Prompt Engineering</td>\n<td>提示词工程，设计和优化输入输出交互，引导模型产生最佳单次输出决策的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Context Engineering</td>\n<td>上下文工程，设计和管理更大范围的上下文信息，在多轮交互中提升模型表现的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MCP<br>Model Context Protocol</td>\n<td>一种使用 AI 工具类的协议</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Skills</td>\n<td>一种快速检索提示词的方法</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-术语\"><a class=\"markdownIt-Anchor\" href=\"#2-术语\"></a> 2. 术语</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">术语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h1 id=\"一-介绍\"><a class=\"markdownIt-Anchor\" href=\"#一-介绍\"></a> 一. 介绍</h1>\n<p>Agent 是一种以环境、任务和目标为基础能够自主决策的计算机程序。</p>\n<p>基于 LLM 的 AI Agent 是利用大语言模型对自然语言的处理来让程序更好地理解和执行任务。也可以说是一种指导 LLM 进行自主决策和行动的系统。</p>\n<p>AI Agent 主要包括以下几个核心组件：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">组件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">检索 <br> Retrieval</td>\n<td>负责从知识库中检索相关信息来组成上下文</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">工具调用 <br> Tool Calling</td>\n<td>负责调用外部工具和 API 来扩展模型的功能</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">记忆 <br> Memory</td>\n<td>负责读写和管理长期和短期记忆，以满足用户个性化需求</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"1-ai-agent-要注意的事\"><a class=\"markdownIt-Anchor\" href=\"#1-ai-agent-要注意的事\"></a> 1. AI Agent 要注意的事</h2>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果 LLM 能够更好地理解和生成自然语言，那么 Agent 就能够更准确地理解任务需求并做出更合适的决策。相反，如果 LLM 的能力有限，Agent 的性能也会受到限制。</p></blockquote>\n<p>相对于传统的 Agent，基于 LLM 的 Agent 性能不仅取决于其算法和规则框架，还非常依赖于 LLM 的质量和能力。</p>\n<p>此外，LLM 的输出是基于概率的，是偏向于自然语言的，具有一定的不确定性。因此，AI Agent 需要设计相应的机制来处理这种不确定性，例如通过多次采样、结果验证等方法来提高决策的鲁棒性。</p>\n<h2 id=\"2-最简单的-ai-agent\"><a class=\"markdownIt-Anchor\" href=\"#2-最简单的-ai-agent\"></a> 2. 最简单的 AI Agent</h2>\n<p>最简单的 AI Agent 就是我们常见的网页与 LLM 进行对话交互。该模式下，用户输入问题，LLM 根据模型知识库生成回答，用户再根据回答继续提问，以此类推。每一次 LLM 的输入都是基于用户的最新输入和历史对话内容生成的。这种历史对话内容也被称之为 上下文 (Context)。</p>\n<h2 id=\"3-prompt-engineering\"><a class=\"markdownIt-Anchor\" href=\"#3-prompt-engineering\"></a> 3. Prompt Engineering</h2>\n<p>LLM 相当于一种黑盒函数，能够将序列输入 (自然语言) 映射到序列输出。我们可以简单定义为：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"bold\">x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"bold\">y</mi></mrow><annotation encoding=\"application/x-tex\">f(\\mathbf{x}) = \\mathbf{y}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbf\">x</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.63888em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">y</span></span></span></span></span></span></p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">x</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">x</span></span></span></span></span> 是输入的自然语言序列，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">y</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{y}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.63888em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">y</span></span></span></span></span> 是输出的自然语言序列，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 是 LLM 模型。</p>\n<p>为了提升 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">y</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{y}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.63888em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">y</span></span></span></span></span> 的质量，我们有两种思路：</p>\n<ol>\n<li>提升 LLM 模型 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 的能力。</li>\n<li>优化输入 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">x</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{x}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">x</span></span></span></span></span>。</li>\n</ol>\n<p>其中对于第二种方法，是一种完全不依赖于训练模型、修改模型参数来提升 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">y</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{y}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.63888em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">y</span></span></span></span></span> 质量的方法，只需要组织好自然语言即可。这种方法被称之为 提示工程 (Prompt Engineering)。</p>\n<p>例如使用自然语言去引导 LLM 生成 JSON 格式的数据，亦或者让 LLM 去扮演某个角色，并以该角色的身份去回答问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设你是一个专业的数学老师，正在教导一个学生解决下面的数学问题。</span><br><span class=\"line\">先回答下面的问题的答案，并列出该问题的每个详细步骤。</span><br><span class=\"line\">并利用这些步骤对答案进行验算是否正确，</span><br><span class=\"line\">最终以 latex 代码的格式输出结果。</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"二-上下文工程\"><a class=\"markdownIt-Anchor\" href=\"#二-上下文工程\"></a> 二. 上下文工程</h1>\n<p>在传统的提示词工程中，往往专注的是设计少量次数的输入输出交互，引导模型作出最佳单次输出决策。这种方法在简单应用中非常有效，但是在更复杂的任务中，单次交互往往无法满足需求。</p>\n<p>上下文工程 (Context Engineering) 则是通过设计和系统性地管理更大范围的上下文信息，从大量的上下文信息中筛选出关键内容，从而在多轮、持续的交互中提升模型的表现，做出符合长期目标的决策。上下文工程是一种更高级的提示工程。</p>\n<p>上下文工程的关键组成成分包括但不限于：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">组成成分</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">短期记忆</td>\n<td>近期的对话内容和交互历史，帮助模型理解当前的上下文<br>往往是直接存放在内存中的信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">长期记忆</td>\n<td>重要的背景信息和用户偏好，帮助模型做出更符合用户需求的决策<br>往往是存放在数据库中的信息，在需要时加载</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">窗口优化</td>\n<td>管理和优化模型的上下文窗口，确保关键内容被优先考虑，包括：<br> 1. 压缩：总结过往对话<br>2. 过滤：去除无关信息<br>3. 优先级排序：将更关键的信息进行特殊标注</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">思维链</td>\n<td>一种分步推理的方法，帮助模型逐步解决复杂问题<br>通过引导模型进行多步思考，提升其解决问题的能力<br> 例如 ReAct 框架、DeepSeek 深度思考</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">系统提示</td>\n<td>预定义的规则和指导方针，帮助模型遵循特定的行为规范<br>通常是固定不变的提示词，被精心设计在上下文的开头</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">工具使用</td>\n<td>集成外部工具和 API，扩展模型的功能<br>允许模型在需要时调用外部资源，例如网络搜索、本地文件检索</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"1-为什么需要上下文工程\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么需要上下文工程\"></a> 1. 为什么需要上下文工程</h2>\n<p>上下文工程的目标往往是：</p>\n<ul>\n<li>方便用户快速调用和管理大量的提示词和上下文信息。</li>\n<li>提升模型的长期记忆和理解能力。</li>\n<li>节约 Token 资源，避免输入冗余和无关的信息。</li>\n<li>与模型无关，适用于各种 LLM 模型，也可以同时适用于多模型协同工作。</li>\n</ul>\n<h3 id=\"i-管理大量提示词\"><a class=\"markdownIt-Anchor\" href=\"#i-管理大量提示词\"></a> i. 管理大量提示词</h3>\n<p>假设用户现在拥有一个 AI Agent 来帮助管理日常生活中的各种应用，包括教用户写程序的提示词(使用什么样的伪代码、什么样的输出格式、怎么测试代码)、教用户做菜的提示词(每一步的详细步骤、注意事项)、教用户聊天的提示词(对方的性格、兴趣爱好、聊天风格)等。</p>\n<p>每一个提示词都使用了 Prompt Engineering 的方法设计了非常详细的上下文内容。当用户想要用到某一种提示词时，只需要复制粘贴到 LLM 的输入框中即可。但是这些提示词就会慢慢积累变多，单纯依靠复制粘贴就会变得非常麻烦。</p>\n<p>如果一股脑将所有提示词丢给 LLM，会浪费 Token 资源，并且也导致 LLM 很难聚焦在用户当前想要使用的提示词上。</p>\n<p>上下文工程就是来帮助用户管理和使用这些提示词。用户可以将所有提示词存放在一个数据库中，当需要使用某一种提示词时，AI Agent 会根据用户的需求，从数据库中检索出最相关的提示词，并将其作为上下文的一部分，添加到 LLM 的输入中。</p>\n<h3 id=\"ii-节约-token-资源\"><a class=\"markdownIt-Anchor\" href=\"#ii-节约-token-资源\"></a> ii. 节约 Token 资源</h3>\n<p>为什么要节约 Token 资源? 非常简单，Token = 钱。上下文越长，消耗的 Token 越多，花费的成本也就越多。</p>\n<h2 id=\"2-系统提示词\"><a class=\"markdownIt-Anchor\" href=\"#2-系统提示词\"></a> 2. 系统提示词</h2>\n<p>系统提示词 (System Prompt) 一般是用于预定义规则和指导方针，帮助模型遵循特定的行为规范。</p>\n<p>在 OpenAI 的 api 接口中，其 JSON 形式通常如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;content&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>  <span class=\"comment\">// 系统提示词的具体内容</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>     <span class=\"comment\">// 可选，角色名称</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;role&quot;</span><span class=\"punctuation\">:</span> string      <span class=\"comment\">// 固定值 &quot;system&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-工具提示词\"><a class=\"markdownIt-Anchor\" href=\"#3-工具提示词\"></a> 3. 工具提示词</h2>\n<p>工具提示词 (Tool Prompt) 是专门用于承载“工具执行结果”的消息类型。其核心作用就是把“工具调用的返回值”以结构化方式注入回模型上下文，让模型基于真实执行结果继续推理。</p>\n<p>Tool Message 不是模型生成的，而是由 Agent Runtime 构造的，内容来自于真实工具执行结果。</p>\n<p>完整的工具调用链通常是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserMessage</span><br><span class=\"line\">↓</span><br><span class=\"line\">AssistantMessage (决定调用工具，产生 tool_call)</span><br><span class=\"line\">↓</span><br><span class=\"line\">[执行工具]</span><br><span class=\"line\">↓</span><br><span class=\"line\">ToolMessage (把执行结果喂回模型)</span><br><span class=\"line\">↓</span><br><span class=\"line\">AssistantMessage (基于结果继续回答或再调用工具)</span><br></pre></td></tr></table></figure>\n<p>记住再次打包发送时要将该 ToolMessage 放在触发它的 AssistantMessage 之后。</p>\n<p>在 OpenAI 的 api 接口中，其 JSON 形式通常如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;content&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>        <span class=\"comment\">// 工具提示词的具体内容</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;toolCallId&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>     <span class=\"comment\">// 此消息响应上一个 AssistantMessage 的 tool_call_id</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;role&quot;</span><span class=\"punctuation\">:</span> string            <span class=\"comment\">// 固定值 &quot;tool&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>相应的，在 request 中还需要包含 <code>list&lt;tools&gt;</code> 字段来定义可用的工具。对于 <code>tools</code> 字段，其 JSON 形式通常如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>      <span class=\"comment\">// 工具的描述</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>    <span class=\"comment\">// 工具的类型，通常是 &quot;function&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;function&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span>      <span class=\"comment\">// 工具类</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>  <span class=\"comment\">// 工具的描述</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>         <span class=\"comment\">// 工具的名称</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;arguments&quot;</span><span class=\"punctuation\">:</span> string<span class=\"punctuation\">,</span>    <span class=\"comment\">// 工具的输出参数，遵循 JSON Schema 规范</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;parameters&quot;</span><span class=\"punctuation\">:</span> object    <span class=\"comment\">// 工具的输入参数，遵循 JSON Schema 规范</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"三-rag-与-agentic-rag\"><a class=\"markdownIt-Anchor\" href=\"#三-rag-与-agentic-rag\"></a> 三. RAG 与 Agentic RAG</h1>\n<p>RAG (Retrieval-Augmented Generation) 是一种结合信息检索和生成模型的技术，用于提升生成内容的准确性和相关性。其核心思想是通过检索相关信息来增强生成模型的输入，从而生成更符合用户需求的回答。</p>\n<p>RAG 是上下文工程中的一个重要组成部分，主要负责从知识库中检索相关信息来组成上下文。</p>\n<h2 id=\"1-传统-rag\"><a class=\"markdownIt-Anchor\" href=\"#1-传统-rag\"></a> 1. 传统 RAG</h2>\n<p>传统的 RAG (Retrieval-Augmented Generation) 包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文档 </span><br><span class=\"line\">→ 切片 </span><br><span class=\"line\">→ 转化成词向量 (Embedding)</span><br><span class=\"line\">→ 存放数据库 </span><br><span class=\"line\">→ 检索 </span><br><span class=\"line\">→ 拼接上下文 </span><br><span class=\"line\">→ LLM 生成回答</span><br></pre></td></tr></table></figure>\n<p>传统的 RAG 核心特征是：</p>\n<ul>\n<li>一次检索，一次生成</li>\n<li>无状态、无规划，索引取决于词向量相似度计算</li>\n<li>检索逻辑是固定的（embedding + cosine / dot）</li>\n</ul>\n<p>其优势是：</p>\n<ul>\n<li>简单稳定，成本低</li>\n<li>可解释性强 (词向量相似度计算，且可以查看检索结果)</li>\n<li>很好做评估</li>\n</ul>\n<p>其劣势是：</p>\n<ul>\n<li>索引质量可能并没有想象的好</li>\n<li>检索错了就会导致全错</li>\n<li>系统不会意识到自己错了</li>\n<li>无法拆解复杂的问题，不擅长跨文档、跨步骤推理、使用工具</li>\n</ul>\n<h2 id=\"2-agentic-rag\"><a class=\"markdownIt-Anchor\" href=\"#2-agentic-rag\"></a> 2. Agentic RAG</h2>\n<p>Agentic RAG 是一个系统范式，把索引全权交给 Agent 来管理。其工作流程是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户问题</span><br><span class=\"line\"> → LLM 判断：是否需要检索？</span><br><span class=\"line\"> → 生成检索 Query</span><br><span class=\"line\"> → 调用 Retriever</span><br><span class=\"line\"> → 阅读结果</span><br><span class=\"line\"> → 判断是否足够？</span><br><span class=\"line\">    ├─ 否 → 改写 Query / 换策略 / 再检索</span><br><span class=\"line\">    └─ 是 → 推理 + 生成</span><br><span class=\"line\"> → 可选：自检 / 反思 / 再修正</span><br></pre></td></tr></table></figure>\n<p>其核心特征是：</p>\n<ul>\n<li>多次、动态检索，推理结构是显式、多步的，查询次数取决于 LLM (例如 Long COT thinking)</li>\n<li>可使用工具链、多模型协同工作 (工具调用, Function Calling)</li>\n<li>在获取最终答案前，可以多次检索、反思、修正</li>\n</ul>\n<p>但代价是：</p>\n<ul>\n<li>复杂度高，系统设计难度大</li>\n<li>延迟高，需要多次交互</li>\n<li>成本高，需要消耗大量 Token</li>\n</ul>\n<details class=\"custom-details\">\n<summary>Agentic RAG 示例</summary>\n<p>该样例来自于 <a href=\"https://www.bilibili.com/video/BV15eBLBfEAw/\">bilibili: BV15eBLBfEAw</a></p>\n<p>例如，设计诸如下面的搜索过程：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第1轮搜索：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 工具：query<span class=\"emphasis\">_knowledge_</span>base(&quot;LangChain 函数调用 功能 实现&quot;)</span><br><span class=\"line\"><span class=\"bullet\">-</span> 观察：命中低、证据不足</span><br><span class=\"line\"><span class=\"bullet\">-</span> 决策：尝试改写查询词</span><br><span class=\"line\"></span><br><span class=\"line\">第2轮搜索：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 推理：“函数调用” 常见英文术语是 “Function Calling”</span><br><span class=\"line\"><span class=\"bullet\">-</span> 工具：query<span class=\"emphasis\">_knowledge_</span>base(&quot;LangChain Function Calling&quot;)</span><br><span class=\"line\"><span class=\"bullet\">-</span> 观察：命中高相关chunk (相似度 0.89)，含实现细节</span><br><span class=\"line\"></span><br><span class=\"line\">第3轮搜索：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 工具：query<span class=\"emphasis\">_knowledge_</span>base(&quot;LangChain Tool Calling&quot;)</span><br><span class=\"line\"><span class=\"bullet\">-</span> 观察：补充工具使用相关文档</span><br><span class=\"line\"></span><br><span class=\"line\">回答：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 基于已读片段整理实现步骤，包含 “函数调用” 的最小实现片段与说明。</span><br></pre></td></tr></table></figure>\n<p>其中需要为这个系统设计系统提示词：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你是一个 Agentic RAG 助手。请遵循以下策略逐步收集证据后回答：</span><br><span class=\"line\"><span class=\"bullet\">1.</span> 先用 query<span class=\"emphasis\">_knowledge_</span>base 工具检索相关信息，获取候选文件和片段线索</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 根据搜索结果，选择最相关的片段，可选择性使用 get<span class=\"emphasis\">_files_</span>meta 查看详细文件信息</span><br><span class=\"line\"><span class=\"bullet\">3.</span> 使用 read<span class=\"emphasis\">_file_</span>chunks 精读最相关的 2-3 个片段作为证据</span><br><span class=\"line\"><span class=\"bullet\">4.</span> 基于读取的具体片段内容组织答案</span><br><span class=\"line\"><span class=\"bullet\">5.</span> 回答末尾用&quot;引用:&quot; 格式列出实际读取的 fileId 和 chunkIndex</span><br><span class=\"line\"><span class=\"bullet\">6.</span> 调用 read<span class=\"emphasis\">_file_</span>chunks 时，参数必须是列表，每个元素为 &#123;&quot;fileId&quot;: 整数, &quot;chunkIndex&quot;: 整数&#125; 格式</span><br><span class=\"line\"><span class=\"bullet\">7.</span> 不要使用 file<span class=\"emphasis\">_id 或 chunk_</span>index，必须用驼峰命名 fileId 和 chunkIndex</span><br><span class=\"line\"><span class=\"bullet\">8.</span> 确保 JSON 完整，不要省略括号或者引号</span><br><span class=\"line\"></span><br><span class=\"line\">重要原则：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 不要编造信息，只基于实际读取的片段内容回答</span><br><span class=\"line\"><span class=\"bullet\">-</span> 若证据不足，请说明并建议进一步搜索的方向</span><br><span class=\"line\"><span class=\"bullet\">-</span> 优化选择评分高的搜索结果进行深入阅读</span><br></pre></td></tr></table></figure>\n\n</details>\n<hr />\n<h1 id=\"四-mcp-协议\"><a class=\"markdownIt-Anchor\" href=\"#四-mcp-协议\"></a> 四. MCP 协议</h1>\n<hr />\n<h1 id=\"五-skills-技术\"><a class=\"markdownIt-Anchor\" href=\"#五-skills-技术\"></a> 五. Skills 技术</h1>\n<p>Agent Skills 是一种能让 AI 快速调用、按需加载相关提示词的技术，其包括元数据、提示词和可能的工具(脚本、模板)，让AI Agent在需要时自动加载和使用。</p>\n<p>简单来说，用户将所有提示词按照不同的分类和标签进行归类，并为每一个提示词写一个简单的概括 (叫做 metadata)，一同存放在数据库中。当用户使用 AI Agent 时，它会根据用户的需求，从数据库中检索出最相关的 Skill，并将其作为上下文的一部分（或执行某些脚本），添加到 LLM 的输入中。</p>\n<h2 id=\"1-skills-的工作流程\"><a class=\"markdownIt-Anchor\" href=\"#1-skills-的工作流程\"></a> 1. Skills 的工作流程</h2>\n<p>Skills 的步骤包括：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">步骤</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Discovery</td>\n<td>发送请求时，加载每个可用 Skill 的名称和元数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Activation</td>\n<td>1. 通过语义相似性来匹配请求与描述<br>2. 请求与某个 Skill 的描述匹配时，激活该 Skill<br>3. 将完整的 <code>SKILL.md</code> 加载到上下文中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Execution</td>\n<td>按照 Skill 的说明执行，根据需要加载引用的文件或运行捆绑的脚本</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-skill-结构\"><a class=\"markdownIt-Anchor\" href=\"#2-skill-结构\"></a> 2. Skill 结构</h2>\n<p>Skill 可以看作是一个包含所有这些提示词信息的一个单元，其结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skill-name/</span><br><span class=\"line\"> ├── SKILL.md          # Skill 的描述和元数据</span><br><span class=\"line\"> ├── scripts/          # 可选的脚本文件</span><br><span class=\"line\"> └── references/       # 可选的参考文件</span><br></pre></td></tr></table></figure>\n<p>对于 <code>SKILL.md</code> 文件，其内容结构如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">name: my-skill</span><br><span class=\"line\"><span class=\"section\">description: My personal workflow skill</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># My Skill</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1.</span> Step one... Inferring certain segments...</span><br><span class=\"line\"><span class=\"bullet\">2.</span> Step two... Using some tools...</span><br><span class=\"line\"><span class=\"bullet\">3.</span> Step three... Concluding with...</span><br><span class=\"line\">etc.</span><br><span class=\"line\"></span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\"></a> 参考文献</h1>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1PRvhBSEwx/\">video: 【闪客】你管这破玩意叫智能体？Manus背后的技术</a></li>\n<li><a href=\"https://aibook.ren/archives/what-is-skills-overall\">web: 一文看懂什么是Agent技能（Skills），用来干什么的？怎么用它？</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1dz6oBWEWx/\">video: 什么是大模型Skill 10分钟弄懂</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV15eBLBfEAw/\">video: 【B站首推】Agentic RAG 才是未来！吊打传统 RAG！…</a></li>\n</ul>\n<hr />\n<h1 id=\"参考项目\"><a class=\"markdownIt-Anchor\" href=\"#参考项目\"></a> 参考项目</h1>\n<p>排名不分先后，内容只显示了与该文章相关的技术栈：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">项目名称</th>\n<th>项目包含内容</th>\n<th>项目仓库</th>\n<th>项目文档</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">MCP</td>\n<td>MCP 官方文档</td>\n<td></td>\n<td>- <a href=\"https://modelcontextprotocol.io/docs/getting-started/intro\">wiki</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MemoryOS</td>\n<td>参考系统中内存管理原理实现的高效记忆管理<br>1. 记忆添加、查询、生成用户画像</td>\n<td>- <a href=\"https://github.com/BAI-LAB/MemoryOS\">github</a></td>\n<td>- <a href=\"https://arxiv.org/abs/2506.06326\">arxiv</a><br>- <a href=\"https://bai-lab.github.io/MemoryOS/docs\">wiki</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Langchain</td>\n<td>用于构建智能体和基于 LLM 的应用程序的框架<br>1. 长期记忆与短期记忆</td>\n<td>- <a href=\"https://github.com/langchain-ai/langchain\">github</a></td>\n<td>- <a href=\"https://docs.langchain.com/oss/python/langchain/overview\">wiki</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MoeChat</td>\n<td>语音交互系统，用语音和 AI 角色自然对话<br>1. 长期记忆查询 (针对时间)</td>\n<td>- <a href=\"https://github.com/AlfreScarlet/MoeChat/tree/main\">github</a></td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MaiBot</td>\n<td>具有拟人功能的 AI Agent<br>1. 模仿人类对话风格<br>2. Agent 行为规划<br>3. 情绪系统和表情包互动能力</td>\n<td>- <a href=\"https://github.com/Mai-with-u/MaiBot\">github</a></td>\n<td>- <a href=\"https://docs.mai-mai.org/\">wiki</a><br>- <a href=\"https://reference.langchain.com/python/\">api</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MoFox</td>\n<td>基于 <a href=\"https://github.com/Mai-with-u/MaiBot\">MaiBot</a> 的第三方分支<br>1. MCP 系统<br>2. 拓展记忆系统</td>\n<td>- <a href=\"https://github.com/MoFox-Studio/MoFox-Core\">github</a></td>\n<td>- <a href=\"https://deepwiki.com/MoFox-Studio/MoFox_Bot\">deep wiki</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NagaAgent</td>\n<td>功能丰富的智能对话助手系统<br>1. 多 Agent 管理系统<br>2. MCP 系统</td>\n<td>- <a href=\"https://github.com/Xxiii8322766509/NagaAgent\">github</a></td>\n<td>- <a href=\"https://github.com/Xxiii8322766509/NagaAgent/blob/main/README.md\">github</a></td>\n</tr>\n</tbody>\n</table>\n","feature":false,"text":"有关面向大语言模型（LLM）的现代AI Agent的随笔。...","permalink":"/post/随笔/面向LLM的现代AI Agent","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[{"name":"随笔-Agent","slug":"随笔-Agent","count":1,"path":"api/categories/随笔-Agent.json"}],"tags":[{"name":"LLM","slug":"LLM","count":1,"path":"api/tags/LLM.json"},{"name":"Agent","slug":"Agent","count":1,"path":"api/tags/Agent.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%B6-%E6%80%BB%E7%BB%93%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\"> 零. 总结概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%8A%80%E6%9C%AF%E6%A0%88\"><span class=\"toc-text\"> 1. 技术栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\"> 2. 术语</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 一. 介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-ai-agent-%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B\"><span class=\"toc-text\"> 1. AI Agent 要注意的事</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-ai-agent\"><span class=\"toc-text\"> 2. 最简单的 AI Agent</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-prompt-engineering\"><span class=\"toc-text\"> 3. Prompt Engineering</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\"> 二. 上下文工程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\"> 1. 为什么需要上下文工程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#i-%E7%AE%A1%E7%90%86%E5%A4%A7%E9%87%8F%E6%8F%90%E7%A4%BA%E8%AF%8D\"><span class=\"toc-text\"> i. 管理大量提示词</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ii-%E8%8A%82%E7%BA%A6-token-%E8%B5%84%E6%BA%90\"><span class=\"toc-text\"> ii. 节约 Token 资源</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%B3%BB%E7%BB%9F%E6%8F%90%E7%A4%BA%E8%AF%8D\"><span class=\"toc-text\"> 2. 系统提示词</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%B7%A5%E5%85%B7%E6%8F%90%E7%A4%BA%E8%AF%8D\"><span class=\"toc-text\"> 3. 工具提示词</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-rag-%E4%B8%8E-agentic-rag\"><span class=\"toc-text\"> 三. RAG 与 Agentic RAG</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BC%A0%E7%BB%9F-rag\"><span class=\"toc-text\"> 1. 传统 RAG</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-agentic-rag\"><span class=\"toc-text\"> 2. Agentic RAG</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B-mcp-%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\"> 四. MCP 协议</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94-skills-%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\"> 五. Skills 技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-skills-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\"> 1. Skills 的工作流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-skill-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\"> 2. Skill 结构</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"><span class=\"toc-text\"> 参考文献</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\"> 参考项目</span></a></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"深度学习-导航","uid":"3a4df68478d92cfa87fd38d380f924de","slug":"笔记/深度学习/深度学习导航","date":"2025-12-25T10:00:01.000Z","updated":"2026-01-05T04:15:43.614Z","comments":true,"path":"api/articles/笔记/深度学习/深度学习导航.json","keywords":null,"cover":"img/post/笔记/深度学习/导航/cover.webp","text":"关于深度学习的笔记导航。...","permalink":"/post/笔记/深度学习/深度学习导航","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"导航","slug":"导航","count":8,"path":"api/categories/导航.json"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","count":15,"path":"api/tags/Machine-Learning.json"},{"name":"Deep Learning","slug":"Deep-Learning","count":15,"path":"api/tags/Deep-Learning.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"feature":true},"next_post":{"title":"AADS-高级算法和数据结构期末","uid":"bd67a29e57b431e7a8ac14fb82ce9f83","slug":"笔记/算法和数据结构/期末","date":"2026-01-06T05:49:58.000Z","updated":"2026-01-31T10:00:32.139Z","comments":true,"path":"api/articles/笔记/算法和数据结构/期末.json","keywords":null,"cover":"img/post/笔记/算法和数据结构/期末/cover.jpg","text":"用于记录AADS-高级算法和数据结构期末复习内容。...","permalink":"/post/笔记/算法和数据结构/期末","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"笔记-算法和数据结构","slug":"笔记-算法和数据结构","count":2,"path":"api/categories/笔记-算法和数据结构.json"}],"tags":[{"name":"Algorithms","slug":"Algorithms","count":3,"path":"api/tags/Algorithms.json"},{"name":"Data Structures","slug":"Data-Structures","count":10,"path":"api/tags/Data-Structures.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"feature":false}}