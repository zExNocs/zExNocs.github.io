{"title":"随笔-AI Agent的检索工程","uid":"2dbcaf6d8ccd6aa6ce71937af4c45000","slug":"随笔/AI Agent的检索工程","date":"2026-02-02T06:02:27.000Z","updated":"2026-02-03T10:41:21.498Z","comments":true,"path":"api/articles/随笔/AI Agent的检索工程.json","keywords":null,"cover":"img/post/随笔/AI Agent的检索工程/cover.png","content":"<p><a href=\"%E9%9A%8F%E7%AC%94%2FAI%20Agent-%E9%9D%A2%E5%90%91LLM%E7%9A%84%E6%99%BA%E8%83%BD%E4%BB%A3%E7%90%86\">&lt;返回 AI Agent 目录</a></p>\n<hr />\n<h1 id=\"一-介绍\"><a class=\"markdownIt-Anchor\" href=\"#一-介绍\"></a> 一. 介绍</h1>\n<p>检索技术是从 Agent管理的数据(包括知识、指令、工具) 中获取与问题相关的上下文，以支持大语言模型生成准确回答的方法。它是上下文工程中的 检索(Retrieval)组件 和 选择(Select) 机制。</p>\n<hr />\n<h1 id=\"二-检索增强生成技术-rag\"><a class=\"markdownIt-Anchor\" href=\"#二-检索增强生成技术-rag\"></a> 二. 检索增强生成技术 RAG</h1>\n<p>RAG (Retrieval-Augmented Generation) 是一种结合信息检索和生成模型的技术，用于提升生成内容的准确性和相关性。其核心思想是通过检索相关信息来增强生成模型的输入，从而生成更符合用户需求的回答。</p>\n<p>RAG 是上下文工程中的一个重要组成部分，主要负责从知识库中检索相关信息来组成上下文。</p>\n<hr />\n<h2 id=\"1-传统推理前检索-rag\"><a class=\"markdownIt-Anchor\" href=\"#1-传统推理前检索-rag\"></a> 1. 传统推理前检索 RAG</h2>\n<p>传统的 RAG (Retrieval-Augmented Generation) 包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文档 </span><br><span class=\"line\">→ 切片 </span><br><span class=\"line\">→ 转化成词向量 (Embedding)</span><br><span class=\"line\">→ 存放数据库 </span><br><span class=\"line\">→ 检索 </span><br><span class=\"line\">→ 拼接上下文 </span><br><span class=\"line\">→ LLM 生成回答</span><br></pre></td></tr></table></figure>\n<p>传统的 RAG 核心特征是：</p>\n<ul>\n<li>一次检索，一次生成</li>\n<li>无状态、无规划，索引取决于词向量相似度计算</li>\n<li>检索逻辑是固定的（embedding + cosine / dot）</li>\n</ul>\n<p>其优势是：</p>\n<ul>\n<li>简单稳定，成本低</li>\n<li>可解释性强 (词向量相似度计算，且可以查看检索结果)</li>\n<li>很好做评估</li>\n</ul>\n<p>其劣势是：</p>\n<ul>\n<li>索引质量可能并没有想象的好</li>\n<li>检索错了就会导致全错</li>\n<li>系统不会意识到自己错了</li>\n<li>无法拆解复杂的问题，不擅长跨文档、跨步骤推理、使用工具</li>\n</ul>\n<hr />\n<h2 id=\"2-即时检索-agentic-rag\"><a class=\"markdownIt-Anchor\" href=\"#2-即时检索-agentic-rag\"></a> 2. 即时检索 Agentic RAG</h2>\n<p>Agentic RAG 是一个系统范式，把索引全权交给 Agent 来管理。其工作流程是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户问题</span><br><span class=\"line\"> → LLM 判断：是否需要检索？</span><br><span class=\"line\"> → 生成检索 Query</span><br><span class=\"line\"> → 调用 Retriever</span><br><span class=\"line\"> → 阅读结果</span><br><span class=\"line\"> → 判断是否足够？</span><br><span class=\"line\">    ├─ 否 → 改写 Query / 换策略 / 再检索</span><br><span class=\"line\">    └─ 是 → 推理 + 生成</span><br><span class=\"line\"> → 可选：自检 / 反思 / 再修正</span><br></pre></td></tr></table></figure>\n<p>其核心特征是：</p>\n<ul>\n<li>多次、动态检索，推理结构是显式、多步的，查询次数取决于 LLM (例如 Long COT thinking)</li>\n<li>可使用工具链、多模型协同工作 (工具调用, Function Calling)</li>\n<li>在获取最终答案前，可以多次检索、反思、修正</li>\n</ul>\n<p>但代价是：</p>\n<ul>\n<li>复杂度高，系统设计难度大</li>\n<li>延迟高，需要多次交互</li>\n<li>成本高，需要消耗大量 Token</li>\n</ul>\n<details class=\"custom-details\">\n<summary>Agentic RAG 示例</summary>\n<p>该样例来自于 <a href=\"https://www.bilibili.com/video/BV15eBLBfEAw/\">bilibili: BV15eBLBfEAw</a></p>\n<p>例如，设计诸如下面的搜索过程：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第1轮搜索：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 工具：query<span class=\"emphasis\">_knowledge_</span>base(&quot;LangChain 函数调用 功能 实现&quot;)</span><br><span class=\"line\"><span class=\"bullet\">-</span> 观察：命中低、证据不足</span><br><span class=\"line\"><span class=\"bullet\">-</span> 决策：尝试改写查询词</span><br><span class=\"line\"></span><br><span class=\"line\">第2轮搜索：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 推理：“函数调用” 常见英文术语是 “Function Calling”</span><br><span class=\"line\"><span class=\"bullet\">-</span> 工具：query<span class=\"emphasis\">_knowledge_</span>base(&quot;LangChain Function Calling&quot;)</span><br><span class=\"line\"><span class=\"bullet\">-</span> 观察：命中高相关chunk (相似度 0.89)，含实现细节</span><br><span class=\"line\"></span><br><span class=\"line\">第3轮搜索：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 工具：query<span class=\"emphasis\">_knowledge_</span>base(&quot;LangChain Tool Calling&quot;)</span><br><span class=\"line\"><span class=\"bullet\">-</span> 观察：补充工具使用相关文档</span><br><span class=\"line\"></span><br><span class=\"line\">回答：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 基于已读片段整理实现步骤，包含 “函数调用” 的最小实现片段与说明。</span><br></pre></td></tr></table></figure>\n<p>其中需要为这个系统设计系统提示词：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">你是一个 Agentic RAG 助手。请遵循以下策略逐步收集证据后回答：</span><br><span class=\"line\"><span class=\"bullet\">1.</span> 先用 query<span class=\"emphasis\">_knowledge_</span>base 工具检索相关信息，获取候选文件和片段线索</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 根据搜索结果，选择最相关的片段，可选择性使用 get<span class=\"emphasis\">_files_</span>meta 查看详细文件信息</span><br><span class=\"line\"><span class=\"bullet\">3.</span> 使用 read<span class=\"emphasis\">_file_</span>chunks 精读最相关的 2-3 个片段作为证据</span><br><span class=\"line\"><span class=\"bullet\">4.</span> 基于读取的具体片段内容组织答案</span><br><span class=\"line\"><span class=\"bullet\">5.</span> 回答末尾用&quot;引用:&quot; 格式列出实际读取的 fileId 和 chunkIndex</span><br><span class=\"line\"><span class=\"bullet\">6.</span> 调用 read<span class=\"emphasis\">_file_</span>chunks 时，参数必须是列表，每个元素为 &#123;&quot;fileId&quot;: 整数, &quot;chunkIndex&quot;: 整数&#125; 格式</span><br><span class=\"line\"><span class=\"bullet\">7.</span> 不要使用 file<span class=\"emphasis\">_id 或 chunk_</span>index，必须用驼峰命名 fileId 和 chunkIndex</span><br><span class=\"line\"><span class=\"bullet\">8.</span> 确保 JSON 完整，不要省略括号或者引号</span><br><span class=\"line\"></span><br><span class=\"line\">重要原则：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 不要编造信息，只基于实际读取的片段内容回答</span><br><span class=\"line\"><span class=\"bullet\">-</span> 若证据不足，请说明并建议进一步搜索的方向</span><br><span class=\"line\"><span class=\"bullet\">-</span> 优化选择评分高的搜索结果进行深入阅读</span><br></pre></td></tr></table></figure>\n\n</details>\n<hr />\n<h2 id=\"3-混合策略\"><a class=\"markdownIt-Anchor\" href=\"#3-混合策略\"></a> 3. 混合策略</h2>\n<p>在混合策略中，AI Agent 并不是一次性将所有的工具都一股脑地丢给 LLM，而是根据不同的任务需求渐进式地揭示上下文：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">步骤</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">利用元数据<br>metadata</td>\n<td>使用文件名、目录结构、API 状态码等 “启发式信号” 来缩小检索范围</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">渐进式披露<br>progressive disclosure</td>\n<td>通过主动探索，一层层地揭示上下文，并保证始终聚焦于核心任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">重排序<br>Re-ranking</td>\n<td>使用更精细的模型进行二次精选，提升信噪比</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h1 id=\"三-skills-技术\"><a class=\"markdownIt-Anchor\" href=\"#三-skills-技术\"></a> 三. Skills 技术</h1>\n<p>Agent Skills 是一种能让 AI 快速调用、按需加载相关提示词的技术，其包括元数据、提示词和可能的工具(脚本、模板)，让AI Agent在需要时自动加载和使用。</p>\n<p>简单来说，用户将所有提示词按照不同的分类和标签进行归类，并为每一个提示词写一个简单的概括 (叫做 metadata)，一同存放在数据库中。当用户使用 AI Agent 时，它会根据用户的需求，从数据库中检索出最相关的 Skill，并将其作为上下文的一部分（或执行某些脚本），添加到 LLM 的输入中。</p>\n<h2 id=\"1-skills-的工作流程\"><a class=\"markdownIt-Anchor\" href=\"#1-skills-的工作流程\"></a> 1. Skills 的工作流程</h2>\n<p>Skills 的步骤包括：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">步骤</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Discovery</td>\n<td>发送请求时，加载每个可用 Skill 的名称和元数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Activation</td>\n<td>1. 通过语义相似性来匹配请求与描述<br>2. 请求与某个 Skill 的描述匹配时，激活该 Skill<br>3. 将完整的 <code>SKILL.md</code> 加载到上下文中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Execution</td>\n<td>按照 Skill 的说明执行，根据需要加载引用的文件或运行捆绑的脚本</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-skill-结构\"><a class=\"markdownIt-Anchor\" href=\"#2-skill-结构\"></a> 2. Skill 结构</h2>\n<p>Skill 可以看作是一个包含所有这些提示词信息的一个单元，其结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">skill-name/</span><br><span class=\"line\"> ├── SKILL.md          # Skill 的描述和元数据</span><br><span class=\"line\"> ├── scripts/          # 可选的脚本文件</span><br><span class=\"line\"> └── references/       # 可选的参考文件</span><br></pre></td></tr></table></figure>\n<p>对于 <code>SKILL.md</code> 文件，其内容结构如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">name: my-skill</span><br><span class=\"line\"><span class=\"section\">description: My personal workflow skill</span></span><br><span class=\"line\"><span class=\"section\">---</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># My Skill</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1.</span> Step one... Inferring certain segments...</span><br><span class=\"line\"><span class=\"bullet\">2.</span> Step two... Using some tools...</span><br><span class=\"line\"><span class=\"bullet\">3.</span> Step three... Concluding with...</span><br><span class=\"line\">etc.</span><br><span class=\"line\"></span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<p>考虑到 KV 缓存命中，可以让 Skill 固定一些上下文前缀，从而提升命中率。</p>\n<hr />\n<h1 id=\"参考文献\"><a class=\"markdownIt-Anchor\" href=\"#参考文献\"></a> 参考文献</h1>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV15eBLBfEAw/\">video: 【B站首推】Agentic RAG 才是未来！吊打传统 RAG！…</a></li>\n<li><a href=\"https://aibook.ren/archives/what-is-skills-overall\">web: 一文看懂什么是Agent技能（Skills），用来干什么的？怎么用它？</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1dz6oBWEWx/\">video: 什么是大模型Skill 10分钟弄懂</a></li>\n</ul>\n<hr />\n<p><a href=\"%E9%9A%8F%E7%AC%94%2FAI%20Agent-%E9%9D%A2%E5%90%91LLM%E7%9A%84%E6%99%BA%E8%83%BD%E4%BB%A3%E7%90%86\">&lt;返回 AI Agent 目录</a></p>\n","feature":false,"text":"有关 AI Agent 的检索工程知识和思考，包含 RAG、Skills 技术。...","permalink":"/post/随笔/AI Agent的检索工程","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"随笔-Agent","slug":"随笔-Agent","count":4,"path":"api/categories/随笔-Agent.json"}],"tags":[{"name":"LLM","slug":"LLM","count":4,"path":"api/tags/LLM.json"},{"name":"Agent","slug":"Agent","count":4,"path":"api/tags/Agent.json"},{"name":"Context Engineering","slug":"Context-Engineering","count":3,"path":"api/tags/Context-Engineering.json"},{"name":"RAG","slug":"RAG","count":1,"path":"api/tags/RAG.json"},{"name":"Skills","slug":"Skills","count":1,"path":"api/tags/Skills.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 一. 介绍</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF-rag\"><span class=\"toc-text\"> 二. 检索增强生成技术 RAG</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BC%A0%E7%BB%9F%E6%8E%A8%E7%90%86%E5%89%8D%E6%A3%80%E7%B4%A2-rag\"><span class=\"toc-text\"> 1. 传统推理前检索 RAG</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%8D%B3%E6%97%B6%E6%A3%80%E7%B4%A2-agentic-rag\"><span class=\"toc-text\"> 2. 即时检索 Agentic RAG</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%B7%B7%E5%90%88%E7%AD%96%E7%95%A5\"><span class=\"toc-text\"> 3. 混合策略</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89-skills-%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\"> 三. Skills 技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-skills-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\"> 1. Skills 的工作流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-skill-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\"> 2. Skill 结构</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"><span class=\"toc-text\"> 参考文献</span></a></li></ol>","author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"随笔-AI Agent的工具调用工程","uid":"21ea59c3cb5f2b5236c9677bdbbeba28","slug":"随笔/AI Agent的工具调用工程","date":"2026-02-02T11:47:09.000Z","updated":"2026-02-02T19:00:27.256Z","comments":true,"path":"api/articles/随笔/AI Agent的工具调用工程.json","keywords":null,"cover":"img/post/随笔/AI Agent的工具调用工程/cover.jpg","text":"有关 AI Agent 的工具调用工程知识和思考，包含 MCP 技术。...","permalink":"/post/随笔/AI Agent的工具调用工程","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"随笔-Agent","slug":"随笔-Agent","count":4,"path":"api/categories/随笔-Agent.json"}],"tags":[{"name":"LLM","slug":"LLM","count":4,"path":"api/tags/LLM.json"},{"name":"Agent","slug":"Agent","count":4,"path":"api/tags/Agent.json"},{"name":"Context Engineering","slug":"Context-Engineering","count":3,"path":"api/tags/Context-Engineering.json"},{"name":"Tool Calling","slug":"Tool-Calling","count":1,"path":"api/tags/Tool-Calling.json"},{"name":"Function Calling","slug":"Function-Calling","count":1,"path":"api/tags/Function-Calling.json"},{"name":"MCP","slug":"MCP","count":1,"path":"api/tags/MCP.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"feature":false},"next_post":{"title":"随笔-AI Agent的记忆工程","uid":"d4bf4e42fb0c5c829e26c963c245cb13","slug":"随笔/AI Agent的记忆工程","date":"2026-02-02T05:41:00.000Z","updated":"2026-02-02T18:52:53.009Z","comments":true,"path":"api/articles/随笔/AI Agent的记忆工程.json","keywords":null,"cover":"img/post/随笔/AI Agent的记忆工程/cover.png","text":"有关大语言模型长周期任务的记忆管理随笔。...","permalink":"/post/随笔/AI Agent的记忆工程","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"随笔-Agent","slug":"随笔-Agent","count":4,"path":"api/categories/随笔-Agent.json"}],"tags":[{"name":"LLM","slug":"LLM","count":4,"path":"api/tags/LLM.json"},{"name":"Agent","slug":"Agent","count":4,"path":"api/tags/Agent.json"},{"name":"Memory","slug":"Memory","count":1,"path":"api/tags/Memory.json"},{"name":"Short-Term Memory","slug":"Short-Term-Memory","count":1,"path":"api/tags/Short-Term-Memory.json"},{"name":"Long-Term Memory","slug":"Long-Term-Memory","count":1,"path":"api/tags/Long-Term-Memory.json"}],"author":{"name":"zExNocs","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"<p>一个喜欢摸鱼的人。<br>去码头整点薯条。</p>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/img/svg/github.svg","link":"https://github.com/zExNocs"},"bilibili":{"icon":"/img/svg/bilibili.svg","link":"https://space.bilibili.com/13423200"},"steam":{"icon":"/img/svg/steam.svg","link":"https://steamcommunity.com/id/zExNocs/"}}}},"feature":false}}