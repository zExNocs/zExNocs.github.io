[{"id":"dd909d4f3bf029c1efe5bae0e6ec00d1","title":"随笔-记录网友怪话","content":"←返回导航\n\n\n\n\n","slug":"随笔-记录网友怪话","date":"2024-05-25T14:52:15.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"ca919ca5c3402d033970c77af27cf3c5","title":"随笔-梗图","content":"←返回导航\n 娱乐向\n\n\n\n\n\n\n\n\n 提问向\n\n\n提问的艺术\n\n\n\n提问收费表\n\n\n\n","slug":"随笔-梗图","date":"2024-05-25T13:55:45.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"49266c0927eaad653ea21227e55d59fb","title":"LAC - Formal Languages and Automata Theory 形式语言与自动机理论","content":" 背景\n课程原名为Languages and Computation(语言与计算)，但是这很明显是一个比较笼统的名字。本课程的主要内容还是将有关形式语言与自动机理论的知识。\n关于自动机，早在学习算法竞赛的时候有学过AC自动机(Aho-Corasick automaton, 是字典树 + KMP算法 + 自动机的结合)的知识，但是并没有建立有关自动机的系统性概念。\n此外，在学习做游戏AI的时候，有接触过关于状态设计模式的概念，游戏AI是一个巨大的状态自动机，因此我也利用这个方法在我CPP课程的游戏里设计了敌人的AI，具体可以参考这个笔记: 简单游戏引擎开发笔记。\n 介绍\n本笔记主要分为下面几个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n","slug":"笔记-LAC-形式语言与自动机","date":"2024-05-25T10:53:20.000Z","categories_index":"笔记","tags_index":"Notes,Automata Theory,Formal Languages,Theory","author_index":"zExNocs"},{"id":"ca7a89ba385cdbc1ce7b55d4c88122bd","title":"AIM - Optimization 优化算法","content":" 背景\n课程原名为Artificial Intelligence Methods(人工智能方法)，但实际上内容都是有关一些优化算法的内容，相比如今环境下主流的大模型、神经网络还是相差甚远。因为部分优化算法中也具备一些学习能力（比如说遗传算法），因此也可以被视为一种弱人工智能。\n 介绍\n本笔记主要分为下面几个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n","slug":"笔记-AIM-优化算法","date":"2024-05-25T10:52:11.000Z","categories_index":"笔记","tags_index":"Algorithm,AI,Optimization","author_index":"zExNocs"},{"id":"8e94a57200662cea86ae71df183554b9","title":"ADE - Algorithms Data Structures and Efficiency 算法数据结构和效率","content":" ✒️背景\n早在一年前就知道了这个有关算法和数据结构的课程。作为一个退役OIer，之前有接触过关于这个课程的内容，比如堆、图论等，因此是对这个课程具有很大兴趣的。\n不过这个课程并不是集中于讲解算法和数据结构，而是着重于使用理论对算法效率的分析，比如说Big-Oh家族。学算法竞赛的时候只是经常听说过和使用过时间复杂度、空间复杂度，不过一直以来对它们的理解都停留在算法在时间和空间上对某一或多种变量/输入的增长程度上，可以说是对这一类知识处于一种一知半解的状态。\n建议使用右边的导航选择性地阅读。\n 🔖介绍\n本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。\n本笔记主要分为下面四个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n\n一. 算法效率的评估\n二. Big-Oh家族和理论\n三. Master定理\n四. 数据结构\n五. 算法\n\n 🔬一. 算法效率的评估\n如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 程序的运行时间 来评估测量算法效率。\n在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 (关于SPFA，它死了) 。\n由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。\n\n 方法一：Experiment 实验统计\n\n实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。具体步骤如下:\n\n写一个程序实施该算法\n使用不同的输入大小和输入信息运行程序\n记录实际运行时间\n绘制并使用统计学分析（如回归分析）\n\n在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注最差的情况，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。\n 缺点 &amp; 局限性\n\n必须用程序实现该算法，可能会很耗时。\n需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。\n效率的评估受到硬件/软件/语言环境的影响。\n\n\n 方法二：Theory 理论分析\n理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。\n跟实验统计一样，我通常指关注最差的情况。\n 特点\n\n具有一定的抽象性。\n能够独立于硬件/软件/语言环境来评估算法的效率。\n能够考虑所有可能的输入。\n\n 缺点 &amp; 局限性\n\n实施过程可能会比较困难，需要一定的知识基础。\n在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。\n\n 评估标准\n在实验统计中，我们往往使用 程序的运行时间 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：原始运算数量。\n 原始运算的定义\n原始运算(primitive operations)是算法执行的基本运算。\n在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将汇编代码、算数运算视作一个原始运算。\n注意，原始运算的定义不是固定的，在这个笔记中，我们将这些操作视作一个原始运算：\n\n\n\n描述\n伪代码样例\n\n\n\n\n变量赋值\na ← 0\n\n\n数组索引\na[10]\n\n\n变量比较\na == 10\n\n\n算数运算\na + 1\n\n\n函数调用\nfunction()\n\n\n函数返回\nreturn 0\n\n\n\n注意：\n\n在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。\n数组索引需要用到袁术运算是因为它需要在内存中进行索引。\n函数调用属于原始运算是因为它需要在内存中进行索引。\n在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。\n\n对于其他的运算，都可以拆分为这些原始运算：\n\n\n\n描述\n分析\n操作数\n伪代码样例\n\n\n\n\nfor循环，循环次数为n\n要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)\n1+n+2n = 3n+1\nfor i ← 1 to n do\n\n\nfor循环，循环次数为(n-1)\n要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)\n1+2(n-1)+2(n-1) = 4n-3\nfor i ← 1 to (n-1) do\n\n\nwhile循环，循环次数为n\n每次循环只需要判断即可\nn\nwhile i &gt; n\n\n\nwhile循环，循环次数为(n-1)\n每次循环都需要进行判断和减法\n2(n-1)\nwhile i &gt; (n-1)\n\n\nif then判断，then内部原始运算数为k\n一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)\n1 + k\nif … then …\n\n\n\n\n一个计算原始运算数的例子\n一个返回数组最大值的伪代码：\n123456Algorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)    if A[i] &gt; currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)  return currentMax         # 原始运算为1，函数返回\n综上所述，这个算法的原始运算总数为 2+(4n−3)+2(n−1)+2(n−1)+1=8n−42 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 = 8n - 42+(4n−3)+2(n−1)+2(n−1)+1=8n−4\n\n\n 二. 🏠Big-Oh家族和理论\n// TODO\n 三. 🏫Master定理\n// TODO\n 四. 🔒数据结构\n// TODO\n 五. 💻算法\n// TODO\n 📘Reference\n","slug":"笔记-ADE-算法数据结构和效率","date":"2024-05-25T00:42:20.000Z","categories_index":"笔记","tags_index":"Notes,Algorithm,Data Structure,Big Oh","author_index":"zExNocs"},{"id":"d681443dee58dcfb94dec12db90a9a0d","title":"随笔日记导航","content":" 随笔\n\n梗图\n记录网友怪话\n\n\n 日记\n","slug":"导航-随笔日记导航","date":"2024-05-25T00:15:32.000Z","categories_index":"导航","tags_index":"Diary,Essay","author_index":"zExNocs"},{"id":"c9fd788a84f48b02fed840451084249f","title":"笔记导航","content":" 按照年份分类\n Y3\n\nADE - 算法数据结构和效率 : 有关算法效率分析的课题笔记，包括Big-Oh家族、Master定理和部分算法与数据结构的算法分析。\n\n","slug":"导航-笔记导航","date":"2024-05-24T21:25:57.000Z","categories_index":"导航","tags_index":"Notes","author_index":"zExNocs"},{"id":"625e3e920d4d18f0b54366f772b38b35","title":"语言学习导航","content":"","slug":"导航-语言学习导航","date":"2024-05-24T17:44:53.000Z","categories_index":"导航","tags_index":"Languaue","author_index":"zExNocs"},{"id":"f2a68e25ffce8d6b8f475f30117ea7f4","title":"算法和数据结构导航","content":" 算法\n 数据结构\n","slug":"导航-算法和数据结构导航","date":"2024-05-24T17:43:22.000Z","categories_index":"导航","tags_index":"Algorithm,Data Structure","author_index":"zExNocs"}]