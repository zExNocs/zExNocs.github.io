[{"id":"43a3c4ed23195bb672e40c41942223f5","title":"随笔-如何提交文章到VoidGameSpace上","content":"本文章仅适用于VoidGameSpace论坛及其GitHub库。\n该教程目前仅适用于Windows系统。\n官方博客传送面板\n 如何使用github进行提交\n 一. 确认Git安装\nGit下载地址: Link\n测试Git：打开 cmd 或者 PowerShell，输入 git -v 可以查看到当前Git的版本。\n 二. 配置Git设置和SSH\n\n使用下面两个指令配置Git全局设置：\n\n12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot;\n\n配置ssh设置：可以参考这个文章\n\n\n使用 ssh-keygen -t rsa -C &quot;你的邮箱&quot;，一路回车生成SSH。\n找到文件C:\\User\\用户名\\.ssh\\id_rsa.pub，使用记事本打开并复制里面的内容。\n打开GitHub在Settings界面左边找到SSH and GPG keys进入。\n点击 New SSH key，在title中填入合适的标题，在SSH中填入刚刚复制的内容。\n本地指令输入 ssh -T git@github.com 验证是否配置成功。\n\n 三. fork库到自己的库中\n打开 GitHub库 网页，点击右上角 Fork 按钮，复制该库到自己的库中。\n选择owner为自己的账户，Repository name可以设置为默认GameDevWebsite。\nDescription用来描述这个库，可以随便写一些，例如：VoidGameSpace论坛的Fork库。\n点击 Create fork 按钮。\n 四. clone库到本地\n进入自己的库中找到刚刚fork的GameDevWebsite库，一般为 https://github.com/用户名/GameDevWebsite\n找到 &lt;&gt; Code 绿色按钮，在本地中使用 PowerShell 打开想要部署的位置 or 在部署的位置中右键选择在终端打开 or 使用cmd cd 到要部署的文件夹，使用下面三种方式之一克隆库到本地\n\n使用HTTPS，复制web URL，输入git clone 复制的URL部署。这个方法需要你在终端登录到Git中。\n使用SSH，复制SSH key，输入git clone 复制的SSH_key部署。\n点击Download ZIP，下载压缩包到要部署的文件夹并解压。\n\n 五. 编写自己的文档\n在部署的项目目录GameDevWebsite中，路径source\\_posts\\创建自己的文件夹，并在文件夹中创建.md文件，参考GitHub库中元数据说明，编写自己的文章。\n另外，markdown的编写可以参考官方文档：Link\n 六. 提交文档到自己fork的库中\n使用 PowerShell 打开项目目录GameDevWebsite，或者在目录中右键点击在终端打开，或者使用cmd cd到目录。\n\n创建自己的分支(可选，新手建议直接修改main分支)：使用 git checkout -b 分支名 创建并切换到新的分支。(分支的作用是保证main分支的干净，一般只有最终版本才会合并到main分支)。如果你已经创建过分支，就不需要再创建该分支了。\n添加所有文件到暂存区： git add .\n提交添加的文件： git commit -m &quot;修改描述&quot;。为了养成好习惯，修改描述要有一定的准则。例如你修改文档可以写 &quot;docs(你的名字): 添加了xxx文章&quot;。具体准则可以自行搜索学习一下。\npush库：如果你使用的是新建的分支，使用git push origin 分支名 将新分支push到库中。如果你使用的是main分支或者是已经创建的库，那么使用 git push 将提交的内容push到库中。\n\n 七. 拉取申请\n找到自己fork的库，点击左上方 Pull requests按钮，进入页面点击右上方New pull request按钮。左边是合并的基库，右边是申请合并的库。在右边申请的库中选择自己的库和分支(如果没有创建分支就选择main)，然后填写一些申请描述即可。\n 八. 等待审核\n建议留言压力v佬(bushi)\n","slug":"随笔/随笔-如何提交文章到VoidGameSpace上","date":"2024-05-28T14:06:44.000Z","categories_index":"随笔","tags_index":"Hexo,VoidGameSpace","author_index":"zExNocs"},{"id":"ed2691e46b19986acffbcbe7e26041d1","title":"随笔-让Aurora支持KaTeX和Emoji","content":" ✒️背景\n最早接触markdown是在洛谷的个人博客时使用的。其中有一个功能我特别喜欢用，就是用$$符号展示出的公式，类似于这样：f(x)=eΔkTf(x)=e^{\\frac{\\Delta}{kT}}f(x)=ekTΔ​，以至于以后只要用到有关字母公式的地方就会喜欢性地打出$$。\n但是我在使用Aurora的时候，发现它并不能直接使用$$公式，研究发现是Hexo默认的markdown渲染器不支持KaTeX，故有此文章来研究如何让Hexo支持。\n 🔖内容\nHexo的markdown渲染器有很多种：Hexo多种Markdown渲染器对比分析。\nHexo自带的markdown渲染器不支持KaTeX，也不支持emoji。而网络上常见的pandoc在部署到Aurora时会出现很多问题。这里我使用的是markdown-it-plus，它原生就支持emoji和KaTeX插件。具体步骤如下：\n\n卸载原生渲染器 npm un hexo-renderer-marked --save\n安装新渲染器 npm i hexo-renderer-markdown-it-plus --save\n添加选项：在根目录下_config.yml添加以下字段：\n\n12345678910markdown_it_plus:    highlight: true    html: true    xhtmlOut: true    breaks: true    langPrefix:    linkify: true    typographer:    quotes: “”‘’    pre_class: highlight\n\n添加css：在根目录下_config.aurora.yml找到injects字段，并添加css，参考如下：\n\n12345678#! ---------------------------------------------------------------#! Injections#! @docs https://aurora.tridiamond.tech/guide/site-meta.html#custom-meta#! ---------------------------------------------------------------injects:  scripts:  css:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css&quot;&gt;\n\n清理并重新生成Hexo hexo clean &amp; hexo g -d\n\n 📘Reference\n\nHexo多种Markdown渲染器对比分析: https://zsyyblog.com/b73ceb85.html\nhexo-renderer-markdown-it-plus官方文档：https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus\nAurora官方插件文档：https://aurora.tridiamond.tech/cn/configs/site-meta.html\n\n","slug":"随笔/随笔-让Hexo支持KaTeX和Emoji","date":"2024-05-27T13:05:16.000Z","categories_index":"随笔","tags_index":"Hexo","author_index":"zExNocs"},{"id":"dd909d4f3bf029c1efe5bae0e6ec00d1","title":"随笔-记录网友怪话","content":"←返回导航\n\n\n\n\n","slug":"随笔/随笔-记录网友怪话","date":"2024-05-25T14:52:15.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"ca919ca5c3402d033970c77af27cf3c5","title":"随笔-梗图","content":"←返回导航\n 娱乐向\n\n\n\n\n\n\n\n\n 提问向\n\n\n提问的艺术\n\n\n\n提问收费表\n\n\n\n","slug":"随笔/随笔-梗图","date":"2024-05-25T13:55:45.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"49266c0927eaad653ea21227e55d59fb","title":"LAC - Formal Languages and Automata Theory 形式语言与自动机理论","content":" 背景\n课程原名为Languages and Computation(语言与计算)，但是这很明显是一个比较笼统的名字。本课程的主要内容还是将有关形式语言与自动机理论的知识。\n关于自动机，早在学习算法竞赛的时候有学过AC自动机(Aho-Corasick automaton, 是字典树 + KMP算法 + 自动机的结合)的知识，但是并没有建立有关自动机的系统性概念。\n此外，在学习做游戏AI的时候，有接触过关于状态设计模式的概念，游戏AI是一个巨大的状态自动机，因此我也利用这个方法在我CPP课程的游戏里设计了敌人的AI，具体可以参考这个笔记: 简单游戏引擎开发笔记。\n 介绍\n本笔记主要分为下面几个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n","slug":"笔记/笔记-LAC-形式语言与自动机","date":"2024-05-25T10:53:20.000Z","categories_index":"笔记","tags_index":"Notes,Automata Theory,Formal Languages,Theory","author_index":"zExNocs"},{"id":"ca7a89ba385cdbc1ce7b55d4c88122bd","title":"AIM - Optimization 优化算法","content":" 背景\n课程原名为Artificial Intelligence Methods(人工智能方法)，但实际上内容都是有关一些优化算法的内容，相比如今环境下主流的大模型、神经网络还是相差甚远。因为部分优化算法中也具备一些学习能力（比如说遗传算法），因此也可以被视为一种弱人工智能。\n 介绍\n本笔记主要分为下面几个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n","slug":"笔记/笔记-AIM-优化算法","date":"2024-05-25T10:52:11.000Z","categories_index":"笔记","tags_index":"Algorithm,AI,Optimization","author_index":"zExNocs"},{"id":"8e94a57200662cea86ae71df183554b9","title":"ADE - Algorithms Data Structures and Efficiency 算法数据结构和效率","content":" ✒️背景\n早在一年前就知道了这个有关算法和数据结构的课程。作为一个退役OIer，之前有接触过关于这个课程的内容，比如堆、图论等，因此是对这个课程具有很大兴趣的。\n不过这个课程并不是集中于讲解算法和数据结构，而是着重于使用理论对算法效率的分析，比如Big-Oh表示法。学算法竞赛的时候只是经常听说过和使用过时间复杂度、空间复杂度，不过一直以来对它们的理解都停留在算法在时间和空间上对某一或多种变量/输入的增长程度上，可以说是对这一类知识处于一种一知半解的状态。\n建议使用右边的导航选择性地阅读。\n 🔖介绍\n本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。\n本笔记主要分为下面四个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n\n一. 算法效率的评估\n二. Big-Oh表示法和其家族\n三. Master定理\n四. 数据结构\n五. 算法\n\n 一. 🔬算法效率的评估\n如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 程序的运行时间 来评估测量算法效率。\n在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 (关于SPFA，它死了) 。\n由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。\n\n 方法一：Experiment 实验统计\n\n\n\n\n\n\n\n\n\n\n实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。\n具体步骤如下:\n\n写一个程序实施该算法\n使用不同的输入大小和输入信息运行程序\n记录实际运行时间\n绘制并使用统计学分析（如回归分析）\n\n在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注最差的情况，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。\n 缺点 &amp; 局限性\n\n必须用程序实现该算法，可能会很耗时。\n需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。\n效率的评估受到硬件/软件/语言环境的影响。\n\n\n 方法二：Theory 理论分析\n\n\n\n\n\n\n\n\n\n理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。\n跟实验统计一样，我通常指关注最差的情况。\n 特点\n\n具有一定的抽象性。\n能够独立于硬件/软件/语言环境来评估算法的效率。\n能够考虑所有可能的输入。\n\n 缺点 &amp; 局限性\n\n实施过程可能会比较困难，需要一定的知识基础。\n在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。\n\n 评估标准\n在实验统计中，我们往往使用 程序的运行时间 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：原始运算数量。\n 原始运算的定义\n\n\n\n\n\n\n\n\n\n原始运算(primitive operations)是算法执行的基本运算。\n在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将汇编代码、算数运算视作一个原始运算。\n注意，原始运算的定义不是固定的，下面有更具体的说明。在这个笔记中，我们将这些操作视作一个原始运算：\n\n\n\n描述\n伪代码样例\n\n\n\n\n变量赋值\na ← 0\n\n\n数组索引\na[10]\n\n\n变量比较\na == 10\n\n\n算数运算\na + 1\n\n\n函数调用\nfunction()\n\n\n函数返回\nreturn 0\n\n\n\n注意：\n\n在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。\n数组索引需要用到袁术运算是因为它需要在内存中进行索引。\n函数调用属于原始运算是因为它需要在内存中进行索引。\n在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。\n\n对于其他的运算，都可以拆分为这些原始运算：\n\n\n\n描述\n分析\n操作数\n伪代码样例\n\n\n\n\nfor循环，循环次数为nnn\n要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)\n1+n+2n=3n+11+n+2n = 3n+11+n+2n=3n+1\nfor i ← 1 to n do\n\n\nfor循环，循环次数为(n−1)(n-1)(n−1)\n要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)\n1+2(n−1)+2(n−1)=4n−31+2(n-1)+2(n-1) = 4n-31+2(n−1)+2(n−1)=4n−3\nfor i ← 1 to (n-1) do\n\n\nwhile循环，循环次数为nnn\n每次循环只需要判断即可\nnnn\nwhile i &gt; n\n\n\nwhile循环，循环次数为(n−1)(n-1)(n−1)\n每次循环都需要进行判断和减法\n2(n−1)2(n-1)2(n−1)\nwhile i &gt; (n-1)\n\n\nif then判断，then内部原始运算数为kkk\n一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)\n1+k1 + k1+k\nif ... then ...\n\n\n\n\n一个计算原始运算数的例子: arrayMax(A, n)\n一个返回数组最大值arrayMax(A, n)的伪代码：\n123456Algorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)    if A[i] &gt; currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)  return currentMax         # 原始运算为1，函数返回\n综上所述，这个算法的原始运算总数为 2+(4n−3)+2(n−1)+2(n−1)+1=8n−42 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 = 8n - 42+(4n−3)+2(n−1)+2(n−1)+1=8n−4\n\n\n原始运算的个数并不是固定的，例如在计算操作 c←A[i]c \\leftarrow A[i]c←A[i] 中，你也可以认为是444个原始运算：\n\n获取AAA数组的指针储存在寄存器中。\n获取iii储存在寄存器中。\n计算A+iA + iA+i作为A[i]A[i]A[i]的指针储存在寄存器中。\n复制变量ccc的数值写在A+iA + iA+i指针的内存中。\n\n当然在这个笔记中，你也可以认为只有222个原始运算：\n\n根据iii索引获取A[i]A[i]A[i]数组位置 (数组索引)。\n将变量ccc的数值赋值给A[i]A[i]A[i] (变量赋值)。\n\n但是无论是444还是222，这个操作永远不可能会是2n2n2n，即它的增长率永远不可能会超过常数级(增长率的定义在下面)。\n\n\n\n\n\n\n\n\n\n原始运算的个数只与算法的效率有关，与正确性无关。\n 使用原始运算估算运行时间\n增长率(Growth Rate)指的是函数的因变量随着自变量的增加而增长的速率。\n\n\n\n\n\n\n\n\n\n对于算法来说，假设它的最差情况的运行时间为T(n)T(n)T(n)，那么T(n)T(n)T(n)的增长率是该算法的固有属性，是不受硬件/软件环境影响的。\n我们可以使用原始运算来估算运行时间，假设：\n\n原始运算的个数为P(n)P(n)P(n)。\n最快的原始运算所需要的时间为aaa，是一个常数。\n最慢的原始运算所需要的时间为bbb，是一个常数。\n\n可以得出：aP(n)≤T(n)≤bP(n)aP(n) \\leq T(n) \\leq bP(n)aP(n)≤T(n)≤bP(n)\n由于a和b都是常数，那么我们认为T(n)T(n)T(n)和P(n)P(n)P(n)具有相同的增长率。很明显T(n)T(n)T(n)和P(n)P(n)P(n)的导数肯定是不同的，因此增长率并不等同于导数。\n但是增长率有一种只可意会不可言传的感觉：这种增长率具体形式是什么样的？如何定义哪两个函数具有相同的增长率？那么就需要用到我们的Big-Oh表示法了。\n 二. 🏠Big-Oh表示法和其家族\n 基本知识\n我们需要一种函数分类(Classification of Functions)来通过缩放的行为将函数分组在一起，同一组的函数具有这样的相似性：\n\n删除不必要的细节。\n相对快速、简单。\n处理运行时可能会发生的“奇怪的”函数(例如分段函数)。\n在数学上拥有明确的定义。\n\n其中一种最佳的方法是使用Big-Oh表示法和其家族(Big-Oh notation and family)：\n\nOOO: Big-Oh\nΩ\\OmegaΩ: Big-Omega\nΘ\\ThetaΘ: Big-Theta\nooo: little-oh\nω\\omegaω: little-omega\n\n本笔记只集中于前四个的定义和Big-Oh的相关理论。\n\n Big-Oh：O(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is O(g(n))f(n) \\ is \\ O(g(n))f(n) is O(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∃c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ \\leq } \\color{black} c \\ g(n)\n∃c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣≤c g(n)\n注意:\n\n量词顺序是 ∃ ∃ ∀\\exist \\ \\exist \\ \\forall∃ ∃ ∀\nccc 和 n0n_0n0​必须是常数，不能随着nnn变化。不然这是没有意义的。\n注意符号&gt;,≥,≤&gt;,\\geq,\\leq&gt;,≥,≤的区分。相比之下是比较严格的(例如，n0n_0n0​ 不能等于 000, nnn 可以等于 n0n_0n0​)。\n\n此外，Big-Oh可以会被定义为：\nlim sup⁡n→∞f(n)g(n)&lt;∞\\limsup_{n\\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty \nn→∞limsup​g(n)f(n)​&lt;∞\n\n\n\n\n\n\n\n\n\nBig-Oh只规定了f(n)f(n)f(n)的增长率的上限(upper bound on the growth rate of the function)。\n 特点\n\nBig-Oh不关注算法或者是“算法最差的运行时间”，而是只关注于函数。也就是说它并不是对算法进行分类，而是对函数进行分类。\n一般f(n)f(n)f(n)表示运行时间，nnn表示输入的个数，所以Big-Oh中描述的函数一般为 f:N+→R+f: \\mathbb{N^+} \\to \\mathbb{R^+}f:N+→R+，g(n)g(n)g(n)也类似。\nBig-Oh只规定了f(n)f(n)f(n)的增长率的上限，也就是说，当nnn足够大时，f(n)f(n)f(n)的增长速率不大于g(n)g(n)g(n)。\nBig-Oh中g(n)g(n)g(n)的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于f(n)=1f(n) = 1f(n)=1可以是O(1)O(1)O(1)，但也可以是O(n)O(n)O(n)。因此g(n)g(n)g(n)的增长率越小越能反应出f(x)f(x)f(x)的增长率。\n\n 性质\nBig-Oh作为一个二元关系(binary relation)，拥有以下性质：\n\nBig-Oh具有自反性(Reflexive, e.g. xRxx R xxRx)，即 f(n)f(n)f(n) 是 O(f(n))O(f(n))O(f(n))。\nBig-Oh不具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)，例如 f(n)=1f(n) = 1f(n)=1 是 O(n)O(n)O(n)，但是 f(n)=nf(n) = nf(n)=n 不是 O(1)O(1)O(1)。\nBig-Oh具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。即如果 ∀n≥n1,f(n)≤c1g(n)\\forall n \\geq n_1, f(n) \\leq c_1g(n)∀n≥n1​,f(n)≤c1​g(n)，且∀n≥n2,g(n)≤c2h(n)\\forall n \\geq n_2, g(n) \\leq c_2h(n)∀n≥n2​,g(n)≤c2​h(n)，那么总有 ∀n≥n3,f(n)≤c1c2h(n),n3=max⁡(n1,n2)\\forall n \\geq n_3, f(n) \\leq c_1c_2h(n), n_3=\\max(n_1,n_2)∀n≥n3​,f(n)≤c1​c2​h(n),n3​=max(n1​,n2​)。\n\n综上所述，Big-Oh具有自反性和传递性，因此Big-Oh更像是⊂,∈,≤\\subset, \\in, \\leq⊂,∈,≤,而不是===，因此有一种表示方法是将Big-Oh视作集合，使用n∈O(n)n \\in O(n)n∈O(n)。此时也有会 O(lower_order)⊂O(heigher_order)O(lower\\_ order) \\subset O(heigher\\_ order)O(lower_order)⊂O(heigher_order)。\n此外，也有一种说法是使用f(n)=O(n)f(n) = O(n)f(n)=O(n)，其中等于号是一种单向的等于。但是本笔记中更偏向于使用“是”或者“is”来表示。\n 推论 &amp; 方法\n\n推论1：存在三个函数f(n)f(n)f(n), g(n)g(n)g(n), p(n)p(n)p(n)和正数k,b∈N+k, b\\in \\mathbb{N^+}k,b∈N+，如果f(n)f(n)f(n)是O(g(n))O(g(n))O(g(n))，且f(n)=k p(n)+bf(n)=k\\ p(n) + bf(n)=k p(n)+b，那么有p(n)p(n)p(n)是O(g(n))O(g(n))O(g(n))。\n\n\n证明推论1\n假设有c0&gt;0,n0&gt;0c_0 &gt; 0, n_0 &gt; 0c0​&gt;0,n0​&gt;0，对于n1≥n0n_1 \\geq n_0n1​≥n0​，有：\nf(n1)≤c0 g(n1)f(n_1) \\leq c_0 \\ g(n_1)f(n1​)≤c0​ g(n1​)，那么有：\nk p(n1)+b≤c0 g(n1)k\\ p(n_1) + b \\leq c_0 \\ g(n_1)k p(n1​)+b≤c0​ g(n1​)，整理得：\np(n1)≤c0kg(n1)−bkp(n_1) \\leq \\frac{c_0}{k}g(n_1) - \\frac{b}{k}p(n1​)≤kc0​​g(n1​)−kb​\n当n足够大时候，假设此时n1≥n2n_1 \\geq n_2n1​≥n2​，有 cg(n1)≥2bcg(n_1) \\geq 2bcg(n1​)≥2b\n从而有 p(n1)≤c02kg(n1)p(n_1) \\leq \\frac{c_0}{2k}g(n_1)p(n1​)≤2kc0​​g(n1​)\n设 c1=c2k&gt;0c_1=\\frac{c}{2k}&gt;0c1​=2kc​&gt;0，我们得到：\np(n1)≤c1 g(n1)p(n_1) \\leq c_1\\ g(n_1)p(n1​)≤c1​ g(n1​)，即\n存在 c1c_1c1​，n2n_2n2​使得 ∀n&gt;n2,p(n)≤c1 g(n)\\forall n &gt; n_2, p(n) \\leq c_1\\ g(n)∀n&gt;n2​,p(n)≤c1​ g(n)\n因此p(n)p(n)p(n)是O(g(n))O(g(n))O(g(n))。\n\n\n\n推论2 （乘法）：如果f1(n)f_1(n)f1​(n) 是 O(g1(n))O(g_1(n))O(g1​(n)), f2(n)f_2(n)f2​(n) 是 O(g2(n))O(g_2(n))O(g2​(n))，那么 f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 O(g1(n)g2(n))O(g_1(n)g_2(n))O(g1​(n)g2​(n))。\n\n\n证明推论2\n∵f1(n)∵ f_1(n)∵f1​(n) 是 O(g1(n))O(g_1(n))O(g1​(n))\n∴f1(n)≤c1 g1(n)  for all  n≥n1∴ f_1(n) \\leq c_1\\ g_1(n)\\ \\text{ for all } \\ n \\geq n_1∴f1​(n)≤c1​ g1​(n)  for all  n≥n1​\n∵f2(n)∵ f_2(n)∵f2​(n) 是 O(g2(n))O(g_2(n))O(g2​(n))\n∴f2(n)≤c2 g2(n)  for all  n≥n2∴ f_2(n) \\leq c_2\\ g_2(n)\\ \\text{ for all } \\ n \\geq n_2∴f2​(n)≤c2​ g2​(n)  for all  n≥n2​\n∵f1(n),f2(n),g1(n),g2(n)≥0∵ f_1(n), f_2(n), g_1(n), g_2(n) \\geq 0∵f1​(n),f2​(n),g1​(n),g2​(n)≥0\n那么有 n0=max⁡(n1,n2)n_0 = \\max(n_1, n_2)n0​=max(n1​,n2​)\nf1(n)f2(n)≤c1c2g1(n)g2(n)  for all  n≥n0f_1(n)f_2(n) \\leq c_1c_2g_1(n)g_2(n) \\ \\text{ for all } \\ n \\geq n_0f1​(n)f2​(n)≤c1​c2​g1​(n)g2​(n)  for all  n≥n0​\n因此f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 O(g1(n)g2(n))O(g_1(n)g_2(n))O(g1​(n)g2​(n))\n\n\n\n推论3 （加法）：如果 f(n)=1+h(n)f(n) = 1 + h(n)f(n)=1+h(n)，且当n→∞n \\to \\inftyn→∞ 时 h(n)→0h(n) \\to 0h(n)→0，那么 f(n)f(n)f(n) 是 O(1)O(1)O(1)。\n\n\n证明推论3\n∵∵∵ 当n→∞n \\to \\inftyn→∞ 时 h(n)→0h(n) \\to 0h(n)→0\n∴∴∴ ∃n0&gt;0, ∀n≥n0,h(n)≤1\\exist n_0 &gt; 0,\\ \\forall n \\geq n_0, h(n) \\leq 1∃n0​&gt;0, ∀n≥n0​,h(n)≤1\n∴∴∴ ∃n0&gt;0, ∀n≥n0,f(n)≤2\\exist n_0 &gt; 0,\\ \\forall n \\geq n_0, f(n) \\leq 2∃n0​&gt;0, ∀n≥n0​,f(n)≤2\n∴∴∴ f(n)f(n)f(n) 是 O(1)O(1)O(1) 取 c=2,n0=n1c = 2, n_0 = n_1c=2,n0​=n1​ 且 h(n1)&lt;=1h(n_1) &lt;= 1h(n1​)&lt;=1\n\n\n一些常用的 h(n)h(n)h(n):\n\nn2/2nn^2/2^nn2/2n\nn2000/2n100n^{2000}/2^{\\frac{n}{100}}n2000/2100n​\n(log(n))100/n0.1(log(n))^{100} / n^{0.1}(log(n))100/n0.1\n\n综合推论2和3，可知如果 f(n)=g(n)(1+h(n))f(n) = g(n)(1 + h(n))f(n)=g(n)(1+h(n))，且当n→∞n \\to \\inftyn→∞ 时 h(n)→0h(n) \\to 0h(n)→0，那么 f(n)f(n)f(n) 是 O(g(n))O(g(n))O(g(n))。\n因此我们总结了获取Big-Oh的通用方法 —— 删除规则(Drop Rules)：\n\n删除低阶(lower-order)项 (根据推论2, 3)。阶排名可以看下面常用表示表。\n删除常数(constant)项系数 (根据推论1,总能找到 kkk 使得系数变成 111)。\n\n 例子\n\n证明arrayMax(A, n)是 O(n)O(n)O(n) 的例子 (定义)\n由上述计算原始运算数的例子可知，arrayMax(A, n)的原始运算记数为 f(n)=8n−4f(n) = 8n - 4f(n)=8n−4\n设g(n)=ng(n) = ng(n)=n，因此需要求证 ∃c&gt;0,∃n0&gt;0,∀n≥n0,f(n)≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​,f(n)≤c g(n)，整理可得：\n{n≤4c−8c&gt;8n≥4c−8c&lt;8−4≤0c=8\\begin{cases}\nn \\leq \\frac{4}{c - 8} &amp; c &gt; 8 \\\\\nn \\geq \\frac{4}{c - 8} &amp; c &lt; 8 \\\\\n-4 \\leq 0 &amp; c = 8\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​n≤c−84​n≥c−84​−4≤0​c&gt;8c&lt;8c=8​\n由于我们规定是 ∀n≥n0\\forall n \\geq n_0∀n≥n0​，因此我们只能取 n≥8n \\geq 8n≥8。\n当我们取 n=8n = 8n=8时，很明显任意n0&gt;0n_0 &gt; 0n0​&gt;0都可以证明成立。此时我们可以取 n0=1n_0 = 1n0​=1。\n当我们取 n&gt;8n &gt; 8n&gt;8时，很明显任意n0&gt;4c−8n_0 &gt; \\frac{4}{c - 8}n0​&gt;c−84​都可以证明成立。此时我们可以取 n0=4c−8n_0 = \\frac{4}{c - 8}n0​=c−84​。\n实际上，上述情况只需要求出一组(c,n0)(c,n_0)(c,n0​)即可，因此我们可以直接取c=8,n0=1c = 8, n_0 = 1c=8,n0​=1。不过这里给出了一种选取(c,n0)(c,n_0)(c,n0​)的具体方法。\n因此arrayMax(A, n)的时间复杂度是 O(n)O(n)O(n)。\n\n\n\n对于分段函数Big-Oh的证明 (定义)\n如何计算下面函数的Big-Oh:\nf(n)={nif n is even1if n is oddf(n) = \n\\begin{cases}\nn &amp; \\text{if } n \\text{ is even} \\\\\n1 &amp; \\text{if } n \\text{ is odd}\n\\end{cases}\nf(n)={n1​if n is evenif n is odd​\n因为Big-Oh是规定的函数增长率的上限，因此我们应该取增长率最大的函数，即f(n)=nf(n) = nf(n)=n，此时当c=1,n0=1c = 1, n_0 = 1c=1,n0​=1可以证明出f(n)f(n)f(n)是O(n)O(n)O(n)，而无法证明出f(n)f(n)f(n)是O(1)O(1)O(1)。\n\n\n\n求 f(n)=n2+nf_(n) = n^2 + nf(​n)=n2+n 的Big-Oh (定理2, 3)\nf(n)=n2+n=n2(1+1n)f(n) = n^2 + n = n^2(1 + \\frac{1}{n})f(n)=n2+n=n2(1+n1​)\n因为自反性，n2n^2n2 是 O(n2)O(n^2)O(n2)。\n因为当n→∞n \\to \\inftyn→∞ 时 1n→0\\frac{1}{n} \\to 0n1​→0，根据推理3可知 1+1n1 + \\frac{1}{n}1+n1​ 是 O(1)O(1)O(1)。\n因此根据推理2，f(n)f(n)f(n) 是 O(n2∗1)=O(n2)O(n^2 * 1) = O(n^2)O(n2∗1)=O(n2)\n\n\n\n求 f(n)=5n4+3n3f_(n) = 5n^4 + 3n^3f(​n)=5n4+3n3 的Big-Oh (删除规则)\n\n删除低阶3n3^n3n，因此f(n)f(n)f(n) 是 O(5n4)O(5n^4)O(5n4)\n删除常数555，因此f(n)f(n)f(n) 是 O(n4)O(n^4)O(n4)\n\n\n\n Big-Oh公约\n遵循这个公约可以更好地去分析算法以及给出最大的信息。\n\n使用最小且正确的增长率函数表示Big-Oh。例如说 2n2n2n 是 O(n)O(n)O(n) 而不是 O(n2)O(n^2)O(n2)，尽管后者也是正确的。\n使用最简的函数表示Big-Oh。例如说 2n2n2n 是 O(n)O(n)O(n) 而不是 O(2n)O(2n)O(2n)。\n\n\n Big-Omega：Ω(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is Ω(g(n))f(n) \\ is \\ \\Omega (g(n))f(n) is Ω(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∃c&gt;0,∃n0&gt;0,∀n≥n0:f(n)≥c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : f(n) \\color{red} \\boldsymbol{ \\geq } \\color{black} c \\ g(n)\n∃c&gt;0,∃n0​&gt;0,∀n≥n0​:f(n)≥c g(n)\n注意：\n\n量词顺序是 ∃ ∃ ∀\\exist \\ \\exist \\ \\forall∃ ∃ ∀。\n与Big-Oh不同，最后的符号是 ≥\\geq≥ 而不是 ≤\\leq≤。\n\n此外，Big-Omega可以会被定义为：\nlim inf⁡n→∞f(n)g(n)&gt;0\\liminf_{n\\to \\infty} \\frac{f(n)}{g(n)} &gt; 0 \nn→∞liminf​g(n)f(n)​&gt;0\n 特点\n\nBig-Omega规定了f(n)f(n)f(n)的增长率的下限，也就是说，当nnn足够大时，f(n)f(n)f(n)的增长速率不小于g(n)g(n)g(n)。\nBig-Omega中g(n)g(n)g(n)的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于f(n)=n3−nf(n) = n^3 - nf(n)=n3−n 可以是 Ω(n3)\\Omega(n^3)Ω(n3)，但也可以是 Ω(n2)\\Omega(n^2)Ω(n2)。因此g(n)g(n)g(n)的增长率越大越能说明f(n)f(n)f(n)的增长率。\n一般可以用来描述算法的最佳情况。\n\n 性质\n类似于Big-Oh，Big-Omega作为一个二元关系拥有下面的性质：\n\nBig-Omega具有自反性(Reflexive, e.g. xRxx R xxRx)。\nBig-Omega不具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)。\nBig-Omega具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。\n\nBig-Omega更像是 ≥\\geq≥。\n 推论 &amp; 方法\n\n推论1：f(n) is O(g(n))  ⟺  g(n) is Ω(f(n))f(n) \\text{ is } O(g(n))\\iff g(n) \\text{ is } \\Omega(f(n))f(n) is O(g(n))⟺g(n) is Ω(f(n))\n推论2 （乘法）：如果f1(n)f_1(n)f1​(n) 是 Ω(g1(n))\\Omega(g_1(n))Ω(g1​(n)), f2(n)f_2(n)f2​(n) 是 Ω(g2(n))\\Omega(g_2(n))Ω(g2​(n))，那么 f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 Ω(g1(n)g2(n))\\Omega(g_1(n)g_2(n))Ω(g1​(n)g2​(n))。\n\n删除规则依然适用于Big-Omega，但是注意删除法则跟Big-Oh一样是删除低阶函数而不是删除高阶函数。\n例如 f(n)=n3−nf(n) = n^3 - nf(n)=n3−n中，应该删除的是nnn。找到n3n^3n3后我们就可以找比n3n^3n3阶级低的函数来代替。\n\n Big-Theta：θ(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is Θ(g(n))f(n) \\ is \\ \\Theta (g(n))f(n) is Θ(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∃c′&gt;0,∃c′′&gt;0,∃n0&gt;0,∀n≥n0:c′ g(n)≤f(n)≤c′′ g(n)\\exist c&#x27; &gt; 0, \\exist c&#x27;&#x27;&gt;0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : c&#x27;\\ g(n) \\leq f(n) \\leq c&#x27;&#x27; \\ g(n)\n∃c′&gt;0,∃c′′&gt;0,∃n0​&gt;0,∀n≥n0​:c′ g(n)≤f(n)≤c′′ g(n)\n此外，Big-Theta可以被定义为：\n\n\n\n\n\n\n\n\n\nf(n) is Θ(g(n))  ⟺  f(n) is O(g(n)) and f(n) is Ω(g(n))f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } f(n) \\text{ is } \\Omega(g(n))\nf(n) is Θ(g(n))⟺f(n) is O(g(n)) and f(n) is Ω(g(n))\nf(n) is Θ(g(n))  ⟺  f(n) is O(g(n)) and g(n) is O(f(n))f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } g(n) \\text{ is } O(f(n))\nf(n) is Θ(g(n))⟺f(n) is O(g(n)) and g(n) is O(f(n))\n 性质\nBig-Theta作为一个二元关系拥有下面的性质：\n\nBig-Theta具有自反性(Reflexive, e.g. xRxx R xxRx)。\nBig-Theta具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)：如果 f(n)f(n)f(n) 是 Θ(g(n))\\Theta(g(n))Θ(g(n))，那么 g(n)g(n)g(n) 是 Θ(f(n))\\Theta(f(n))Θ(f(n))。可以根据Big-Theta的第二定义和Big-Omega的推论1得出。\nBig-Theta具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。\n\nBig-Theta更像是 ≈\\approx≈。\n\n little-oh：o(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is o(g(n))f(n) \\ is \\ o(g(n))f(n) is o(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∀c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣&lt;c g(n)\\color{red} \\boldsymbol{ \\forall } \\color{black} c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ &lt; } \\color{black} c \\ g(n)\n∀c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣&lt;c g(n)\n注意:\n\n量词顺序是 ∀ ∃ ∀\\forall \\ \\exist \\ \\forall∀ ∃ ∀。\n因为是对于全部的 ccc 存在 n0n_0n0​，因此 n0n_0n0​ 的数值可以依赖于 ccc。\n与Big-Oh不同，最后的符号是 &lt;&lt;&lt; 而不是 ≤\\leq≤。\n\nlittle-oh也可以被定义为：\nlim⁡n→∞f(n)g(n)=0\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = 0\nn→∞lim​g(n)f(n)​=0\n 性质\nlittle-oh作为一个二元关系(binary relation)，拥有以下性质：\n\nlittle-oh不具有自反性(Reflexive, e.g. xRxx R xxRx)。即f(n)=nf(n) = nf(n)=n 不是 o(n)o(n)o(n)。\nlittle-oh不具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)。\nlittle-oh具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。\n\nlittle-oh 更像是严格的 &lt;&lt;&lt;。\n 特点\n\n与Big-Oh类似，little-Oh定义是函数的严格无法到达的上限。\nlittle-oh的意思是，当nnn足够大时，f(n)f(n)f(n)的增长速率小于g(n)g(n)g(n)。\nlittle-oh中 g(n)g(n)g(n) 阶级越小，越能说明 f(n)f(n)f(n) 的增长率。\n\n 推论 &amp; 方法\n\n推论1：如果f(n)f(n)f(n) 是 o(g(n))o(g(n))o(g(n))，那么 f(n)f(n)f(n) 一定是 O(g(n))O(g(n))O(g(n))\n正如 &lt; → ≤&lt;\\ \\to\\ \\leq&lt; → ≤ 一样，很明显 O(g(n))⊂o(g(n))O(g(n)) \\subset o(g(n))O(g(n))⊂o(g(n))。\n推论2 （乘法）：如果f1(n)f_1(n)f1​(n) 是 o(g1(n))o(g_1(n))o(g1​(n)), f2(n)f_2(n)f2​(n) 是 o(g2(n))o(g_2(n))o(g2​(n))，那么 f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 o(g1(n)g2(n))o(g_1(n)g_2(n))o(g1​(n)g2​(n))。\n\n与Big-Oh类似，little-Oh也可以使用删除规则。与Big-Oh不同的是，little-Oh不能选择事实删除规则后的函数，而只能选择比该函数阶级更大的函数。\n 例子\n\n证明 f(n)=n2+nf(n) = n ^ 2 + nf(n)=n2+n 是 O(n3)O(n^3)O(n3)\n要证明f(n)=n2+nf(n) = n ^ 2 + nf(n)=n2+n 是 O(n3)O(n^3)O(n3)，则需要证明 ∀c&gt;0,∃n0&gt;0,∀n≥n0:f(n)&lt;c g(n)\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : f(n) &lt; c \\ g(n)∀c&gt;0,∃n0​&gt;0,∀n≥n0​:f(n)&lt;c g(n)。\n代入和整理可得 ∀c&gt;0,∃n0&gt;0,∀n≥n0:cn2−n−1&gt;0\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : cn^2-n-1 &gt; 0∀c&gt;0,∃n0​&gt;0,∀n≥n0​:cn2−n−1&gt;0。\n由公式可得，若 cn2−n−1=0cn^2-n-1 = 0cn2−n−1=0，且nr&gt;0n_r &gt; 0nr​&gt;0，可解得 nr=1+4c+12c&gt;0n_r = \\frac{1 + \\sqrt{4c + 1}}{2c} &gt; 0nr​=2c1+4c+1​​&gt;0。\n且当 n&gt;nrn &gt; n_rn&gt;nr​ 时，cn2−n−1&gt;0cn^2 - n - 1 &gt; 0cn2−n−1&gt;0 恒成立，那么可以取 n0=nr+1=1+4c+12c+1n_0 = n_r + 1 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1n0​=nr​+1=2c1+4c+1​​+1，使得 ∀n≥n0:f(n)&lt;c g(n)\\forall n \\geq n_0 : f(n) &lt; c \\ g(n)∀n≥n0​:f(n)&lt;c g(n) 恒成立。\n因此，f(n)=n2+nf(n) = n ^ 2 + nf(n)=n2+n 是 O(n3)O(n^3)O(n3)，此时对于所有的 ccc 取 n0=1+4c+12c+1n_0 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1n0​=2c1+4c+1​​+1。\n\n\n 关于Big-Oh和little-oh的定义上的思考：\n如果将Big-Oh的定义改为：∃c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣&lt;c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ &lt; } \\color{black}c \\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣&lt;c g(n)，此时定义这个为 O&lt;O_&lt;O&lt;​，而原定义为 O≤O_{\\leq}O≤​，\n那么实际上，对于 g(n)&gt;0g(n) &gt; 0g(n)&gt;0， f(n)f(n)f(n) 是 O&lt;(g(n))  ⟺  f(n)O_&lt;(g(n)) \\iff f(n)O&lt;​(g(n))⟺f(n) 是 O≤(g(n))O_{\\leq}(g(n))O≤​(g(n))。\n唯一的区别是对于 f(n)=0,g(n)=0f(n) = 0, g(n) = 0f(n)=0,g(n)=0 来说 000 是 O≤(0)O_{\\leq}(0)O≤​(0) 而不是 O&lt;(0)O_&lt;(0)O&lt;​(0)。\n而我们想要定义Big-Oh的渐进符号为 ≤\\leq≤，就得要求 000 是 O(0)O(0)O(0)，因此使用 ≤\\leq≤ 而不是 &lt;&lt;&lt;。\n同理，对于little-oh如果定义改为：∀c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣≤c g(n)\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ \\leq } \\color{black}c \\ g(n)∀c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣≤c g(n)，此时定义这个为 o≤o_{\\leq}o≤​，而原定义为 o&lt;o_{&lt;}o&lt;​。\n此时 o&lt;o_{&lt;}o&lt;​ 与 o≤o_{\\leq}o≤​ 定义的唯一区别也是当 f(n)=0,g(n)=0f(n) = 0, g(n) = 0f(n)=0,g(n)=0 的时候，此时 000 是 o≤(0)o_{\\leq}(0)o≤​(0) 而不是 o&lt;(0)o_{&lt;}(0)o&lt;​(0)。\n而我们想要定义little-oh的渐进符号是 &lt;&lt;&lt;，就得要求 000 不是 o(0)o(0)o(0)，那么使用的是 &lt;&lt;&lt; 而不是 ≤\\leq≤。\n实际上，对于Big-Oh和little-oh最主要的区别是 ∃c\\exist c∃c 和 ∀c\\forall c∀c。\n\n 常用表示表[1]\n根据阶级(order)从小到大排名。\n\n\n\n表示\n中文名\n英文名\n数量级\n\n\n\n\nO(1)O(1)O(1)\n常数级\nconstant\n∞\\infty∞\n\n\nO(log⁡log⁡n)O(\\log{\\log{n}})O(loglogn)\n双对数级\ndouble logarithmic\n221062^{2^{10^6}}22106\n\n\nO(log⁡n)O(\\log{n})O(logn)\n对数级\nlogarithmic\n1030103010^{301030}10301030\n\n\nO((log⁡n)c),c&gt;1O((\\log{n})^c), c &gt; 1O((logn)c),c&gt;1\n多重对数级\npolylogarithmic\n2106c2^{10^{\\frac{6}{c}}}210c6​\n\n\nO(nc),0&lt;c&lt;1O(n^c), 0 &lt; c &lt; 1O(nc),0&lt;c&lt;1\n分数幂级\nfractional power\n106c10^{\\frac{6}{c}}10c6​\n\n\nO(n)O(n)O(n)\n线性级\nlinear\n10610^6106\n\n\nO(nlog⁡n)=O(log⁡n!)O(n\\log{n}) = O(\\log{n!})O(nlogn)=O(logn!)\n对数线性/拟线性级\nloglinear, n-log-n\n10510^5105\n\n\nO(n2)O(n^2)O(n2)\n二次级\nquadratic\n10310^3103\n\n\nO(nc)O(n^c)O(nc)\n多项式/代数级\npolynomial, algebraic\nnc\\sqrt[c]{n}cn​\n\n\nO(cn)O(c^n)O(cn)\n指数级\nexponential\n6log⁡c106\\log_{c}{10}6logc​10\n\n\nO(n!)O(n!)O(n!)\n阶乘级\nfactorial\n999\n\n\n\n\n Big-Oh家族使用样例\n\n用于表示一个范围：算法 X 最坏的情况时间复杂度是 o(n4)o(n^4)o(n4) 和 Ω(n3)\\Omega(n^3)Ω(n3)，但是实际表现并不确定。\n用于确定一个增长率：算法 X 最佳的情况时间复杂度是 Θ(n2)\\Theta(n^2)Θ(n2)。\n用来表示一个平均值：算法 X 平均情况时间复杂度是 O(n3)O(n^3)O(n3)。\n\n\n 使用Big-Oh家族分析算法效率注意点\nBig-Oh家族之所以实用是因为它隐藏了低阶项和常数。它们主要分析当 nnn 足够大时渐进的范围,也可以说是 nnn 的增长率。\n但是在 nnn 比较小时这些被隐藏掉的项可能会成为非常重要的参考指标。也就是说不能完全根据Big-Oh家族和阶级大小来完全判断一个算法的实际工作时的效率。\n例如：\n\n10000n10000n10000n 是 O(n)O(n)O(n)，同时 2n2^n2n 是 O(2n)O(2^n)O(2n)，当时当 nnn 比较小时，例如 n=6n = 6n=6 时，前者需要进行的计算数是 600006000060000，而后者是 646464，此时前者的效率是不如后者的。\nO(1.02n)O(1.02^n)O(1.02n) 尽管是指数级(exponential)，但是它的效率并不逊色。\n\n但是Big-Oh家族在理论上对算法效率进行分析往往是有效的，并且在 nnn 比小的时候程序所消耗的时间往往是会忽略不计的。\n\n 总结\n\nBig-Oh家族定义及其渐进表示法总结[1:1]\n\n\n\n\n表示法\n名字\n描述\n渐进符号\n形式定义\n\n\n\n\no(g(n))o(g(n))o(g(n))\nlittle-Oh\n函数渐进地由ggg支配\n&lt;&lt;&lt;\n∀c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣&lt;c g(n)\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : | f(n) | &lt; c \\ g(n)∀c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣&lt;c g(n)\n\n\nO(g(n))O(g(n))O(g(n))\nBig-Oh\n函数以ggg为渐进边界\n≤\\leq≤\n∃c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\leq c\\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣≤c g(n)\n\n\nΘ(g(n))\\Theta(g(n))Θ(g(n))\nBig-Theta\n函数由ggg为渐进边界和下边界\n≈\\approx≈\n∃c′&gt;0,∃c′′&gt;0,∃n0&gt;0,∀n≥n0:c′g(n)≤f(n)≤c′′g(n)\\exist c&#x27;&gt;0,\\exist c&#x27;&#x27;&gt;0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : c&#x27;g(n) \\leq f(n) \\leq c&#x27;&#x27;g(n)∃c′&gt;0,∃c′′&gt;0,∃n0​&gt;0,∀n≥n0​:c′g(n)≤f(n)≤c′′g(n)\n\n\nΩ(g(n))\\Omega(g(n))Ω(g(n))\nBig-Omega\n函数由ggg为渐进下边界\n≥\\geq≥\n∃c&gt;0,∃n0&gt;0,∀n≥n0:f(n)≥c g(n)\\exist c&gt;0,\\exist n_0&gt;0,\\forall n \\geq n_0: f(n) \\geq c\\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​:f(n)≥c g(n)\n\n\nω(g(n))\\omega(g(n))ω(g(n))\nlittle-omega\n函数渐进支配ggg\n&gt;&gt;&gt;\n∃c&gt;0,∀n0&gt;0,∃n≥n0:f(n)&gt;c g(n)\\exist c&gt;0,\\forall n_0 &gt; 0, \\exist n \\geq n_0 : f(n) &gt; c\\ g(n)∃c&gt;0,∀n0​&gt;0,∃n≥n0​:f(n)&gt;c g(n)\n\n\n\n\n如何求解一个算法的时间复杂度Big-Oh：\n\n建立算法函数的伪代码。\n求出该算法函数的原始运算数(number of primitive operator)和输入大小n的函数关系。\n根据该函数求出Big-Oh表示。\n\n\n\n 三. 🏫Master定理\n// TODO\n 四. 🔒数据结构\n// TODO\n 五. 💻算法\n// TODO\n 📘Reference\n\n\n\n源自: https://en.wikipedia.org/wiki/Big_O_notation ↩︎ ↩︎\n\n\n\n","slug":"笔记/笔记-ADE-算法数据结构和效率","date":"2024-05-25T00:42:20.000Z","categories_index":"笔记","tags_index":"Notes,Algorithm,Data Structure,Big Oh","author_index":"zExNocs"},{"id":"d681443dee58dcfb94dec12db90a9a0d","title":"随笔日记导航","content":" 随笔\n 娱乐类随笔\n\n梗图\n记录网友怪话\n\n 技术类随笔\n\n让Hexo支持KaTeX和emoji\n\n\n 日记\n","slug":"导航/导航-随笔日记导航","date":"2024-05-25T00:15:32.000Z","categories_index":"导航","tags_index":"Diary,Essay","author_index":"zExNocs"},{"id":"c9fd788a84f48b02fed840451084249f","title":"笔记导航","content":" 按照年份分类\n Y3\n\nADE - 算法数据结构和效率 : 有关算法效率分析的课题笔记，包括Big-Oh家族、Master定理和部分算法与数据结构的算法分析。\n\n","slug":"导航/导航-笔记导航","date":"2024-05-24T21:25:57.000Z","categories_index":"导航","tags_index":"Notes","author_index":"zExNocs"},{"id":"625e3e920d4d18f0b54366f772b38b35","title":"语言学习导航","content":"","slug":"导航/导航-语言学习导航","date":"2024-05-24T17:44:53.000Z","categories_index":"导航","tags_index":"Languaue","author_index":"zExNocs"},{"id":"f2a68e25ffce8d6b8f475f30117ea7f4","title":"算法和数据结构导航","content":" 算法\n 数据结构\n","slug":"导航/导航-算法和数据结构导航","date":"2024-05-24T17:43:22.000Z","categories_index":"导航","tags_index":"Algorithm,Data Structure","author_index":"zExNocs"}]