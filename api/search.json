[{"id":"367c4ae2735e8df1bc976f97aeb76f16","title":"笔记-计算机安全","content":"","slug":"笔记/笔记-计算机安全","date":"2025-05-20T16:28:12.000Z","categories_index":"笔记","tags_index":"","author_index":"zExNocs"},{"id":"3ae50ab4ba4da3b0252b141ce255837e","title":"笔记-安卓开发","content":" ✒️背景\n暂时没有背景。\n 🔖介绍\n暂时没有介绍。\n 一. 安卓介绍\n安卓(Android)是一个主要为手机和平板设计的操作系统(operating system)。其主要是基于 Linux 内核的修改版本构建，针对移动设备架构进行了优化，使用类似Java的环境进行应用开发（与传统Java平台不同）。\n其软件设计主要采用 Apache 许可证开源，鼓励社区开发和贡献。特定部分不是开源的。\n 0. 平台架构：\n从下到上：安卓内核(kernel)、硬件层、ART(Android Runtime)、Java API 架构、用户应用。\n 1. 灵活性 (Flexibility)\n其具有灵活性(Flexibility)和定制性(Customization)：\n\n允许硬件制造商进行定制，从而实现跨设备的多样化 Android 体验。\n支持自定义引导加载程序，实现更深层次的系统修改和 root 权限（在某些情况下）。\nroot 权限提供 super 用户访问权限。\n\n 2. 兼容性 (Compatibility)\n具有向前和向后(Forward &amp; backward)兼容性支持。\n向后兼容性限制：\n\n无法使用早期版本中不存在的 API。\n开发人员可以为其应用指定最低 API 级别。\n\n许可和品牌：\n\nAndroid logo 已获得 Creative Commons (CC) 许可。\n标有“Android 手机”的设备必须：\n\n通过特定的兼容性测试。\n支持 Android 设定的 API 标准。\n\n\nAndroid”品牌仅授权给开放移动联盟(Open Mobile Alliance)成员。\n\n 3. 安卓内核 (kernel)\n安卓内核是基于 linux 的，但有一些特定的修改。\n\n电源管理增强(Power Management Enhancements)，包括唤醒锁(wakelock)。\nBinder IPC (进程间通信 Inter-Process Communication) 驱动程序：一种用于高效进程通信的自定义机制。\nLow Memory Killer：一种在内存不足的情况下优雅地终止进程的机制，根据重要性确定优先级。\nAshmem (Anonymous Shared Memory 匿名共享内存)：\nAlarm Driver (警报驱动程序)：用于根据定时事件唤醒设备。\nOOM（Out of Memory 内存不足）调整：针对前台和后台进程采用不同的 OOM 处理方式。\n\n 4. 安卓硬件 (hardware)\n\nBluetooth：BlueZ\nGPS：制造商提供的 libgps.so\nWifi：wpa_supplicant\nDisplay：标准帧缓冲驱动程序 Standardframebuffer driver\nKeyboard：标准输入事件 Standardinput event\nLights：制造商提供的 liblights.so\nAudio 音频：制造商提供的 libaudio.so\nCamera：制造商提供的 libcamera.so\nPowerManagement：“wakelocks” kernel patch\nSensors：制造商提供的 libsensors.so\nRadio 无线电：制造商提供的 libril.so\n\n 5. 安卓应用\n安卓应用使用的是沙盒(sandboxing)模式：\n\n确保应用程序在隔离环境中运行，以确保安全。\n利用 Linux 多用户功能。\n\n通常一部手机只有一个用户。\n\n\n每一个应用都有自己的进程，运行在自己的虚拟机中，拥有独一无二的 UID/AID。\n确保应用程序无法访问其他应用程序的文件、数据或进程。\n利用内置的 Linux 安全措施，包括标准用户和 root 用户权限。\n\n标准用户没有根访问权限。\n根访问权限涵盖整个系统，但通常拥有限制以增强安全性。\n\n\n\n 6. 安卓启动过程\n\n启动 ROM/Bootloader：将引导加载程序加载到 RAM 中，检测外部 RAM、设置网络、内存等。\n启动内核：配置缓存、保护内存、调度并加载驱动程序。\n初始化：挂载 /sys、/dev 或 /proc 等目录，运行 init.rc 脚本。\nZygote &amp; VM：允许在 Android VM 之间共享代码，以便快速启动不同应用的单独 VM。\n系统服务应用：电源管理器、活动管理器、电话、注册表、包管理器、上下文管理器、系统联系人提供程序等\n\n 7. Zygote\nZygote 是 Android 启动序列的一部分，可帮助启动应用程序。系统通过 Zygote 进行初始化，从而在 Dalvik（旧版 Android）或 ART（新版 Android）上执行应用。\n出于安全和隔离的原因，Android 应用程序在单独的进程中运行。每次启动应用程序时，启动一个新进程并从头开始设置 Android runtime (ART) 的新实例效率很低。\nZygote 是辅助其启动的一个系统进程，初始化时包含所有必要系统库的主进程，这可确保常用资源已预先加载并在应用程序之间共享。在系统启动时，它会加载基本 Java 和 Android 类（java.、android.）。此预加载可缩短后续应用的启动时间。\nAndroid应用在启动时会从Zygote进程派生一个新的进程，以减少应用启动时的初始化开销。减少了应用进程从零开始的初始化时间，提高了Android设备多任务或快速切换应用时的性能。\n安卓虚拟机创建依赖 Zygote:\n\nSingle Instance: 系统启动后，Zygote 会创建 Android 虚拟机（Dalvik 或 ART，具体取决于版本）的单实例。\nClass Reference: 此 VM 已准备好在 Zygote 初始化期间加载的类，确保用户应用快速启动和响应。\n\n 8. ART\nART是用来替代Dalvik虚拟机的东西，其特点如下：\n\nAOT 预编译（Ahead-Of-Time Compilation）：在应用安装时就会进行预编译，将应用的字节码（.dex 文件）编译为本地机器码并存储下来。这样在应用运行时，省去了重复的 JIT（Just-In-Time）编译过程，启动更快，性能更高。\n更高效的垃圾回收（Garbage Collection）：ART 采用分代式垃圾回收（Generational GC）或其他更先进的 GC 技术，减少卡顿并降低对应用运行的干扰。\n更好的调试工具和诊断能力：ART 提供了更丰富的调试选项和运行分析工具，如更详细的内存分析、线程分析等，方便开发者进行性能优化。\n兼容性：虽然 ART 采用的是与 Dalvik 不同的执行机制，但大多数应用无需进行改动就可在 ART 上运行，Google 在实现中保留了较高程度的向后兼容。\n\n 安卓硬件\n 1. 一芯片系统 (System On A Chip, SOCs)\n\n仅使用芯片上的部分晶体管组成 CPU\n\n使用其余晶体管构建系统的其他组件\n外部引脚直接连接到外围硬件\n\n\n在芯片上集成多个异构组件\n\n减少通信开销\n减少热量\n\n\n晶体管提供计算、存储\n\n将芯片划分为多个通信区域\n\n\n通用架构\n\nCPU 核心：ARM Cortex 系列（例如 Cortex-A78）\n用于 AI 任务的神经处理单元 (NPU)\n\n\n差异\n\n人工智能和机器学习的集成：SoC 越来越多地包含用于机器学习和人工智能的专用核心，从而增强了面部识别和增强现实等功能。\n\n\n根据用例进行定制\n\n不同的 SoC 针对不同的性能需求进行了优化，例如游戏、摄影或能效。可以拥有独特的配套模块。\n\n\n封装层叠 (Package on Package, PoP)：\n\n背景：传统 SoC 中的 RAM集成度各不相同，在现代 SoC 中，集成 RAM 更为常见，但配置可能因应用需求而异。\n定义：一种将内存封装直接安装在 SoC 顶部的封装技术。\n生产灵活性：允许独立生产和测试内存和逻辑组件。\n空间优化：垂直堆叠组件以节省水平空间，这对于紧凑型设备设计至关重要\n\n\n\n 2. ARM CPU vs Intel CPU (x86)\n约 95% 的智能手机使用 ARM CPU，其余设备使用 Intel、MIPS 等。\n\n为什么使用ARM？\n快速高效的操作。\n更高的代码密度可实现更紧凑的设计。\n减少组件堆积，提高空间利用率。\n\nARM 指令的特点：\n\n每条指令尽可能只使用一个周期。\n每条指令的长度为 32bit\n几乎每条指令都具有条件执行功能。\n一般寄存器：\n\nR0-R12：一般目的的寄存器\nR13：栈寄存器\nR14：链接寄存器\nR15：PC\n\n\n并不是所有的指令都用到 32bit，这会导致潜在的低效率，因此使用 Thumb 指令：\n\nThumb 指令使用紧凑的 ARM 16-bit 指令集。\n使用可变长度指令集，保留最常用的ARM指令并将它们编码成16位。\n\n通过减少指令大小，实现了更快的速度。\n一次32-bit内存可以检索两个16位 Thumb 指令。\n\n\n\n\n\nARM bit.LITTLE：\n\nARM 使用大小核，通过集成强大的 (big) 内核和高效的 (LITTLE) 内核，将高性能与能效相结合。\n系统可以根据当前任务的需求在核心之间无缝切换，确保最佳性能和效率。\n\n 安卓软件的核心组件\n安卓与传统Java应用不同，可以有多个入口点。这些入口点定义了安卓系统可以与应用程序交互或者进入应用程序的方式，包括活动(Activity)、服务(Service)、广播收集器(Broadcast Receiver)和内容提供程序(Content Provider)。\n传统的操作系统通常只有一个 Main 入口点，并且操作系统将程序加载到进程中并执行，实例化 Java VM 加载应用程序使用的所有类 执行 main。\n而安卓中是基于component的模型，拥有多个应用程序入口点：\n\nZygote fork 后仍执行 main 函数，但在此基础上进行抽象。\n并非所有都是用户的入口点。\n每个component都作为逻辑上独立的唯一实体存在\n\n一个 Android 应用程序应该包含多个组件，并且用户经常在短时间内与多个应用程序进行交互，因此应用程序需要适应不同类型的用户驱动的工作流程和任务。\n安卓的特定组件通常是由特定interface进行通信，在运行时进行绑定。每个组件都有特定的生命周期，根据需要动态加载和卸载。\n 1. Activity\n包括UI组件，View。是 android.app.Activity 的子类。其提供一个虚拟的UI，每一个 Activity 都拥有自己的窗口。\n a. View\nUI layout属于一个View，是一种资源，在单独的通过编程构建的XML文件中指定。\n\nView的子类包含：\n\nViews: 用来显示一些内容\nWidgets: 执行某些操作\nViewGroups：布局子视图\n\n\n\n I. Views\n\n设计规范：\n\n首选浅布局层次结构。\n尽可能减少嵌套布局（遍历成本）。\nwide over deep。\n\n\n编程方面：\n\n可以使用使用 setContentView() 来指定Activity的View。\n可以使用 addView()、removeView() 来改变视图的层次结构。\n根据 XML 布局定义生成的ID，使用 R.layout.ID 来找到特定的视图。\n可以将 View 和数据绑定在一起。\n\n\n策略：\n\n手机很少是相同的，通常具有不同的屏幕尺寸和宽高比、各种分辨率。所以应该避免硬编码 UI 组件配置细节。\n布局应该适应其所填充的屏幕：\n\n将布局定义为层次结构和关系。\n使用以密度无关像素 (density-independent pixels,dp) 而不是 px 定义测量值\n\n1dp 相当于 160dpi 上的一个像素。\n\n\n可以定义特定于配置的布局\n\nSmall, normal, large and extra large.\n使用最小宽度限定符\n使用方向限定符\n进行规划，例如 res/layout-sw600dp/main_activity.xml\n\n\n\n\n\n\n\n II. ViewGroups - Layouts\nLayouts通常包含：\n\nFrameLayout：最简单的layout，只包含一个物体。\nLinearLayout：根据方向属性，将所有子项对齐到单一方向。\nTableLayout：将子项定位到行和列中\nConstraintLayout / RelativeLayout：让子视图指定它们相对于父视图或彼此的位置，使用对齐进行约束。\nScrollView：垂直滚动视图。\nSwipeRefreshLayout：实现“下拉刷新”交互效果的控件。检测垂直滑动、显示进度条并触发回调方法。\n\n III. Widgets\n用于可以交互的子View：\n\nButton\nTextView\nEditText\nCalendarViewer\nImageView\n\n这些组件可以处理UI事件：\n\n代码中，可以使用 setOnClickListener()。\n在XML中，可以设置 android:onClick=&quot;&quot; 参数。\n\n这些组件可以文字展示：\n\n代码中，可以使用 .getText() 和 .setText()\n在XML中，设置 android:text=&quot;&quot; 参数，例如 android:text=&quot;@string/hello_world&quot;\n\n b. 数据绑定\n传统model中，设计大量样本代码(boilerplate code)：\n\nActivity 和 Model 紧密耦合\n处理 Activity 中的 onClick 事件\n查找对相关视图的引用\n检索内容（例如文本字段的内容）\n将结果写回视图\n\n一个数据模型应该：\n\n将 POJO 绑定到View组件以进行初始填充\n使对象可观察，以便在更改时自动更新 UI\n\n如继承&quot;BaseObservable&quot;，或者使用&quot;ViewModel + Livedata&quot;。\n使用可观察域，即 @&#123;&#125; 和 @=&#123;&#125;\n可观察的objects, fields and collections\n\n\nData Binding Library：\n\n是一种直接在XML中与类的成员进行绑定的方法，减少了在Activity中进行初始化的方法。\n即从layout中引用model对象。\n会生成必要的绑定类。\n包括基本格式表达式。\n\n\n双向数据绑定，允许从View更新Object，反之亦然\n\n数据绑定的实现方法：\n引用数据：\n123456&lt;data&gt;  &lt;variable    name=&quot;viewmodel&quot;    type=&quot;com.example.myapplication.MyModel&quot;  /&gt;&lt;/data&gt;\n可观察域：\n\n@&#123;&#125;：接收数据变化，是单项绑定。\n@=&#123;&#125;：接收属性的数据更改并监听用户更新，是双向绑定。\n\n1android:progress = &quot;@=&#123;viewmodel.progress&#125;&quot;\n c. Manifest文件\n是应用的components列表，用于指定程序的入口点，通常包含应用的信息(需要什么、什么可以做)。不在这个列表的不能称之为 components。那么该组件无法作为入口点。\n通常要考虑：\n\n如何启动（默认的启动 activity）\n如何向其他人展示\n哪些内容可以访问它 （程序内部和外部）\n用户的权限。\n\n d. Navigation\nActivity 可以启动其他的 Activity，此时新的Activity就在旧的Acitivity上方。Activity 类似于一个栈结构。\n i. 分层活动导航 (Hierarchical Activity Navigation)\n种类：\n\nDescendant navigation 子级导航：指从一个层级（通常是父级）“深入”到下一个层级（子级）的导航方式。也可理解为“层级向下”或“钻取”式导航。\nLateral navigation 横向导航：在同一层级内进行“左右”或“并列”切换的导航方式。也可理解为“同级别的兄弟页面之间”的移动。通常是同一父级下不同子页面之间的切换。\n\n形式：\n\n列出可选择的 activity\n屏幕之间 Tab\n在屏幕或页面之间滑动\n按钮切换\n导航（graphs, destinations）\n\n ii. Back 和 UP 导航\n都属于撤消横向和后代导航。\n\nBack: 可以在同一级中返回。\n\n关闭当前的 activity。\n恢复堆栈中的下一个活动\n\ntaps 和 swipes 会更改当前屏幕显示的信息，而不是activity，因此不会影响历史记录。\n\n\n\n\nUp: 返回父级。\n\n关闭当前的 activity。\n启动（或恢复）相应的父级活动。\n\n在 manifest 中表示。一般使用 android:parentActivityName=&quot;.ParentActivity&quot; 表示。\n如果它在后台堆栈中，则将其移到最前面。\n可以创建一个“假”返回堆栈\n\n\n\n\n\n e. Fragments\nFragments 是比 Activity 更小的 UI 单元。\n\n多个 Fragments 可以组成一个 Activity，这样可以支持大屏幕 （例如平板）。\n可以在多个 Activity 复用一个 Fragments。\n管理逻辑上属于堆栈中同一 Activity 的项目集合\n\n例如翻阅照片。\n\n\n在输入、事件、生命周期方面与宿主 Activity 的关系有些复杂\n\n f. Intents\nIntent用来描述一个操作(operator)，包括要执行的Action以及所要处理的数据（可以用 URI 表示）。\nAndroid 的设计理念是通过 Intent 在不同的组件（尤其是 Activity 之间）进行通信，而不是让我们手动去实例化 Activity。\nIntent 还可以实现延迟绑定（Late Runtime Binding），并能把多个 Activity 逻辑“黏合”到一起。\n系统会根据AndroidManifest.xml中注册的信息来确定该如何响应并处理 Intent。\n i. 使用 Intent 启动/停止一个 Activity\n如何使用 Intent 启动一个 Activity：\n\n创建一个新的 Intent 对象。\n指定想要将 Intent 发送给谁（可以是显式或者隐式方式）。\n调用 startActivity() 函数，并把这个 Intent 传递进去。\n系统会根据传入的 Intent，启动一个新的 Activity（即由系统的运行时来负责真正的启动过程）。\n\n停止一个 Activity：\n\n被启动的 Activity 完成任务后，可以通过调用 finish() 方法来销毁自己，返回到原先的 Activity。\n当用户按下“返回”键时，系统也会销毁当前 Activity，将界面返回到上一个 Activity（或退出应用）。\n\n ii. 显式 vs 隐式 Intent\n显式(Explicit) Intent：\n\n提供要启动的 Activity 的完全类名。\n如 Intent myIntent = new Intent(context, otherActivity.class);\n\n隐式(Implicit) Intent:\n\n只指定一个操作（Action）和数据类型（Data/Category/Type）。\n由系统或其他应用中符合条件的组件来响应。\n必须要在 manifest 中声明，具体看下面 Intent Filters\n\n iii. Intent Filters for Deep Linking\nIntent Filters 是在 AndroidManifest.xml 中为 Activity、Service 或 BroadcastReceiver 指定的过滤条件，用于匹配特定的 Intent。它们决定哪些 Intent 可以由某个组件（如 Activity）处理。\n匹配条件：\n\nAction：定义意图的操作（例如 android.intent.action.VIEW 表示“查看某个资源”）。\nCategory：补充描述意图的分类（例如 android.intent.category.DEFAULT 是默认分类）。\nData：指定数据 URI（例如 URL 的协议或路径）或 MIME 类型，用于匹配数据内容。\n\n通过在 AndroidManifest.xml 中声明 Intent Filters，可以：\n\n指定某个 Activity 可以处理的 Intent 类型。\n实现 Deep Linking：允许应用直接打开特定的内容（如通过 URL 直接跳转到应用内的某个界面）。\n支持隐式 Intent：当其他应用或系统发送隐式 Intent 时，只有符合声明的 Activity 会被匹配到。\n\n当多个应用或组件的 Intent Filters 都匹配某个 Intent 时，系统会弹出一个选择对话框，允许用户选择使用哪个应用来处理。\n例子：\n1234567&lt;activity android:name=&quot;com.example.martinactivities.ForthActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;data android:scheme=&quot;http&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;\n这个配置表示 ForthActivity 是一个可以处理特定 Intent 的 Activity。\n\n表示此 Activity 可以处理“查看某些内容”的操作，例如点击链接或打开文件。\n表示这个 Activity 是默认分类，用于普通的隐式 Intent 调用。\n表示此 Activity 能够处理 HTTP URL 的数据。\n\n g. Activity 之间的通信\n\nstartActivity()的限制：\n\n用于启动另一个 Activity，但不允许返回结果到启动它的 Activity。\n应用通常需要维持用户在多个 Activity 中的状态。\n在复杂的场景中，Activity 可能需要跨进程通信（IPC），或者作为其他应用的入口点。\n\n\nstartActivityForResult() 已过时：\n\n启动另一个 Activity，并允许子 Activity 在完成后将结果返回到启动它的 Activity。\nstartActivityForResult() 需要提供一个数值型的请求代码（requestCode），以便区分返回的结果来源。\n子类使用 setRusult() 和规定一个返回结果的 intent 来返回结果。\n父类使用重写 onActivityResult(int requestCode, int resultCode, Intent) 方法来处理结果。\n\n\nregisterForActivityResult()\n\n是 startActivityForResult() 的现代替代方法，更加简洁、安全，避免了旧方法中繁杂的 onActivityResult() 回调逻辑。\n基于合约：例如使用 ActivityResultContracts.StartActivityForResult 来指定启动的 Activity 和结果处理逻辑。\n回调处理：在启动 Activity 时注册一个回调函数，当子 Activity 结束后返回时，该回调会被调用。\n\n\n\n h. Tasks vs Activities vs Processes\n\n\n\n名字\n介绍\n\n\n\n\nActivities\n定义一个应用组件(application component)中屏幕的信息。应用是一个Activities的集合，包括创建的和从其他应用中复用的。\n\n\nTasks\n为了实现一个目标而用到的一系列activity。单个任务可以只使用一个app中的activity，也可以利用多个不同app中的activity。\n\n\nProcesses\n创建特定应用的 host component 。一个任务可以跨越多个进程\n\n\n\n i. 安卓开发中的任务管理。\n为什么要管理任务？\n\n用户频繁切换任务/堆栈：比如从一应用跳转到另一个应用或在同一个应用的不同活动中切换。\n大多数任务由多个活动 (Activities) 组成：\n\n调用另一个应用中的 Activity：\n\n并不总是局限于一个应用，而是跨应用的任务。\n通过松散绑定的方式提供连贯的用户体验，依赖于 Intent 等机制。\n\n\n非确定性的用户路径 (Non-deterministic User Journeys)：\n\n应用的启动位置不一定相同。\n用户可能在一段时间内“离开”应用，然后返回。\n\n\n\n\n\n任务管理的好处\n\n利用其他应用的组件：\n\n通过 Intent 调用其他应用的 Activity，简化复杂功能的实现。\n\n\n细粒度的资源管理\n\n单个任务的活动状态可以根据需求调整，以优化内存、CPU、存储、屏幕和电池的使用。\n例如，释放后台任务的资源来提高设备性能。\n\n\n\n如何应对任务管理？\n\n组件具有生命周期 (Lifecycles)：\n\n每个 Activity 和 Fragment 都有生命周期，通过管理生命周期事件（如 onCreate, onStart, onDestroy 等），可以更高效地控制任务和资源使用。\n\n\n\n Activity 与进程管理的核心概念\n\n系统不会直接杀死活动 (The OS never kills an Activity)：\n\nAndroid 系统不会单独终止活动，而是会杀死托管这些活动的进程以释放内存。\n系统更倾向于通过终止后台进程来回收资源。\n\n\n应用如何响应内存压力：\n\nonTrimMemory 回调：应用可以通过该回调管理自己的内存资源，例如清除缓存或释放不必要的数据。\n\n\n进程被终止的可能性取决于其状态：\n\n系统会选择对用户影响最小的进程进行终止。\n决策依据包括：\n\n进程最近是否被使用。\n进程是否与主屏 (Home Activity) 相关联。\n\n\n\n\n\n j. Activity 的生命周期管理\n I. Activity 的三种主要状态：\n\nActive (活跃状态)：\n\nActivity 位于前台并获得焦点。\n用户正在与该 Activity 交互。\n\n\nPaused (暂停状态)：\n\nActivity 仍然可见，但不在顶部。\n例如，出现一个半透明窗口或分屏模式中另一个应用获得焦点时，Activity 进入暂停状态。\nActivity 处于活动状态但未获得焦点。\n\n\nStopped (停止状态)：\n\nActivity 被其他 Activity 完全遮挡。\n此状态下，Activity 不再可见。\n\n\n\n II. 优先级降低的 Activity\nAndroid 系统如何管理资源：\n\n当 Activity 进入 Paused 或 Stopped 状态时，系统可能会降低其资源分配优先级。\n具体表现：\n\n停止状态的 Activity 被挂起 (Suspended)：不会主动执行任何代码，但其状态会被保留。\n非活动的 Activity 可能被销毁 (Destruction)：\n\n如果系统需要额外内存，可能会销毁处于 Stopped 或 Paused 状态的 Activity 来回收资源。\n重要性：必须保存 Activity 的状态以便用户返回时恢复。\n\n\n\n\n\n III. 注意事项\n状态转换会触发事件，确保避免以下问题：\n\n因为用户接听电话导致的崩溃：\n\n当用户接听电话或应用失去焦点时，系统可能会暂停或停止当前的 Activity。\n如果没有妥善管理生命周期，可能会导致崩溃。\n\n\n在用户不使用应用时消耗资源：\n\n停止或暂停的 Activity 不应占用系统资源（如内存、CPU），以避免浪费和影响其他任务的性能。\n\n\n丢失用户进度：\n\n确保在 Activity 状态变化时保存用户数据（如输入内容、进度）。\n提供一致的用户体验非常重要。\n\n\n在配置更改期间的崩溃（例如屏幕旋转）：\n\n设备从纵向切换到横向或其他配置变化（如语言、屏幕大小）时，Activity 会重新创建。\n如果没有保存状态或正确处理生命周期事件，可能会导致崩溃或用户数据丢失。\n\n\n\n IV. 生命周期\nonCreate() → onStart() → onResume() → onPause() → onStop() → onDestroy()\n\nonCreate()：Activity 的初始化方法，相当于组件的“构造函数”。用于执行基础设置，例如加载 UI 布局。\nonStart()：Activity 对用户可见，但尚未获得焦点。此时 UI 已加载，但用户还不能与之交互。\nonResume()：Activity 已进入前台，并可供用户交互。Activity 将一直处于此状态，直到被其他 Activity 遮挡或用户切换应用。\nonPause()：Activity 不再是用户的焦点，但仍部分可见（如弹出窗口覆盖部分界面）。停止不需要运行的任务，例如暂停视频播放或相机预览。\nonStop()：Activity 完全不可见，处于后台状态。应释放资源并保存持久数据（如数据库或文件）。\nonDestroy()：Activity 被销毁时调用。可能不会正常调用，所以不要在这里保存状态。\n\n当一个活动启动另一个活动后，必然有一个活动进入 onPause()，另一个进入 onResume()。\n关于 onDestroy() 注意事项：\n\n配置更改时，例如设备的屏幕方向、语言或者输入设备发生变化时，当前 Activity 会被摧毁并重新创建。\n当一个 Activity 正常完成时，用户按下返回键或者调用 finish() 方法，onDestroy() 会被调用。\n如果系统因为资源不足终止后台进程，则不会调用。\n因此，应该在 onPause() 或 onStop() 中提前保存关键数据，避免因进程被杀死导致数据丢失。\n\n V. UI保存\n主要在于如何使用 onSaveInstanceState() 方法。\n该方法不应依赖 Activity 保存 UI 或状态，配置更改和进程终止都可以恢复。例如当设备旋转会导致配置更改。\n在 Activity 被停止 onStop() 之前，系统会调用 onSaveInstanceState()。目的是保存 UI 的瞬态状态（transient state），以便在 Activity 重新创建时恢复。\n例如：保存用户输入内容、滚动位置或临时选择项。\n\n保存瞬态 UI 状态：\n在 Activity 被重新创建时，保存的状态会通过 Bundle 传递：\n\n12onCreate(Bundle savedInstanceState)onRestoreInstanceState(Bundle savedInstanceState)\n\n保存非瞬态 UI 状态：\n\n使用 SQL 数据库。\n使用 SharedPreferences。\n\n\n\n实例状态 Instance State：\n\n目的：\n\n用于保存小型的、与 UI 相关的数据，这些数据易于序列化或反序列化。\n比如文本输入框的内容、滚动位置等。\n\n\n序列化开销：\n\n由于需要序列化和反序列化，存在一定的性能消耗。\n因此，数据量不宜过大，否则会影响性能。\n\n\n快速存取需求：\n\n状态保存需要足够快，否则会导致 UI 卡顿或帧丢失。\n\n\n\nBundle 特点：\n\n结构：Bundle 是一个键值对（Key/Value）的集合。\n适用场景：适合保存小型的瞬态状态（transient state），如当前页面索引、简单的用户数据。\nBundle 中存储的数据量有限，过大的数据可能导致 TransactionTooLargeException。\n复杂类（如自定义对象）需要实现 Parcelable 接口以优化性能。\n\n建议：\n\n只适用于储存小数据，适用于 UI 瞬态状态的数据存储，避免存储复杂和大规模的数据。\n由于序列化过程的开销，建议尽量保持 Bundle 的存储简单、快速。\n对于复杂数据（如网络请求结果、列表数据），建议使用 ViewModel 或持久化存储（如数据库、SharedPreferences）。\n\n VI. ViewModel：\nViewModel 可以在配置更改时保留状态，例如屏幕旋转不会导致数据丢失。\nViewModel 设计用于与 Activity 或 Fragment 的生命周期绑定，但独立于 UI 控件。在配置更改（如屏幕旋转）中，Activity 或 Fragment 会被销毁并重新创建，而 ViewModel 不会被销毁，从而保持数据的一致性。\n局限性：\n\n对配置更改免疫：ViewModel 可以在配置更改时保留状态，例如屏幕旋转不会导致数据丢失。\n不对资源管理终止免疫：如果系统由于资源不足（如内存不足）终止整个应用进程，ViewModel 中的数据会丢失。此时需要储存在数据库中。\n不对导航操作免疫：当用户导航离开当前 Activity 或 Fragment 时，ViewModel 会被销毁。\n\n VII. LiveData：\n\nLifecycleOwner：Activity 或 Fragment 实现了 LifecycleOwner 接口。提供生命周期对象，用于跟踪当前的生命周期状态。\nLifecycleObserver：注册为观察者的对象会感知生命周期事件。开发者可以将逻辑放入观察者中，而不是直接嵌入生命周期回调。\n\n好处：\n\n逻辑分离：生命周期逻辑与核心业务逻辑分离。\n减少错误：通过系统管理的组件状态减少数据更新冲突。\n\nLiveData 是一种可观察的数据容器，专为生命周期感知设计。与 ViewModel 配合使用，提供数据驱动的 UI 更新。\n特点：\n\n自动管理观察者：\n\n当 UI 组件处于非活动状态时，不会触发观察者回调，避免浪费资源或引发错误。\n当组件被销毁时，自动移除观察者。\n\n\n提供活动数据：\n\n只有当组件处于活动状态时，LiveData 才会分发数据更新。\n\n\n\n适用场景：\n\n数据绑定：实时更新 UI，适合动态数据流。\n简化生命周期处理：减少因生命周期变化导致的数据不一致问题。\n\n 2. Service\n在后台执行长时间运行操作的机制。没有用户界面（UI），用于长时间运行的操作。服务不受限于某个活动（Activity）的生命周期。一个服务可以被多个应用程序使用，避免资源重复。\n服务运行在主线程。\nActivity 经常会从前台转到后台（如用户切换任务）。当 Activity 被停止或销毁时，运行中的任务可能会中断。那么就出现一个问题：如何在 Activity 的生命周期内，或超过其生命周期的情况下处理任务。\n处理方法：\n\n基于生命周期的处理：主要由 Activity 的生命周期（如 onStop() 和 onPause()）及其 UI 组件的回调函数驱动。\n线程执行：Android 使用单线程模型，所有 UI 操作都在主线程（UI 线程）上完成。当需要运行耗时操作（如网络请求或复杂计算）时，必须使用辅助线程来避免阻塞 UI。\n\n线程与 Activity 的关系：\n\nActivity 销毁时，未正确管理的线程可能继续运行，导致内存泄漏或应用崩溃。\n\n为了处理超过 Activity 生命周期的任务，那么需要用到 Service。Service 是一个独立于 Activity 的应用组件，专门用于处理长时间运行的任务。即使 Activity 被销毁，Service 仍然可以继续运行。\n例如：\n\n播放后台音乐。\n定期从网络获取数据。\n上传或下载文件。\n\n服务的限制（What Services are not）\n\n服务不是单独的进程，而是运行在声明它的应用进程中。\n服务不是线程，需要手动启动工作线程以处理后台任务。\n\nAndroid 的 WorkManager\n\n主要用于处理可延迟的后台任务，同时遵守系统的后台限制。\n\n任务、服务与活动的分工（Tasks, Services, and Activities）\n\n服务处理长时间运行或后台任务，例如检查邮件、播放音乐。\n活动负责用户交互，例如显示邮件列表或音乐播放界面。\n\n a. 服务的生命周期（Service Lifecycle）\n\nonCreate()：服务初始化时调用。\nonStartCommand() 或 onBind()：根据启动方式调用。\nonDestroy()：服务结束时调用。\n\n绑定服务（Bound Services）：与其他组件绑定，生命周期与绑定组件相关联。\n非绑定服务（Unbound Services）：独立运行直到被显式停止。\n b. 服务的类型\n\n\n\n类型\n描述\n生命周期\n启动方式\n是否绑定\n\n\n\n\n前台服务\n用户可见的操作（如播放音乐）。\n操作或任务活动期间。\nstartForegroundService()\n可绑定，也可独立运行。\n\n\n后台服务\n用户不可见。\n可能在系统内存不足时终止。\nstartService()\n可绑定。\n\n\n绑定服务\n用于组件间通信。\n绑定的组件存在期间。\n使用 bindService()\n必须绑定。\n\n\nIntentService\n处理异步任务，工作完成后停止。\n任务完成后自行终止。\nstartService()\n很少绑定。\n\n\n\n c. Activity与Service的通信\n\n通过Intent通信：活动（Activity）可以通过发送Intent启动一个服务，触发onStartCommand。\n服务与用户通信：服务可以通过通知（Notifications）与用户交互，因为服务本身没有UI。\n服务与Activity通信：\n\n服务无法通过Intent直接与Activity通信。\n例如，发送邮件或MP3播放任务可通过绑定（Binding）实现通信。\n\n\n保证任务完成：服务的生命周期（Lifecycle）管理至关重要。\n\n d. Notifications\n作用：\n\n提醒用户应用程序的事件，例如任务提醒或系统状态。\n需考虑用户的情绪和专注力，避免过度打扰。\n\n跨平台通知设计原则：\n\n遵循Material Design或Human Interface Guidelines。\n避免无意义通知，例如“很久没见到你了”。\n目标是创建简洁易读、用户友好的通知。\n\n与服务的关系：\n\n服务可以通过通知告知用户正在运行的任务。\nPendingIntent 允许用户通过通知返回到 Activity。\n服务可以在通知中提供交互按钮，例如暂停/停止功能。\n\n e.服务的生命周期\n\n服务的启动方式：\n\nStarted Service（启动服务）：通过startService启动，会独立运行，直到显式调用stopService停止。\nBound Service（绑定服务）：通过bindService绑定，运行于与之绑定的Activity之间的通信通道中。\n\n\n生命周期的特点：\n\n可以同时启动和绑定服务。\n不同的生命周期责任：\n\n启动服务需要开发者管理生命周期。\n绑定服务的生命周期由系统自动管理。\n\n\n\n\n终止服务：\n\n自行调用stopSelf。\n通过Intent调用stopService。\n避免终止：\n\n可将服务设置为前台服务（Foreground Service），通过startForeground提高优先级。\n\n\n\n\nonStartCommand返回值决定服务重启行为：\n\nSTART_NOT_STICKY：服务不再自动重启。\nSTART_STICKY：服务重启但不重新传递Intent。\nSTART_REDELIVER_INTENT：重启服务并重新传递上一次的Intent。\n\n\n\n f. 远程服务 Remote Service\n\nIntent的作用：用于在应用或进程之间通信，但在远程服务中需要进一步扩展。\n跨进程通信的特点：\n\n远程服务允许在不同应用/进程之间共享服务。\n需要将任务交给其他进程中的线程处理。\n可能被多个进程同时使用，因此必须声明为exported服务（在Manifest文件中定义）。\n隐式 Intent 在远程服务中不能使用（可能由于权限或安全性原因）。\n\n\n通信方式：\n\n使用Messenger：用于消息传递（异步）。\n定义接口：支持注册回调和将系统服务封装到API中以供客户端调用。\n\n\n\n g. 服务间通信（Communicating with Services）\n\nMessenger 的角色：\n\nMessenger 是服务的一个 IPC（进程间通信）接口。\n基于消息的通信模型，而不是直接的方法调用。\n支持异步通信，使用消息（Message）携带数据包。\n\n\n消息队列与线程：\n\n消息被排队到单个线程中，按顺序处理。\n使用 Handler 管理线程间的通信和并发。\n服务可以通过定义自己的 Handler 来响应不同类型的消息对象。\n\n\nIBinder 的使用：\n\nMessenger 实际上是一个带有“发送消息”功能的 IBinder。\n服务端通过 IBinder 共享与客户端的连接。\n客户端通过 IBinder 发送消息给服务。\n\n\n双向通信（Bi-directional Communication）：\n\n客户端也可以拥有自己的 Messenger。\n客户端在发送消息时提供一个返回的 Messenger 引用，以实现双向通信。\n\n\n\n h. Messenger/Handler/Looper 关系\n\n\n\n名称\n比喻\n\n\n\n\nProcesses\n将每个应用程序类比为社区中的独立房子。\n\n\nMessenger\n如果一个房子（应用中的活动）需要向另一个房子（远程服务）发送消息，它会写信交给邮递员（Messenger），邮递员将其递送到目的地。\n\n\nHandler\n负责检查信箱的人，阅读信件并根据内容采取行动。\n\n\nLooper\n定期检查信箱的例行工作，确保不会遗漏重要邮件。\n\n\n\n i. 消息传递（Message Transfer） 的机制\n\n服务端的准备（Inside the Service House）\n\n服务端在开始前，会通知邮递员（Messenger）：“如果有人要给我发送信件（消息），这是我的信箱地址，以及我喜欢的信件格式。”\n这一步相当于服务端设置了消息接收的规则和流程。\n\n\n客户端的操作（Inside the Activity House）\n\n当客户端（Activity House）想要向服务端（Service House）发送消息时：\n\n客户端写好信件（消息）并交给邮递员（Messenger）。\n由于服务端之前提供了详细的地址和说明，邮递员能够准确地将信件送达。\n\n\n\n\n回复消息的机制\n\n如果客户端希望收到服务端的回复，它需要在信件中附带回信地址（自己的 Messenger 信息）。\n这样，服务端可以通过回信地址，将响应（回复消息）送回客户端。\n\n\n\n g. Parcelable\n如果服务是绑定到同一个进程内，它们共享相同的内存空间。在这种情况下，可以轻松调用方法并传递对象或引用，效率更高。\n那么需要跨进程通信，如何传递对象？\n\n使用java.io.Serializable\n\n通过反射或自省技术写入对象ID和字段。\n如果类或变量名称发生变化，可能会导致错误。\n缺点：\n\n慢：性能较低。\n脆弱：对类定义的修改敏感。\n\n\n\n\n使用 Parcelable\n\n定义简单的协议用于写入基本数据类型。\n通过传递关键数据重新创建对象（类似深拷贝）。\n具有抗小改动能力（类定义发生小变化不会出错）。\n优点：\n\n快速：比Serializable高效得多。\n由Android内核驱动提供支持。\n\n\n适合在Android应用中使用，特别是涉及跨进程数据传递时。\n\n\n\n h. Defining Remote Interface\n通过 AIDL 定义远程接口\n\n主要功能：\n\n为服务的功能指定一个接口\nAIDL 的作用：\n\n生成一个 代理对象（Proxy Object），允许在本地使用，像远程服务是本地的一样。\n生成一个 存根实现（Stub Implementation）：负责处理远程事务的服务端。\n生成 通信协议：包括对象的序列化（parcelling）和反序列化（unparcelling）步骤，作为拷贝和重新创建对象的传输协议。\n\n\n\n\n与 Java 接口定义的相似性\n\n方法参数标签：\n\nin：传递到远程方法。\nout：返回给调用者。\ninout：既作为输入又作为输出。\noneway：异步调用。\n\n\n允许的数据类型：\n\nJava 的基本数据类型：如 int, float, boolean。\n列表（List）、映射（Map）等集合。\n实现 Parcelable 协议的类。\n\n\n\n\n作用\n\nAIDL 编译器自动为开发者生成 Java 代码。这些代码处理进程间通信（IPC）的细节，确保接口中的方法调用能够正确地分发并在目标远程进程中执行。\n当调用生成代码中的某个方法时，它会使用 Binder 框架 与远程进程通信。Binder 框架确保方法调用被正确传递到目标位置，并在需要时返回结果。\nBinder 提供了底层的 IPC 机制。AIDL 简化了 Binder 的使用，开发者通过定义熟悉的接口，而无需直接处理复杂的 IPC 细节。AIDL 自动处理大部分 IPC 的实现。\n\n\n与 Messenger 相比：\n\n支持复杂接口。\n性能高，多线程支持多客户端访问。\n支持自定义数据类型。\n支持双向通信和回调。\n\n\n\n J.  IPC 进程间通信\n\n\n每个进程有自己的地址空间，提供数据隔离。\n\n\nIPC 用于实现模块化，但需要克服跨进程直接交互的限制。\n\n\nBinder作为Android的IPC核心，支持远程过程调用和数据传输。\n\nBinder简化了进程间通信。Binder是Android的底层IPC机制，通过数据打包和解包实现安全通信。\n使用 AIDL 定义通信接口，通过代理 (proxy) 和存根 (stub) 实现高效的组件交互。\n内容：\n\n调用 (Calls)： 支持一对一和一对多的简单进程消息传递（单向或双向）。\n身份识别 (Identifying)： 管理进程 ID（PID）和用户 ID（UID）。\n管理 (Managing)： 提供引用计数和跨进程对象映射功能。\n间接功能：\n\n作为一个令牌（Token）。\n共享文件描述符（File Descriptor）以实现共享内存区域。\n\n\n线程管理：控制工作线程的休眠和唤醒。\n\n\n\n\n\nBinder 实现 (Binder Implementation)：\n\nAPI 层面：\n\n使用 AIDL 和 Java API 暴露 IBinder 接口。\n提供 Parcelable 接口用于对象的序列化和反序列化。\n\n\n中间件层：\n\n管理用户空间的 Binder 框架功能。\n处理数据的序列化/反序列化以及与内核驱动的交互。\n\n\n内核驱动层：\n\n通过 ioctl 系统调用支持中间件。\n实现跨进程文件操作和内存映射。\n为每个服务应用程序提供线程池。\n\n\n\n\n\nBinder 事务 (Binder Transactions)\n\n事务启动：进程 A 调用 IBinder.transact() 请求操作。\n事务处理：进程 B 的 Binder 对象通过 onTransact() 方法接收和处理请求。\n线程管理：每个进程的线程池处理所有 IPC 请求。\n阻塞与响应：发起请求的进程 A 在 transact() 调用期间阻塞，等待进程 B 返回结果。\n\n\n\nBinder 安全性\n\nBinder 本身不负责安全，但提供了可信执行环境。\n内核通过 UID/PID 管理客户端身份。\n\n\n\nBinder 性能\n\n显式限制：\n\n每个进程的事务缓冲区大小为 1MB，限制了并发事务的数据量。\n建议保持事务数据较小。\n\n\n隐式限制：\n\n数据传输需要复制，增加了内存资源的重复使用。\n不适合传输大规模数据流。\n\n\n优化方式：\n\n使用共享内存（如 Ashmem）传递大数据。\n\n\n\n\n\n k. 系统服务 (System Services)\n\n电源管理 (Power Manager)。\n包管理器 (Package Manager)。\n位置服务 (Location Manager)。\n通知管理器 (Notification Manager)。\n蓝牙服务 (Bluetooth Service)。\n音频服务 (Audio Service)。\n\n l. 服务管理器\n\n功能：\n\n跟踪和管理所有系统服务的引用。\n允许客户端通过服务名检索远程服务的 Binder 句柄。\n\n\n特性：\n\n首个通过 Binder 注册的服务。\n仅允许可信系统服务注册（如系统、媒体服务）。\n\n\n\n 3. Broadcast Receiver\n响应来自操作系统/其他应用程序的广播消息。\n 4. Content Provider\n使数据可供其他应用程序使用/利用来自其他应用程序的数据。\n 其他\n 1. Kotlin\nKotlin 是 2011 年 JetBrains 创建的语言。\n i. 为什么使用 Kotlin？\n\n现代语言特性。\n与 Java 的互操作性。\n提高开发人员的工作效率。\n\n ii. 为什么 Kotlin &gt; Java？\n\n简洁性 Conciseness\n\n显著减少样板代码 (boilerplate code)。\n例如 数据类自动生成 getter、setter 和其他实用方法\n\n\n安全功能 Safety Features\n\nNull Safety 空安全：在编译时消除 NullPointerException。\n\n默认情况下，变量不能为空值，除非显式声明为空。(加一个问号?)\n\n\nImmutability 不可变的：鼓励使用不可变的数据结构。\n\n默认情况下，Kotlin 提倡不可变性。\n被声明为 val 的变量是只读的，不能重新分配。\n这可以避免可变变量引起的意外副作用，从而使代码更安全。\n\n\n\n\n互操作性 Interoperability\n\n与现有 Java 代码无缝集成。\n允许从 Java 逐步迁移到 Kotlin。\n\n\n扩展方法\n\nKotlin 允许使用新功能扩展类，而无需从该类继承或使用 Decorator 等设计模式。\n\n\n\n iii. Coroutines 协程\n协程本质上是轻量级线程 (Lightweight Threads)。它们允许我们执行后台任务，而无需与传统线程相关的大量资源成本。协程是实现异步的一种方式。\n线程是由操作系统管理和调度的，而协程则是由程序代码自身进行管理和调度。\n与线程不同，协程由 Kotlin 运行时而不是操作系统管理，从而使其效率更高。\nSequential Asynchronous Code（顺序异步代码）：\n\n协程使异步代码看起来像同步代码，协程的特性允许我们以顺序的方式编写异步逻辑。\n这种顺序风格的代码更加直观，不会阻塞主线程，适用于高并发和 I/O 密集型任务。\n\n优点：\n\n协程支持非阻塞操作 (Non-blocking Code Execution)：\n\n在执行长时间运行的任务时，协程不会阻塞主线程，保持应用的响应能力\n非阻塞操作可以避免出现“应用无响应”（Application Not Responding，ANR）错误，这是移动应用开发中的常见问题。\n\n\n简化代码结构：\n\n避免嵌套回调和“回调地狱”（Callback Hell）。\n\n协程提供了更直观的方式来处理异步操作，而不需要依赖复杂的嵌套回调。\n\n\n以顺序方式编写代码：\n\n协程的代码结构更接近同步代码，简化了逻辑流程，提升了可读性和维护性。\n\n\n\n\n可扩展并发性 (Scalable Concurrency)\n\n高效处理多任务并发：协程能够高效地管理和执行大量并发任务，且资源开销极小。\n便于应用扩展：相比传统线程，协程更容易管理并发任务，尤其适用于需要高并发的场景。\n\n\n\n 2. Jetpack Compose\nJetpack Compose 是一个现代工具包，用于通过声明式方式构建原生 Android 用户界面。完全使用 Kotlin 构建，紧密集成，利用现代语言特性实现简洁和可表达的代码。\n是基于 Jetpack 的一个工具，基于模块化组件，组成成分有：\n\nFoundation：提供核心工具，例如AppCompat\nArchitecture：提供生命周期感知组件，例如 ViewModel, LiveData 和 Room\nUI：包括用于导航、Fragment和动画的工具。\nBehavior：提供后台任务和数据处理的工具。\n\n特性：\n\n使用 Kotlin 编写 UI 和业务逻辑，无需切换上下文。\n支持 实时预览 (Live Previews) 和 热重载 (Hot Reloading)，在开发过程中实时更新 UI。\n使用Composable 函数：通过函数式组件减少冗余代码。\n无需 XML 布局和 findViewById，可直接引用 UI 组件。\n\n优点：\n\n提高生产力 (Improved Productivity)\n\n减少样板代码：减少开发中的重复性代码，提高应用质量。\n直观的 API：采用声明式编程风格，学习曲线平滑，更易于掌握和使用。\n\n\n更高的性能 (Better Performance)：\n\n高效的渲染 (Efficient Rendering)：仅更新受影响的组件，避免不必要的重绘，从而提升性能。\n异步处理 (Asynchronous Handling)：提供流畅的 UI 交互体验，适配现代异步工作流。\n\n\n轻松集成 (Easy Integration)：\n\n与现有视图兼容 (Interoperable with existing Android views)\n向后兼容：支持旧版本的 Android，同时提供生命周期感知的功能。\n\n\n\n缺点：\n\n关注点分离减少 (Reduced Separation of Concerns)：\n\n在 Composable 函数中将布局和逻辑结合在一起，可能会模糊 UI 结构与功能代码之间的界限。\n这可能会增加隔离特定部分的难度。\n\n\n复杂 UI 中的复杂性增加 (Increased Complexity in Large UIs)：\n\n对于复杂的用户界面，将布局和内容结合在同一代码中，可能会导致函数变得庞大且难以阅读。\n开发者需要将 UI 拆分成更小、更可重用的组件以提高可读性。\n\n\n文件体积膨胀的可能性 (Potential for Large Files)：\n\n由于将 UI 和逻辑放在一起，文件可能变得非常庞大，尤其是在大型应用中。\n查找特定组件或逻辑可能会变得困难。\n\n\n\n i. Composable Function\n使用 @Composable 注解，用于定义 UI 组件。\n\n声明式 UI 定义：描述 UI 应该显示什么，而不是如何构建。\nComposable 函数可以嵌套，并组合起来构建复杂的用户界面。\n\nComposables 中管理状态：\n\n维护状态以跨越多次重组 (recomposition)。\n响应用户交互和数据变化，动态更新 UI。\n\n状态管理工具：\n\nremember：用于在相同的 Composable 中保持状态，避免因重组丢失数据。\nmutableStateOf：持有一个可变的值，当值发生变化时会触发 UI 的重新绘制 (recomposition)。\n\n 3. 零日攻击 (Zero-day Attack)\n零日攻击是一种利用软件漏洞的攻击行为，这些漏洞对于供应商或开发者来说是未知的。“零日”意味着开发者在漏洞被利用之前，没有任何时间（0天）来修复这个问题。\n特点：\n\n未被发现的漏洞 (Undetected Vulnerabilities)：\n\n攻击者利用在安全团队或开发人员发现之前存在的漏洞。\n这些漏洞通常处于未知状态，未被公开\n\n\n高风险 (High Risk)：\n\n在漏洞被修复之前，攻击者可能造成严重的损害。\n高危攻击可能泄露敏感信息、破坏系统或造成经济损失。\n\n\n隐蔽性 (Stealthy Nature)：\n\n零日攻击往往具有高度隐蔽性，通常在攻击发生后才被察觉。\n由于未被识别，受害者可能无法立即采取防御措施。\n\n\n\n 4. 线程执行\n I. 单线程模型：\n\n主线程 (Main Thread)：Android 应用程序默认使用单线程模型，所有组件（Activity、Service、BroadcastReceiver 等）都在主线程上运行。\n主线程启动时，负责处理：\n\n用户界面的绘制。\n响应用户交互事件（如 onClick()）。\n处理 Activity 生命周期事件（如 onCreate()、onDestroy()）。\n\n\n适合主线程的任务：\n\n短时间的 UI 更新。\n生命周期事件的调度。\n\n\n不适合主线程的任务：\n\n网络请求。\n文件读写。\n数据库操作。\n\n\n\n II. 线程管理：\n\n避免在主线程运行耗时任务：\n\nAndroid 会抛出 NetworkOnMainThreadException，阻止在主线程上执行网络操作。\n耗时任务会导致应用卡顿甚至无响应（ANR：Application Not Responding）。\n\n\n推荐的做法：\n\n使用辅助线程（如 Thread 或 ExecutorService）。\n使用异步工具类（如 AsyncTask，但已被弃用）。\n使用现代 Android 框架（如 Coroutines 或 WorkManager）。\n\n\n\n III. Looper and Handle\nHandlerThread：HandlerThread 是对普通线程的扩展，支持 Looper。它是一个后台线程，与主线程分离。提供一个线程，并自动管理与该线程相关的 Looper 和消息队列（MessageQueue）。通常用于在后台线程中处理任务。\nLooper：每个 HandlerThread 都包含一个 Looper，Looper 维护了一个消息队列（MessageQueue），用于管理事件队列。Looper.loop() 运行循环，从队列中取出消息并调度执行。\nMessage：消息是需要处理的任务，可以包含数据或者对某个 Runnable 对象的引用。是线程间通信的基础单元。消息队列中的每个消息会被 Looper 分发给相应的 Handler 进行处理。\nHandler：Handler 绑定到某个 Looper 上，负责与 Looper 的消息队列交互。用于向线程的消息队列发送消息或任务。常用于在辅助线程中执行任务后，将结果发送到主线程更新 UI。Handler 是线程安全的，可以从不同线程发送消息到绑定的 Looper。\n 代码相关\n 1. 活动类 AppCompatActivity\n\n生命周期管理：\n\n\n\n\n重写方法\n说明\n使用补充\n\n\n\n\nonCreate()\n创建时调用。是生命周期的起点。\n一般用于设计布局、初始化控件、配置数据等。\n\n\nonStart()\n启动时调用，即用户即将看到它，但还没有与用户互动时。\n\n\n\nonResume()\n即将于用户交互时调用。是活跃状态。\n\n\n\nonPause()\n失去焦点时调用。\n一般用于暂停动画、保存数据或释放资源。\n\n\nonStop()\n完全不可见时调用。比如说被另一个Activity全屏覆盖或应用被最小化。\n可以释放更多资源。\n\n\nonRestart()\n从停止变回可见状态时调用。此方法在onStart()之前被调用。\n常用于恢复onStop中被释放的资源。\n\n\nonDestory()\n被摧毁之前调用。是生命周期的终点。\n释放掉所有的资源.\n\n\n\n\n子活动相关：\n\n\n\n\n方法\n说明\n样例\n\n\n\n\nIntent getIntent()\n获取启动该活动的intent。没有则返回Null。\nvar intent = getIntent()\n\n\nregisterForActivityResult(ActivityResultContracts&lt;I, O&gt;, Callback&lt;O&gt;)\n用于注册ActivityResultLauncher&lt;Intent&gt;。\n\n\n\nsetRusult(RESULT, Intent)\n返回启动它的 Activity，并返回结果\nRESULT_OK: 操作成功RESULT_CANCELED：操作取消RESULT_FIRST_USER：自动定义结果代码\n\n\n\n\n其他辅助类：\n\n\n\n\n方法\n说明\n样例\n\n\n\n\nView findViewById()\n根据控件id寻找控件\nvar a = findViewById(R.id.a);\n\n\n\n 2. 视图类 View\n 列表视图 ListView\n 回收视图 RecyclerView\n可以动态创建并回收视图，提升性能。\n 3. 资源类 R\n\n\n\n子类\n说明\n样例\n\n\n\n\nlayout\n当前布局相关信息\nR.layout.activity_main\n\n\nid\n控件id相关\nR.id.buttonCalculate\n\n\n\n 4. 意图类 Intent\n用于给其他的 Activity 传递参数。\n\n\n\n方法\n说明\n样例\n\n\n\n\nputExtra(key, value)\n传递数据。\nintent.putExtra(&quot;result&quot;, 10);\n\n\ngetStringExtra(key)\n根据key获取字符串数据。\nname = intent.getStringExtra(&quot;name&quot;);\n\n\n\n\n父类打开子类，并返回给子类信息。\n子类返回父类，并返回给父类信息。\n需要用到 startActivityForResult(Intent, int)，或者 Activity Result API 的 ActivityResultLauncher 打开子活动。\n\n","slug":"笔记/笔记-安卓开发","date":"2024-10-31T22:58:02.000Z","categories_index":"笔记","tags_index":"JAVA,Android","author_index":"zExNocs"},{"id":"24ad0055d0e4d9377d4df87cbfd9108d","title":"笔记-LaTeX","content":" 一. 模板\n使用 \\documentclass[option]&#123;template&#125;\noption一般表示文字编码，例如 [UTF8]\ntemplate表示模板\n\n\n\n模板\n介绍\n\n\n\n\nreport\n报告\n\n\narticle\n文章\n\n\nctexart\n支持中文的文章\n\n\nctexbook\n支持中文的书\n\n\n\n使用 \\begin&#123;document&#125; 和 \\end&#123;document&#125; 块内表示文件开始和结束\n 二. 包\n使用 \\usepackage&#123;package&#125; 来导入包\n\n\n\n包名\n介绍\n补充\n\n\n\n\ngraphicx\n图片\n使用\\includegraphics[param]&#123;filename&#125;导入图片具体见下方的七. 图片相关\n\n\n\n 三. 标题\n\n\n\n代码\n解释\n补充\n\n\n\n\n\\titile&#123;&lt;&gt;&#125;\n文章标题\n\n\n\n\\author&#123;&lt;&gt;&#125;\n文章作者\n\n\n\n\\date&#123;param&#125;\n文章日期\n\\today 今天\n\n\n\n 四. 格式化命令\n\n\n\n代码\n解释\n\n\n\n\n\\textbf&#123;&lt;&gt;&#125;\n文字加粗\n\n\n\\textit&#123;&lt;&gt;&#125;\n文字斜体\n\n\n\\underline&#123;&lt;&gt;&#125;\n下划线\n\n\n\n 五. 排版\n\n\n\n代码\n解释\n补充\n\n\n\n\n\\part\n部\n在 book 模板中使用\n\n\n\\chapter\n章\n在 book 模板中使用\n\n\n\\section&#123;&lt;&gt;&#125;\n章节\n\n\n\n\\subsection&#123;&lt;&gt;&#125;\n子章节\n\n\n\n\\subsubsection&#123;&lt;&gt;&#125;\n三级章节\n\n\n\n\n 六. 环境\n环境指的是使用 \\begin&#123;name&#125; 和 \\end&#123;name&#125; 嵌套的代码。\n环境内部的文字使用同一种格式。\n\n\n\n环境\n解释\n补充\n\n\n\n\nfigure\n图片环境\n具体看图片相关\n\n\nitemize\n无序bullet列表\n使用\\item表示一个元素\n\n\nenumerate\n有序bullet列表\n使用\\item表示一个元素\n\n\ntable\n表格环境\n具体查看八. 表格相关\n\n\ntabular\n表格内容\n具体查看八. 表格相关\n\n\nequation\n公式环境\n可以简写为\\[ 和 \\]具体查看九. 数学公式相关\n\n\n\n 七. 图片相关\n使用 \\includegraphics[param]&#123;filename&#125; 的方式导入图片。其中param可以有：\n\n\n\n参数\n解释\n补充\n\n\n\n\nwidth=x\n将图片宽度设置为x\n可以是 x\\textwidth，表示原本大小的 x 倍\n\n\nheight=x\n将图片高度设置为 x\n一般高度和宽度选择最小的修改\n\n\n\n此外，可以使用 figure 嵌套，在内部可以使用：\n\n\n\n代码\n解释\n\n\n\n\n\\caption\n图片标题\n\n\n\\centering\n图片居中\n\n\n\n 八. 表格相关\n使用 \\begin&#123;table&#125; 和 \\end&#123;table&#125; 规定表格环境。在内部可以使用：\n\n\\center 表格居中\n\\caption&#123;anything&#125; 表格标题\n\n使用 \\begin&#123;tabular&#125;&#123;param&#125; 和 \\end&#123;tabular&#125; 环境嵌套表格内容。\n\nparam 表示表格的列的数量和格式:\n\n\n\n\n参数\n解释\n补充\n\n\n\n\nl\n左对齐。\n会添加新的一列。\n\n\nc\n居中。\n会添加新的一列。\n\n\nr\n右对齐。\n会添加新的一列。\n\n\np&#123;width&#125;\n设置列宽\n例如p&#123;2cm&#125;会添加新的一列。\n\n\n|\n表格绘制竖边框\n不会添加新的一列。\n\n\n\n\n使用 &amp; 隔开不同列之间。\n使用 \\\\ 隔开不同行之间。\n使用 \\hline 绘制水平方向的边框\n\n 九. 数学公式相关\n\n\n行内公式\n行内公式使用 $&lt;&gt;$ 嵌套公式\n\n\n行外公式\n使用 \\begin&#123;equation&#125; 和 \\end&#123;equation&#125; 环境嵌套。\n\n\n运算符号：\n\n\n\n代码\n解释\n补充\n例子\n\n\n\n\n\\over\n分数形式呈现\n\n1 \\over 2 →\\to→ 121 \\over 221​\n\n\n\n","slug":"笔记/笔记-LaTeX","date":"2024-10-25T23:33:20.000Z","categories_index":"笔记","tags_index":"LaTeX","author_index":"zExNocs"},{"id":"75074d75debd3a13d00431331559c0a9","title":"MC插件开发对项目和游戏引擎设计的思考","content":" 🔖介绍\n\n 1. 游戏阶段树 (场景)\n\n 2. 事件与其观察者\n\n 3. 依赖注入(Dependency Injection) 和 控制反转(Inversion of Control，IoC)\n依赖注入是一种软件设计模式，用于实现控制反转，从而实现对象之间的解耦和提高代码的可测试性和可维护性。它的核心思想是将对象的依赖关系从对象内部转移到外部管理（通常是一个容器或框架）。\n依赖注入常见的三种方式：\n\n构造函数注入\n方法注入：setter\n属性注入：通常使用反射或注解实现(@Inject)\n\n优点：\n\n解耦\n提高测试性：可以通过mock简化单元测试\n增加灵活性：可以通过简单替换依赖的类来扩展不同实现的版本\n\n\n 4. 组合大于继承\n","slug":"随笔/随笔-MC插件开发对游戏引擎设计的思考","date":"2024-10-18T15:04:02.000Z","categories_index":"随笔","tags_index":"game engine","author_index":"zExNocs"},{"id":"a4898085ad7e33e4bdefd0d828d621b7","title":"SAI - Symbolic Artificial Intelligence 符号人工智能","content":" ✒️背景\n 🔖介绍\n 一. 符号人工智能(Symbolic AI, SAI)的介绍\n 1. 符号人工智能的基本组成成分\n\n\n\n\n\n\n\n\n\nHow can knowledge be represented symbolically and manipulated in an automated way by reasoning programs.\n如何用符号来表示知识，并通过推理程序以自动化的方式进行操控知识。\n\nKnowledge 知识: 这个世界的任何信息。\n\n例如关于某些特定疾病的医疗信息：导致这些疾病的原因、如何诊断。\n必须是显性的 (explicitly)，因此输入是固定形式的。\n符号AI的核心就是通过符号来表示这些知识。符号可以是文字、数字或其他抽象符号，它们用来表示实体和概念。\n\n\nRepresentation 代表: 如何用/使用哪一种语言代表这些信息。\nReasoning 推理: 如何从明确表示的内容中提取更多信息。\n\n负责根据预定义的规则或逻辑对输入进行推理，生成结论。\n都是形式推理的(Formal Reasoning)，是基于一定规则通过逻辑推导来完成的。\n类型：\n\n归结推理(Resolution Reasoning)\n演绎推理(Deductive Reasoning)\n归纳推理(Inductive Reasoning)\n溯因推理(Abductive Reasoning)\n\n\n\n\n\n符号人工智能又称为基于规则的人工智能，是一种通过符号表示和逻辑推理来模拟人类的人工智能技术。它依赖于明确的、可解释的规则和逻辑系统来处理问题和推理。符号AI则依赖于人类预先定义的规则和知识库。\n 2. 知识型系统 (Knowledge-Based System, KB-System)\n\n知识型系统(Knowledge-Based System)是包含知识符号表示的系统，用于推理。\n知识的符号代表常称为知识库(Knowledge Base)。\n\n知识库是存储系统已知信息的地方，通常以规则、事实、对象及其关系等形式组织。\n知识库需要人工构建和维护，通常是通过专家将领域知识转化为可操作的规则。\n\n\n知识型系统不包含解释(interpretation)，因此推理(reasoning)并不是基于特定解释的。\n\n知识型系统主要是对解释进行约束，也可以说 KB 是一个语句集合，在 KB-System 中假设 KB 是真的。\n推理可以通过蕴含(entailment)进行，即该解释必须满足某些语句 SSS。\n\n推理的例子：如果我们知道 Fido 是一条狗，所有狗都是哺乳动物，因此Fido是哺乳动物。\n\n\n如果 KB⊨αKB \\models \\alphaKB⊨α，那么 α\\alphaα 必须为 TrueTrueTrue\n\nKBKBKB 是显性(explicit)知识\nα\\alphaα 是隐性(implicit)知识\n隐形知识的提取并不简单\n\n\n\n\n知识型系统包含两个部分：\n\n具有显性知识的KBKBKB，由用户指定或者自动学习。\n推理引擎(Inference engine)，利用推理过程从知识库自动提取隐性知识。\n\n推理引擎通常会被赋予一个假设，并尝试证明或者反驳它。\n\n\n\n\n\n 3. 符号人工智能和非符号人工智能(Non-symbolic AI, NSAI)的对比\n\n\n\n\n符号人工智能\n非符号人工智能\n\n\n\n\n求解\n数据和规则都是显示的(explicitly)\n模型是隐式的(implicit)\n\n\n来源\n模型都是由人类提供的\n模型都是根据模式观察自动从数据提取的\n\n\n推理\n形式推理\n统计或隐式推理\n\n\n优点\n1. 可解释性强2. 适合底数据依赖场景\n1. 处理不确定性能力强2.学习能力强\n\n\n局限\n1. Rigid model，难以更新2. 输入必须明确3.有些任务难以形式化\n1.难以或不可能解释2.可能存在一些事情不可能解决?\n\n\n\n尽管NSAI在如今更流行，但是SAI依然在被广泛应用。它们之间并没有直接的可比性，都具有优缺点。\n 二. 知识(Knowledge)\n为了形式化知识和推理，我们需要一个形式语言来描述知识。有很多种方法来描述知识\n 1. 一阶逻辑 (First Order Logic, FOL)\n一阶逻辑 (First Order Logic, FOL) 是声明性语言 (Declarative Language)，是一种知识类型。\nTIP: 使用声明式语言编写的程序描述了问题的逻辑结构或解决问题的目标，而不必明确地规定如何逐步执行这个目标的细节步骤，是高度抽象的。与其相对的是命令式语言，命令式语言程序员需要明确地定义执行过程的每一步。\n\n\n特点：\n\n精确(Precise)\n\n与模糊逻辑(fuzzy logic)不同，每个事实只能是true或false。\n定义哪些字符串是有效语句(syntax)和如果它们为true意味着什么(semantics)。\n\n\n抽象(abstract)\n\n该语言使用抽象符号，例如 xxx。\n与自然语言(如英语)不同，不直接描述自然现象。这些符号与现实世界现象的映射取决于用户。\n\n\n\n\n\n例子：\n\nDog(fido) ∧ Cat(fido)Dog(fido)\\ \\land\\ Cat(fido)Dog(fido) ∧ Cat(fido)\nDog(x)→Animal(x)Dog(x) \\to Animal(x)Dog(x)→Animal(x)\n∃x,Dog(x)∧Lovely(x)\\exist x, Dog(x)∧Lovely(x)∃x,Dog(x)∧Lovely(x)\n\n\n\n I. 基础定义：数据类型、字母表\n\n\n数据类型 (Type)：\n\nBoolean 布尔。\n\n其变量通常叫做 命题变量符号 (元数为 0 的谓词符号)，因此本文中下述所有的&quot;变量&quot;都表示非布尔变量。\n操作符：通常使用 ∧,∨,¬\\land, \\lor, \\neg∧,∨,¬ 。\n\n\nDomain of discourse (domain) 论域。\n\n表示非布尔类型的，可以为数字。\n操作符：通常用量词 ∀,∃,=\\forall, \\exist, =∀,∃,=，并且可以作为谓词或者函数的参数传递。\n\n\n\n\n\n字母表 (Alphabet)：\n\n逻辑符号\n\n域元素(变量): 通常用小写字母表示，如 x,y1,z3,8x, y_1, z_{3, 8}x,y1​,z3,8​ (仅限 domain)。可以是数字。\n\n域元素通常使用等式 === 或者 谓词符号 转化成布尔。\n\n\n量词：∀,∃\\forall, \\exist∀,∃ (仅限 domain)，后面跟着的表达式(必须是公式表达式)通常包含谓词和函数。\n\n简单说，后面要跟布尔(包含谓词和函数的公式表达式)而不能跟变量。\n\n\n等号：===，比较 domain 中的元素 (仅限 domain)。\n\n简单说，布尔是没有相等这个说法的，两边一定是变量。\n布尔的相等往往是使用   ⟺  \\iff⟺ 或者 ≡\\equiv≡。\n\n\n逻辑连接: ∧,∨,¬,→,  ⟺  \\land, \\lor, \\neg, \\to, \\iff∧,∨,¬,→,⟺。\n\n简单说，只能两个布尔使用逻辑连接，而不能用变量。\n\n\n括号: (,),{,},[,](, ), \\{, \\}, [, ](,),{,},[,]。\n\n\n非逻辑符号 (仅限 domain，使用 domain 作为参数)\n\n谓词符号(predicate)：返回布尔值的函数。通常以大写字母表示，例如 P(x),Q,IsTasty(y)P(x), Q, \\text{IsTasty}(y)P(x),Q,IsTasty(y)。\n\n简单说，是将一个变量转化成布尔。\n\n\n函数符号(function)：返回域元素的函数。通常用小写字母表示，例如 f(x),g,madeOf(y)f(x), g, \\text{madeOf}(y)f(x),g,madeOf(y)。\n\n简单说，是将一个变量转化成另一个变量。\n\n\n特点：非逻辑符号都具有元数(arity)，即参数的数量。\n\n元数为 0 的谓词(predicate)称为命题变量(propositional variables)，取值为 ‘true’ 或 ‘false’。\n元数为 0 的函数(function)被称为常量符号(constant symbols)，它们代表域元素(domain element)，例如 字符串&quot;Cat&quot;, 数字73。\n元数为 0 的谓词和函数通常跳过括号，即不使用 P(),f()P(), f()P(),f()，而是 P,fP, fP,f。\n\n\n\n\n\n\n\n II. 完善公式 (Well-Formed Formulas, WFF)\n并不是所有的字母表排序都是有意义的，例如 ¬∧x∀\\neg \\land x \\forall¬∧x∀ 是无意义的语句。\n而有效排序的公式我们称为 完善公式 (Well-Formed Formulas, WFF)。\n完善公式的形式规则(Formation Rules)/语法(grammar)是其通过 公式 和 项 归纳定义：\n\n项(Term)：是返回 域元素 的表达式。\n\n归纳定义：\n\n一个域元素/变量是项，例如整型 xxx。\n形式为 f(t1,t2,...,tn)f(t_1, t_2, ..., t_n)f(t1​,t2​,...,tn​) 的表达式是项。其中 tit_iti​ 是一个项，fff 是元数为 nnn 的函数符号 (包括常量)。\n其值取决于量词符号或者变量分配 di=μ[ti]d_i = \\mu[t_i]di​=μ[ti​]。\n\n\n单个项不属于WFF。\n简单说，就是输出为变量的表达式。\n\n\n公式(Formula)：是返回 布尔值 的表达式。\n\n归纳定义为：\n\n形式为 P(t1,t2,...,tn)P(t_1, t_2, ..., t_n)P(t1​,t2​,...,tn​) 的表达式是公式。其中 tit_iti​ 是一个项，PPP 是一个元数为 nnn 谓词符号。\n¬α\\neg \\alpha¬α 是公式。其中 α\\alphaα 是公式。\nt1=t2t_1 = t_2t1​=t2​ 是公式。其中 t1,t2t_1, t_2t1​,t2​ 是项(不是公式)。\n\n例如 A=B(x)A = B(x)A=B(x) 不是公式也不是项，即不是WFF。因为 A,B(x)A, B(x)A,B(x) 都是公式，而等号是项之间的。\n简单说，就是只能变量相等，而不能布尔相等。\n\n\nα∧β,α∨β,α→β,α  ⟺  β\\alpha \\land \\beta, \\alpha \\lor \\beta, \\alpha \\to \\beta, \\alpha \\iff \\betaα∧β,α∨β,α→β,α⟺β 是公式，其中 α,β\\alpha, \\betaα,β 是公式。\n\n简单\n\n\n∀x,α\\forall x, \\alpha∀x,α 和 ∃x,α\\exist x, \\alpha∃x,α 是公式，其中 xxx 是变量名字，α\\alphaα 是公式(不是项)。\n\n简单说，后面只能跟布尔(一般是包含谓词的表达式)。\n\n\n\n\n公式属于WFF。\n简单说，就是输出为布尔的表达式。\n\n\n\n III. 变量的范围(scope)\n在FOL中，域元素/变量可以是自由的(free)，也可以是绑定的(bound)：\n\n绑定的(bound)变量由 量词 定义，例如 ∀x,P(x)\\forall x, P(x)∀x,P(x) 中的 xxx。\n自由的(free)变量在公式之外定义（它们的值是给定的），例如 P(x)∧Q(x)P(x) \\land Q(x)P(x)∧Q(x) 中的 xxx。\n\n变量的范围(scope)是公式中变量可使用的范围。其中绑定的变量只能在该量词的范围内访问。\n例如 P(x)∨∃y,Q(y)∧R(x,y)P(x) \\lor \\exist y, Q(y) \\land R(x, y)P(x)∨∃y,Q(y)∧R(x,y) 中，xxx 是自由的，其范围是整个表达式；而 yyy 是绑定的，其作用范围是 ∃y,Q(y)∧R(x,y)\\exist y, Q(y) \\land R(x, y)∃y,Q(y)∧R(x,y)。\nTIP: 如果变量名被重复利用，其一般使用的是最内层的定义。例如 P(x)∨∃xQ(x)P(x) \\lor \\exist x Q(x)P(x)∨∃xQ(x) 中 有两个 xxx，其中 P(x)P(x)P(x) 的 xxx 是自由的，而 Q(x)Q(x)Q(x) 的 xxx 是绑定的。\n IV. WFF语句 (Sentences)\n\n\n\n\n\n\n\n\n\nA WFF that does not have free variables is called sentence.\n不存在自由变量的WFF被称为语句。\n要将带有自由变量的公式转换为句子，我们需要为该公式中的每个自由变量替换值。\n一般称这个公式为变量分配(variable assignment) μ\\muμ，μ[ti]\\mu[t_i]μ[ti​] 表示 项 tit_iti​ 在 μ\\muμ 的分配下转化的具体值。\n例如在 x=1x = 1x=1 中，xxx 是项 tit_iti​，di=μ[ti]=1d_i = \\mu[t_i] = 1di​=μ[ti​]=1 是分配的值。\n语句 α\\alphaα 可被分类为：\n\n不可满足的(Unsatisfiable)：不存在解释使得 α\\alphaα 满足。\n可满足的(Satisfiable)：存在至少一个解释使得 α\\alphaα 满足。\n非有效的(Not valid)：存在至少一个解释 α\\alphaα 不满足。\n有效的(Valid)：对于所有的解释都可以使 α\\alphaα 满足。\n\n 有效性和可满足性之间的关系和转换\n对于 α=¬β\\alpha = \\neg \\betaα=¬β：\n\n如果 α\\alphaα 是可满足的，那么 β\\betaβ 是非有效的。\n如果 α\\alphaα 是不可满足的，那么 β\\betaβ 是有效的。\n如果 α\\alphaα 是有效的，那么 β\\betaβ 是不可满足的。\n如果 α\\alphaα 是非有效的，那么 β\\betaβ 是可满足的。\n\n语句是一个特殊的公式(formula)。\n V. FOL语义 (Semantics) 和 逻辑解释 (Logical interpretation)\n\n\n\n\n\n\n\n\n\nSemantics is concerned with the meaning of sentences (but not the mapping to real world).\n语义关注的是句子的意义（而不是与现实世界的映射）\n其中FOL语义是有关非逻辑符号的全部信息（从 domain 转化成 domain 或者 布尔 的全部信息），从而用于评估 FOL 句子为 True 或 False。\n其中逻辑解释(Logical interpretation)定义了FOL的语义。定义如下：\n解释 J\\mathcal{J}J 是一个pair &lt;D,I&gt;\\mathcal{&lt;D, I&gt;}&lt;D,I&gt;，其中\n\nD\\mathcal{D}D 是域(domain of discourse/domain)的非空集合。\n\n对于常量项 ttt，那么始终符合 t∈Dt \\in \\mathcal{D}t∈D。\n对于变量项 ttt，其经过任意映射得到取值 ddd，始终符合 d∈Dd \\in \\mathcal{D}d∈D。\n对于函数 ttt，其参数的集合为 S={t0,t1,...,tn}S = \\{t_0, t_1, ..., t_n\\}S={t0​,t1​,...,tn​} 始终符合 S⊆DS \\subseteq \\mathcal{D}S⊆D，且 t∈Dt \\in \\mathcal{D}t∈D。\n\n\nI\\mathcal{I}I 是非逻辑符号解释函数，一般如下定义：\n\n对于一个元数为 nnn 的函数符号 fff 来说：\nI[f]:D×D×D×⋯×D⏟n times→D\\mathcal{I}[f] : \\underbrace{\\mathcal{D \\times D \\times D \\times \\cdots \\times D}}_{n \\text{ times}} \\to \\mathcal{D}\nI[f]:n timesD×D×D×⋯×D​​→D\n\n如果 n=0n = 0n=0，那么 I[f]∈D\\mathcal{I}[f] \\in \\mathcal{D}I[f]∈D\n简单说，就是这些函数经过每个可能的参数都可能会返回哪些域元素。\n\n\n对于一个元数为 nnn 的谓词符号 PPP 来说，I[P]\\mathcal{I[P]}I[P] 可以看做一个映射(mapping)：\nI[P]:D×D×D×⋯×D⏟n times→{True, False}\\mathcal{I}[P] : \\underbrace{\\mathcal{D \\times D \\times D \\times \\cdots \\times D}}_{n \\text{ times}} \\to \\{\\text{True, False}\\}\nI[P]:n timesD×D×D×⋯×D​​→{True, False}\n\n简单说，就是这些谓词符号经过哪些参数可以满足。\n\n\n对于一个元数为 nnn 的谓词符号 PPP 来说，I[P]\\mathcal{I[P]}I[P] 也可以被视为一个关系(relation):\n\nI⊆D×D×D×⋯×D⏟n times\\mathcal{I} \\subseteq \\underbrace{\\mathcal{D \\times D \\times D \\times \\cdots \\times D}}_{n \\text{ times}}\nI⊆n timesD×D×D×⋯×D​​\n\n如果存在关系元素 a∈Ia \\in \\mathcal{I}a∈I，认为 aaa 可以使谓词符号 PPP 满足。\n\n\n\n简单说，D\\mathcal{D}D 就是域元素的集合，I\\mathcal{I}I 就是谓词和函数对应的真值表和输出表。\n也就是说，如果要判断一个FOL语句是 True 还是 False，只需要知道：\n\ndomain 元素的集合。\n哪些输入满足谓词符号。\n对于每个可能的输入，每个函数返回哪个 域元素。\n\n如果 ttt 是一个项，那么 d=J[t]d = \\mathcal{J}[t]d=J[t] 为：\n\n对于常量项 ttt，d=td = td=t。\n对于变量项 ttt，即 ttt 是一个自由的变量，那么此时取决于变量分配 d=μ[t]d = \\mu[t]d=μ[t]。\n对于函数 ttt，假设 t=f(t0,t1,...,tn)t = f(t_0, t_1, ..., t_n)t=f(t0​,t1​,...,tn​)，那么 d=I[f](J[t0],J[t1],...,J[tn])d = \\mathcal{I}[f](\\mathcal{J}[t_0], \\mathcal{J}[t_1], ..., \\mathcal{J}[t_n])d=I[f](J[t0​],J[t1​],...,J[tn​])。\n\n一个 J=&lt;D,I&gt;\\mathcal{J} = \\mathcal{&lt;D, I&gt;}J=&lt;D,I&gt; 的图例：\n\n 可满足性(Satisfaction)\n一个语句的可满足性取决于其解释。\n 可满足性的定义：\n\n如果α\\alphaα 是一个语句(没有自由变量)，对于某个解释 J\\mathcal{J}J 如果可以使 α\\alphaα 满足，那么可以写作：\n\nJ⊨α\\mathcal{J} \\models \\alpha\nJ⊨α\n\n如果 α\\alphaα 是一个有自由变量的公式，满足性取决于变量分配 μ\\muμ，那么可以写作：\n\nJ,μ⊨α\\mathcal{J}, \\mu \\models \\alpha\nJ,μ⊨α\n称 α\\alphaα 是由 J\\mathcal{J}J 和 μ\\muμ 满足的。\n\n对于某个解释 J\\mathcal{J}J 或者 J,μ\\mathcal{J}, \\muJ,μ，如果 J,μ⊨α\\mathcal{J}, \\mu \\models \\alphaJ,μ⊨α 且 α∈S\\alpha \\in Sα∈S ，那么可以写作：\n\nJ⊨S\\mathcal{J} \\models S\nJ⊨S\nJ,μ⊨S\\mathcal{J}, \\mu \\models S\nJ,μ⊨S\n\n如果 J\\mathcal{J}J 或者 J,μ\\mathcal{J}, \\muJ,μ 不可以使某一个语句或者集合满足，那么就可以用 ⊭\\not\\models⊨ 符号。\n\n简单说，就是添加的断言，断言在这个模型下语句恒成立。\n 可满足性的规则：\n假设 PPP 是一个元数为 nnn 的谓词符号，tit_iti​ 为一个项(term)，公式中 di=μ[ti]d_i = \\mu[t_i]di​=μ[ti​]，即did_idi​ 在 μ\\muμ 下的变量分配； α,β\\alpha, \\betaα,β 是一个公式，xxx 是一个变量，那么有规则：\n\n谓词的解释：J,μ⊨P(t1,t2,...,tn)  ⟺  &lt;d1,d2,...,dn&gt;∈I[P]\\mathcal{J}, \\mu \\models P(t_1, t_2, ..., t_n) \\iff &lt;d_1, d_2, ..., d_n&gt; \\in \\mathcal{I}[P]J,μ⊨P(t1​,t2​,...,tn​)⟺&lt;d1​,d2​,...,dn​&gt;∈I[P]\n\n简单说，就是断言 P(t1,t2,...,tn)P(t_1, t_2, ..., t_n)P(t1​,t2​,...,tn​) 成立，那么对于 PPP 就存在一个映射 (d1,d2,...,dn)→True(d_1, d_2, ..., d_n) \\to True(d1​,d2​,...,dn​)→True。\n\n\n相等解释：J,μ⊨(t1=t2)  ⟺  (d1=d2)\\mathcal{J}, \\mu \\models (t_1 = t_2) \\iff (d_1 = d_2)J,μ⊨(t1​=t2​)⟺(d1​=d2​)\n否定解释：J,μ⊨¬α  ⟺  J,μ⊭α\\mathcal{J}, \\mu \\models \\neg\\alpha \\iff \\mathcal{J}, \\mu \\not\\models \\alphaJ,μ⊨¬α⟺J,μ⊨α\n合取解释：J,μ⊨(α∧β)  ⟺  J,μ⊨α and J,μ⊨β\\mathcal{J}, \\mu \\models (\\alpha \\land \\beta) \\iff \\mathcal{J}, \\mu \\models \\alpha \\text{ and } \\mathcal{J}, \\mu \\models \\betaJ,μ⊨(α∧β)⟺J,μ⊨α and J,μ⊨β\n\n简单说就是断言 α∧β\\alpha \\land \\betaα∧β 成立相当于断言 α\\alphaα 成立 且断言 β\\betaβ 成立。\n\n\n析取解释：J,μ⊨(α∨β)  ⟺  J,μ⊨α or J,μ⊨β\\mathcal{J}, \\mu \\models (\\alpha \\lor \\beta) \\iff \\mathcal{J}, \\mu \\models \\alpha \\text{ or } \\mathcal{J}, \\mu \\models \\betaJ,μ⊨(α∨β)⟺J,μ⊨α or J,μ⊨β\n存在量词解释：J,μ⊨∃x,α  ⟺  ∃d,μ[x]=d→J,μ⊨α\\mathcal{J}, \\mu \\models \\exist x, \\alpha \\iff \\exist d, \\mu[x] = d \\to \\mathcal{J}, \\mu \\models \\alphaJ,μ⊨∃x,α⟺∃d,μ[x]=d→J,μ⊨α\n全称量词解释：J,μ⊨∀x,α  ⟺  ∀d,μ[x]=d→J,μ⊨α\\mathcal{J}, \\mu \\models \\forall x, \\alpha \\iff \\forall d, \\mu[x] = d \\to \\mathcal{J}, \\mu \\models \\alphaJ,μ⊨∀x,α⟺∀d,μ[x]=d→J,μ⊨α\n\n 逻辑蕴含(Logical Entailment)\n如果 SSS 是一个语句的集合，α\\alphaα 是一个句子，如果 ∀J,J⊨S→J⊨α\\forall \\mathcal{J}, \\mathcal{J} \\models S \\to \\mathcal{J} \\models \\alpha∀J,J⊨S→J⊨α，那么称\n\nα\\alphaα 是 SSS 的逻辑结果(logical consequence)\nSSS 逻辑蕴含(entail) α\\alphaα\nS⊨αS \\models \\alphaS⊨α\n简单说，就是可以由 SSS 推导出 α\\alphaα 成立。\n\n如果 S={α1,α2,...,αn}S = \\{\\alpha_1, \\alpha_2, ..., \\alpha_n\\}S={α1​,α2​,...,αn​}，那么 α1∧α2∧...∧αn→α\\alpha_1 \\land \\alpha_2 \\land ... \\land \\alpha_n \\to \\alphaα1​∧α2​∧...∧αn​→α 恒成立。\n如果 S⊨αS \\models \\alphaS⊨α，那么 S∧¬αS \\land \\neg\\alphaS∧¬α 是不可满足的。\n如果 S⊭αS \\not\\models \\alphaS⊨α，那么 S∧¬αS \\land \\neg\\alphaS∧¬α 是可满足的。\n\n证明\n如果 S⊨αS \\models \\alphaS⊨α，即 ∀J,J⊨S→J⊨α\\forall \\mathcal{J}, \\mathcal{J} \\models S \\to \\mathcal{J} \\models \\alpha∀J,J⊨S→J⊨α。\n即 ¬¬∀J,J⊨S→J⊨α\\neg\\neg\\forall \\mathcal{J}, \\mathcal{J} \\models S \\to \\mathcal{J} \\models \\alpha¬¬∀J,J⊨S→J⊨α\n即 ¬∃J,J⊨S∧J⊨¬α\\neg\\exists \\mathcal{J}, \\mathcal{J} \\models S \\land \\mathcal{J} \\models \\neg \\alpha¬∃J,J⊨S∧J⊨¬α\n即 ¬∃J,J⊨S∧¬α\\neg\\exists \\mathcal{J}, \\mathcal{J} \\models S \\land \\neg \\alpha¬∃J,J⊨S∧¬α\n也就是说 S∧¬αS \\land \\neg \\alphaS∧¬α 不可满足。\n\n\n\n如果 α\\alphaα 是有效的(valid)，那么有：\n\n∅⊨α\\varnothing \\models \\alpha\n∅⊨α\n此时也可以写作 ⊨α\\models \\alpha⊨α；非有效的则是 ⊭α\\not\\models\\alpha⊨α\n根据此也可以简化 {α1,α2,...,αn}⊨α\\{\\alpha_1, \\alpha_2, ..., \\alpha_n\\} \\models \\alpha{α1​,α2​,...,αn​}⊨α 为 ⊨α1∧α2∧...∧αn→α\\models \\alpha_1 \\land \\alpha_2 \\land ... \\land \\alpha_n \\to \\alpha⊨α1​∧α2​∧...∧αn​→α\n\n如果集合 SSS 是不可满足的(unsatisfiability)，那么有\n\nS⊨FalseS \\models \\text{False}\nS⊨False\n 蕴含和可满足性之间的转化\n如果 S⊨αS \\models \\alphaS⊨α，那么 S∧¬αS \\land \\neg \\alphaS∧¬α 是不可满足的；反之亦然。\n如果 S⊭αS \\not\\models \\alphaS⊨α，那么 S∧¬αS \\land \\neg \\alphaS∧¬α 是可满足的；反之亦然。\n 蕴含和有效性之间的转化\n如果 S→αS \\to \\alphaS→α 是有效的，那么 S⊨αS \\models \\alphaS⊨α。\n如果 S→αS \\to \\alphaS→α 是非有效的，那么 S⊭αS \\not \\models \\alphaS⊨α\n如果 $$\n 可满足性总结\n\n\n\n概念\n符号\n定义\n\n\n\n\n满足性  Satisfaction\nJ,μ⊨α\\mathcal{J}, \\mu \\models \\alphaJ,μ⊨α\nα\\alphaα 被解释 J\\mathcal{J}J满足\n\n\n蕴含 Entailment\nS⊨αS \\models \\alphaS⊨α\nα\\alphaα 被每一个满足集合 SSS 的解释满足\n\n\n可满足的 Satisfiability\n-\n存在一个解释满足 α\\alphaα\n\n\n有效的 Validity\n⊨α\\models \\alpha⊨α\nα\\alphaα被每一个解释满足\n\n\n不被满足的 Unsatisfiability\nS⊨FalseS\\models \\text{False}S⊨False\n不存在解释使得α\\alphaα满足\n\n\n\n这几个之间问题是可以互相转化的。\n FOL知识库\nFOL不支持数据类型，只支持布尔和域值。但是可以使用谓词，如 Person(x)Person(x)Person(x)，表示 xxx 是一个人。\nreview: 知识库\n如果FOL知识库具有一个层级系统，例如 xxx 是一条狗，同时 xxx 是一个哺乳动物、动物，那么有：Dog(x),Mammal(x),Animal(x)Dog(x), Mammal(x), Animal(x)Dog(x),Mammal(x),Animal(x)。\n但是如果我们每对一个生物这样描述，所有层级都手动添加，会很耗时并且容易出现错误。\n因此我们添加如下的规则：\n\n∀x,Dog(x)→Mammal(x)\\forall x, Dog(x) \\to Mammal(x)∀x,Dog(x)→Mammal(x)\n∀x,Mammal(x)→Animal(x)\\forall x, Mammal(x) \\to Animal(x)∀x,Mammal(x)→Animal(x)\n\n VI. FOL的性质\n\nFOL 具有严谨性(Strictness)。以至于没有办法为规则设置例外。\nFOL 具有单调性(Monotonicity)。\n\n如果 S⊨αS \\models \\alphaS⊨α，那么 ∀β,S∪{β}⊨α\\forall \\beta, S \\cup \\{\\beta\\} \\models \\alpha∀β,S∪{β}⊨α\n\n\n\n 1. 默认假设 (Default assumptions)\n例如，如果说 TOM 是一只鸟，会假设 TOM 会飞。用 FOL 可以表示为 Bird(TOM),∀x.Bird(x)→Flies(x)Bird(TOM), \\forall x. Bird(x) \\to Flies(x)Bird(TOM),∀x.Bird(x)→Flies(x)。\n然而，如果 TOM 最近受了伤，可能就不会满足这个条件。这种假设叫做默认假设 (Default assumptions)。\n对于上述情况，我们的知识可以表示如下：任何鸟都可以飞，除非我们知道情况并非如此。\n∀x.Bird(x)∧¬Abnormal(x)→Fles(x)\\forall x. Bird(x) \\land \\neg Abnormal(x) \\to Fles(x)∀x.Bird(x)∧¬Abnormal(x)→Fles(x)\n作为人类，我们假设没有例外，除非明确声明 ¬Abnormal(x)\\neg Abnormal(x)¬Abnormal(x)，并且我们知道 Abnormal(x)Abnormal(x)Abnormal(x) 什么时候为真。\n然而这种假设无法用 FOL 表示。因为 Abnormal(x) 的解释可能是任意的。\n由于 FOL 的单调性，在给定知识库 S \\model \\alpha 后，我们引入了新的知识 β\\betaβ，依然无法反驳 α\\alphaα。但是我们想要的是非单调性的(non-monotonic logic)，也就是引入一些例外知识 β\\betaβ 让 α\\alphaα 不成立。\n 2. 默认推理 (Default Reasoning)\nFOL不支持非单调性，因此我们无法编码默认知识。\n有多种方法可以扩展 FOL，使其接受默认推理，包括：\n\n闭合世界推理（Closed-world reasoning）\n限制推理（Circumscription）\n默认逻辑（Default logic）\n\n I. 闭合世界推理（Closed-world reasoning）\n闭合世界假设：“如果 α\\alphaα 不能被蕴含，那么 α\\alphaα 为假。”\n知识库被假定为完整的：它包含了足够的知识来证明所有的真实事实。\n例如 Bird(A)∧Bird(B)⊭Bird(C)Bird(A) \\land Bird(B) \\not\\models Bird(C)Bird(A)∧Bird(B)⊨Bird(C)，那么 ¬Bird(C)\\neg Bird(C)¬Bird(C)。\n闭合世界推理具有不一致性（Inconsistency）：\n\n假设我们的知识库 S={P∨Q}S = \\{P \\lor Q\\}S={P∨Q}\n但是我们却有 S⊭PS \\not \\models PS⊨P 和 S⊭QS \\not \\models QS⊨Q\n根据闭合世界假设，¬P∧¬Q\\neg P \\land \\neg Q¬P∧¬Q，因此 S⊨¬(P∨Q)S \\models \\neg(P \\lor Q)S⊨¬(P∨Q)。这与 SSS 不一致。\n\n闭合世界推理的替代方案是 开放世界假设（Open-world assumption）：一个陈述可以为真，即使我们不知道它为真。换句话说，知识不限于知识库本身。\n基于开放世界假设的逻辑示例：\n\n一阶逻辑（FOL）\nOWL\n\n基于闭合世界假设的逻辑：\n\nProlog\n\n II. 限制推理（Circumscription）\n限制推理是闭合世界假设的一种更精确的版本：我们定义哪些谓词应该被假定为假，除非另有说明。\n例如，定义 Abnormal(x)Abnormal(x)Abnormal(x) 默认为假，在没有进一步知识的情况下，推理者会假设 ¬Abnormal(x)\\neg Abnormal(x)¬Abnormal(x)\n限制推理具有不一致性（Inconsistency）：尼克松菱形（Nixon Diamond）。\n III. 默认逻辑（Default logic）\n在默认逻辑中，知识库包括：\n\n通常的一阶逻辑（FOL）句子\n默认规则\n\n默认规则定义了可以使用哪些默认知识。\n默认规则形式如下：\nP:J1,J2,…,Jn/CP: J_1, J_2, \\dots, J_n / CP:J1​,J2​,…,Jn​/C\n\nPPP：前提(prerequisite)。\nJ1,J2,…,JnJ_1, J_2, \\dots, J_nJ1​,J2​,…,Jn​：证明条件(justifications)\nCCC：结论 (conclusion)\n\n解释：\n如果 PPP (前提)成立，并且所有的 JiJ_iJi​ 都无法被证明为假，那么可以得到结论 CCC\n例如：假设规则是 Bird(x):¬Abnormal(x)/Flies(x)Bird(x): \\neg Abnormal(x)/Flies(x)Bird(x):¬Abnormal(x)/Flies(x)：\n\n前提：xxx 是一只鸟\n条件：xxx 不是异常鸟\n结论：xxx 会飞\n\n只要不能证明 Abnormal(x)Abnormal(x)Abnormal(x) 为真，我们就能得到结论 Flies(x)Flies(x)Flies(x)。\n 2. 命题逻辑(Propositional Logic)\n I. 命题逻辑\n命题逻辑(Propositional Logic) 是FOL的一个子集。它是不带有定义域的FOL。\n\n包含零元谓词(zero-arity predicates)，运算符 ∧,∨,¬,(,)\\land, \\lor, \\neg, (, )∧,∨,¬,(,)，以及它们可以表达的，如 →,  ⟺  \\to, \\iff→,⟺。\n命题逻辑不支持 量词、变量、函数和多元谓词。\n存在命题逻辑的推理系统，是完整并合理的。\n\n II. CNF and DNF\n 1. CNF 和 DNF 定义和性质\n任何一个命题公式都可以转化为合取范式(Conjunctive Normal Form, CNF) 和 析取范式(Disjunctive Normal Form, DNF)。\n\n合取范式是析取从句(clauses)的合取，例如 (P∨Q)∧(¬Q∨S)∧T(P \\lor Q) \\land (\\neg Q \\lor S) \\land T(P∨Q)∧(¬Q∨S)∧T\n析取范式是合取从句的析取，例如  (¬P∧R)∨(Q∧¬S)(\\neg P \\land R) \\lor (Q \\land \\neg S)(¬P∧R)∨(Q∧¬S)\n\n一般 CNF 更符合事实逻辑，所以一般我们主要使用 CNF 作为知识库。\n 2. 命题逻辑转化 CNF 的步骤\n\n将   ⟺  \\iff⟺ 和 →\\to→ 转化为基本运算符：\n\n替换所有的 α  ⟺  β\\alpha \\iff \\betaα⟺β 为 (α→β)∧(β→α)(\\alpha \\to \\beta)\\land(\\beta \\to \\alpha)(α→β)∧(β→α)\n替换所有的 α→β\\alpha \\to \\betaα→β 为 (¬α∨β)(\\neg \\alpha \\lor \\beta)(¬α∨β)\n\n\n将 ¬\\neg¬ 写入括号内：\n\n替换所有的 ¬(α∧β∧… )\\neg (\\alpha \\land \\beta \\land \\dots)¬(α∧β∧…) 为 (¬α∨¬β∨… )(\\neg \\alpha \\lor \\neg \\beta \\lor \\dots)(¬α∨¬β∨…)\n替换所有的 ¬(α∨β∨… )\\neg (\\alpha \\lor \\beta \\lor \\dots)¬(α∨β∨…) 为 (¬α∧¬β∧… )(\\neg \\alpha \\land \\neg \\beta \\land \\dots)(¬α∧¬β∧…)\n替换所有的 ¬¬α\\neg \\neg \\alpha¬¬α 为 α\\alphaα\n\n\n使用分配律将析取分布到合取中：\n\n替换所有的 ((α∧β)∨γ)((\\alpha \\land \\beta) \\lor \\gamma)((α∧β)∨γ) 为 ((α∨γ)∧(β∨γ))((\\alpha \\lor \\gamma) \\land (\\beta \\lor \\gamma))((α∨γ)∧(β∨γ))\n\n\n删除所有重复的文字：\n\n替换所有的 (α∨α)(\\alpha \\lor \\alpha)(α∨α) 和 α∧α\\alpha \\land \\alphaα∧α 为 α\\alphaα\n\n\n\n然而，将析取范式转化为合取范式或者将析取范式转化为合取范式可能会增加从句的数量，可能会指数型增加。\n 3. CNF 的子句表示法(Clausal Representation)\n因为 CNF 拥有简单的结构，所以可以使用一种紧凑的形式，叫做子句表示法(Clausal Representation)。规则如下：\n\n每一个 CNF 由一系列的析取子句(clause)表示：\n\n(A∨¬B)⏟Clause 1∧(¬C∨D)⏟Clause 2∧(¬A∨B∨C)⏟Clause 3\\underbrace{(A \\lor \\neg B)}_{\\text{Clause 1}} \\land \n\\underbrace{(\\neg C \\lor D)}_{\\text{Clause 2}} \\land \n\\underbrace{(\\neg A \\lor B \\lor C)}_{\\text{Clause 3}}\nClause 1(A∨¬B)​​∧Clause 2(¬C∨D)​​∧Clause 3(¬A∨B∨C)​​\n\n每一个从句包含一系列的文字(literal)：\n\n(A⏟Literal 1∨¬B⏟Literal 2)\\left( \n\\underbrace{A}_{\\text{Literal 1}} \n\\lor \n\\underbrace{\\neg B}_{\\text{Literal 2}} \n\\right)\n(Literal 1A​​∨Literal 2¬B​​)\n\n每一个文字要么是一个原子语句(atomic sentence)，要么是它的否定。\n我们使用:\n\n花括号 {… }\\{\\dots\\}{…} 表示公式(formula)。\n\n空花括号 {}\\{\\}{} 表示 TRUE\\text{TRUE}TRUE，因为它是合取的中性元素(neutral element)，即 X∧TRUE  ⟺  XX \\land \\text{TRUE} \\iff XX∧TRUE⟺X。\n\n\n方括号 [… ][\\dots][…] 表示子句(clause)。\n\n空方括号 [][][] 表示 FALSE\\text{FALSE}FALSE，因为它是析取的中性元素，即 X∨FALSE  ⟺  XX \\lor \\text{FALSE} \\iff XX∨FALSE⟺X。\n{[]}\\{[]\\}{[]} 表示 FALSE\\text{FALSE}FALSE。\n\n\nA‾\\overline{A}A 表示否定。\n\n\n如：{[A,B‾],[C‾,D],[A‾,B,C]}\\{[A, \\overline{B}], [\\overline{C}, D], [\\overline{A}, B, C]\\}{[A,B],[C,D],[A,B,C]} 用于表示上面的公式。\n子句表示法允许我们将公式作为数学对象（集合的集合）来处理\n\n 4. CNF 的一些推理\n\n如果 CNF 是不可满足的：\n\n显式矛盾：包含空语句，即 []∈S[] \\in S[]∈S。\n隐式矛盾：其归结推导出空语句 [][][]。（归结(Resolution)定义看推理系统）\n\n只有 {[P],[P‾]}\\{[P], [\\overline{P}]\\}{[P],[P]} 才能一步归结出空语句 [][][]\n\n\n\n\n\n 5. CNF 扩展\n为了适应所有 FOL，我们使用扩展的 CNF：\n\n扩展文字(literals)转化为 CNF：\n\n多元谓词、函数和其否定。\n量词形式。如 ∀x,P(x)\\forall x, P(x)∀x,P(x)。\n量词形式的否定。如 ¬∀x,P(x)\\neg \\forall x, P(x)¬∀x,P(x)。\n\n\n对于每个量词使用独一无二的变量名。\n使用德摩根将量词的否定写到里面。\n将量词写在外面。（这依赖于将每个量词使用第一无二的变量名）\n将每一个子句转化为 CNF 的子句表示法。\n\n\n扩展的例子\n考虑该公式：A∧(B∨∀x.∀y.P(f(x),y)∨Q(x))∧¬∃x.Q(x)A \\land (B \\lor \\forall x. \\forall y. P(f(x), y) \\lor Q(x)) \\land \\neg \\exist x. Q(x)A∧(B∨∀x.∀y.P(f(x),y)∨Q(x))∧¬∃x.Q(x)\n\n扩展文字：{[A],[B,∀x.∀y.P(f(x),y)∨Q(x)],[¬∃x.Q(x)]}\\{[A], [B, \\forall x. \\forall y. P(f(x), y) \\lor Q(x)], [\\neg \\exist x. Q(x)]\\}{[A],[B,∀x.∀y.P(f(x),y)∨Q(x)],[¬∃x.Q(x)]}\n变量名：{[A],[B,∀x.∀y.P(f(x),y)∨Q(x)],[¬∃x2.Q(x2)]}}\\{[A], [B, \\forall x. \\forall y. P(f(x), y) \\lor Q(x)], [\\neg \\exist x_2. Q(x_2)]\\}\\}{[A],[B,∀x.∀y.P(f(x),y)∨Q(x)],[¬∃x2​.Q(x2​)]}}\n删否定：{[A],[B,∀x.∀y.P(f(x),y)∨Q(x)],[∀x2.¬Q(x2)]}}\\{[A], [B, \\forall x. \\forall y. P(f(x), y) \\lor Q(x)], [\\forall x_2. \\neg Q(x_2)]\\}\\}{[A],[B,∀x.∀y.P(f(x),y)∨Q(x)],[∀x2​.¬Q(x2​)]}}\n将量词写外面：∀x.∀y.∀x2.{[A],[B,P(f(x),y)∨Q(x)],[Q(x2)‾]}}\\forall x.\\forall y.\\forall x_2.\\{[A], [B, P(f(x), y) \\lor Q(x)], [\\overline{Q(x_2)}]\\}\\}∀x.∀y.∀x2​.{[A],[B,P(f(x),y)∨Q(x)],[Q(x2​)​]}}\n每个句子转化为 CNF：∀x.∀y.∀x2.{[A],[B,P(f(x),y),Q(x)],[Q(x2)‾]}}\\forall x.\\forall y.\\forall x_2.\\{[A], [B, P(f(x), y), Q(x)], [\\overline{Q(x_2)}]\\}\\}∀x.∀y.∀x2​.{[A],[B,P(f(x),y),Q(x)],[Q(x2​)​]}}\n\n\n\n 3. CSP 知识系统\n限制满足问题(Constraint Satisfaction Problem, CSP) 是一个 SAT 问题的扩展。但同时 CSP 也是一种描述知识的语言。\n\n特点：\n\n对于有限的定义域中，其表达能力等价于 SAT (CNF)。\n复杂的知识可以紧凑地表达出来\n拥有有效的求解器\n\n\n\n I. CSP 的定义\n在 CSP 中，给出：\n\n变量的集合 x1,x2,...,xn{x_1, x_2, ..., x_n}x1​,x2​,...,xn​\n定义域 D1,D2,...,Dn{D_1, D_2, ..., D_n}D1​,D2​,...,Dn​\n\n定义域可以是有限也可以是无限的。\n\n\n约束(constraints)的集合 CCC\n\n其问题就是对于每一个变量值 xi∈Dix_i \\in D_ixi​∈Di​ 找到一个值，使得限制 CCC 满足，或证明这个值不存在。\nSAT 问题则是将定义域限制为 TrueTrueTrue 和 FalseFalseFalse。\n II. 约束的描述形式\n约束是一个或多个变量的关系 (relation)。一个约束关系中使用的变量集合称之为范围(scope)。\n也就是说，一个特定组合的变量（范围）是否满足它。\n约束可以被紧凑定义(Compact definition)(如使用算数) 或者 使用表格(Tabular)。\n约束定义的方法：\n\n表格法(Tabular) 只能够定义在有限的定义域中。表格定义通常不切实际。\n我们更偏向于使用紧凑定义(Compact definition)。\n\n例如对于两个范围 “不相等” 约束，可以被描述为：\n\nScope: {x1,x2}\\{x_1, x_2\\}{x1​,x2​}\nCompact definition: 如果 x1≠x2x_1 \\not = x_2x1​=x2​，则满足。\n表格定义（假设其定义域 D1=D2={1,2,3}D_1 = D_2 = \\{1, 2, 3\\}D1​=D2​={1,2,3}）：\n\n\n\n\nx1↓x_1 ↓x1​↓ x2→x_2 →x2​→\n111\n222\n333\n\n\n\n\n111\n−-−\n+++\n+++\n\n\n222\n+++\n−-−\n+++\n\n\n333\n+++\n+++\n−-−\n\n\n\n多个范围定义的 “不相等” 约束：\n\nScope: {x1,x2,…,xk}\\{x_1, x_2, \\dots, x_k\\}{x1​,x2​,…,xk​}\nCompact definition: 对于所有的 i≠j∈{1,2,...,k}i \\not = j \\in \\{1, 2, ..., k\\}i=j∈{1,2,...,k} 如果 xi≠xjx_i \\not = x_jxi​=xj​ 则满足。\n\n III. FOL 和 CSP 知识系统的区别\n\n\n\nFOL\nCSP\n\n\n\n\n常数(零元函数) Constant\n变量\n\n\n零元谓词\n定义域为 2 的变量\n\n\n非零元函数/变量\n多个变量，每种情况对应一个变量需要有限的定义域\n\n\n等价 Equality\n“等于” 限制\n\n\n存在 xxx\nSkolemisation变量 xxx\n\n\n全部 xxx\n需要有限的定义域\n\n\n\n最大的区别是，FOL 是假设它的句子或公式为真。而 CSP 是假设它的限制为真。\n例如我们判断某一个谓词变量 PPP 为真，FOL 的表达是 PPP，而CSP的表达为 P=1P = 1P=1。\n 五. 霍尔语句 (Horn Clauses)\nHorn Clauses 是 CNF 子句的一种特殊情况。\n 1. 命题逻辑中的 Horn 语句\n命题逻辑中的 Horn 子句是一个最多包含一个正文字（未取反文字）的子句。\n a. 命题逻辑中的霍尔语句的正反性\n命题逻辑中的 Horn 语句分为 正霍尔语句 (Positive Horn clause) 和 反霍尔语句 (Negative Horn clause)。\n正霍尔语句是指有一个正文字，例如 [A,B‾,C‾,D‾][A, \\overline{B}, \\overline{C}, \\overline{D}][A,B,C,D] 此时可以被念作 “If B and C and D then A”。\n因为如要证明该语句为真，如果 B,C,DB, C, DB,C,D 为真，那么 AAA 一定为真。可以直接用于“从条件推导结论”（如知识库推理）。\n负霍尔语句没有正文字，例如 [A‾,B‾,C‾,D‾][\\overline{A}, \\overline{B}, \\overline{C}, \\overline{D}][A,B,C,D] 它也被称之为 目标(goal)。用于检查是否存在矛盾（不可满足性），即“所有这些条件不能同时成立”。\n这是为了证明 A,B,C,DA, B, C, DA,B,C,D 由知识库蕴含，因此我们添加了 ¬(A∧B∧C∧D)\\neg(A \\land B \\land C \\land D)¬(A∧B∧C∧D)，也就是 [A‾,B‾,C‾,D‾][\\overline{A}, \\overline{B}, \\overline{C}, \\overline{D}][A,B,C,D]。\n空语句 [][][] 属于负霍尔子句。\n b. 命题逻辑中的霍尔语句的归结\n归结规则无法对两个负Horn子句进行操作，因为所有文字都是负的。\n\n负子句 + 正子句：只能得到负子句。因为消掉了一个正一个负，没有正了。\n正子句 + 正子句：只能得到正子句。因为消掉了一个正一个负，剩下一个正。\n\n定理：如果可以从一个Horn子句集合 SSS 中推导出一个负子句 ccc，那么一定可以通过归结操作将该子句推导出来。\n存在以下形式的推导过程(SLD, Selected literals, Linear pattern, over Definite clauses 推导)\n\n从集合 SSS 中选择一个负子句 c1∈Sc_1 \\in Sc1​∈S\n对于 i=2,3,4,...,i = 2,3,4,...,i=2,3,4,...,，令 cic_ici​ 是 ci−1c_{i-1}ci−1​ 和集合 SSS 中某个正子句归结的结果\n对于某个 nnn，满足 cn=cc_n = ccn​=c\n\n因为空语句也是负语句，因此SLD推导是反驳完备的：\n\n如果SLD推导产生了一个空子句，则集合 SSS 是不可满足的。\n如果集合 SSS 是不可满足的，SLD保证最终会得到一个空子句。\n\n c. 基于 SLD 的算法。\n存在两种算法：\n\nBackward Chaining（反向推理）\nForward Chaining（正向推理）\n\n这两种算法的设计目标是验证一组已知事实：\n\n给定一个由&quot;正Horn子句&quot;组成的集合 SSS。\n给定一个命题变量集合 {Q1,Q2,...,Qn}\\{Q_1, Q_2, ..., Q_n\\}{Q1​,Q2​,...,Qn​}\n证明或反驳 Q1,Q2,...,QnQ_1, Q_2, ..., Q_nQ1​,Q2​,...,Qn​ 是否由集合 SSS 蕴含。\n\n证明这种蕴涵关系等价于将一个负Horn子句 [Q1‾,Q2‾,...,Qn‾][\\overline{Q_1}, \\overline{Q_2}, ..., \\overline{Q_n}][Q1​​,Q2​​,...,Qn​​] 加入到集合 SSS 中，并表示如何推导出空子句 [][][]\n I. Backward Chaining（反向推理）\n一种从目标 Q1∧Q2∧...∧QnQ_1 \\land Q_2 \\land ... \\land Q_nQ1​∧Q2​∧...∧Qn​ 开始，然后沿着推理链向回推进的归结算法被称为反向推理。\n为了证明 Q1Q_1Q1​ 的蕴涵，我们需要找到一个包含非取反的 Q1Q_1Q1​ 的子句。假设我们找到一个子句 c=[Q1,P1‾,P2‾,...Pk‾]c = [Q_1, \\overline{P_1}, \\overline{P_2}, ... \\overline{P_k}]c=[Q1​,P1​​,P2​​,...Pk​​]。那么如果 P1,P2,...,PkP_1, P_2, ..., P_kP1​,P2​,...,Pk​ 全部被蕴含，则可以证明 Q1Q_1Q1​ 也被蕴含。\n证明一个命题变量的蕴涵被归约为证明其他命题变量的蕴涵，这是一种递归算法。\n算法：BackwardChaining(S,{Q1,Q2,...,Qn}S, \\{Q_1, Q_2, ..., Q_n\\}S,{Q1​,Q2​,...,Qn​})\n输出：如果Q1,Q2,...,QnQ_1, Q_2, ..., Q_nQ1​,Q2​,...,Qn​ 被 SSS 蕴含，则返回 TRUE，否则返回 FALSE。\n\n如果 n=0n = 0n=0，那么返回 TRUE\n对于 ∀c∈S\\forall c \\in S∀c∈S，且 c=[Q1,P1‾,P2‾,...,Pk‾]c = [Q_1, \\overline{P_1}, \\overline{P_2}, ..., \\overline{P_k}]c=[Q1​,P1​​,P2​​,...,Pk​​] 那么，如果有 BackwardChaining(S,{Q2,Q3,...,Qn,P1,P2,...,Pk})BackwardChaining(S, \\{Q_2, Q_3, ..., Q_n, P_1, P_2, ..., P_k\\})BackwardChaining(S,{Q2​,Q3​,...,Qn​,P1​,P2​,...,Pk​}) 返回为 TRUE，则返回 TRUE\n返回 FALSE\n\n性质：\n\n该算法是 SOUND 的，它做出的任何结论都是正确的。\n即使在命题逻辑情况下，也不保证终止。\n在相对简单的情况下，它可能会非常低效。\n\n II. Forward Chaining（正向推理）\n核心思想是：当我们证明某个命题变量被知识库蕴涵时，将其标记为“已解决”，然后将这个信息传播到其他子句中。\n如果有一个子句 [A,B1‾,B2‾,...,Bk‾][A, \\overline{B_1}, \\overline{B_2}, ..., \\overline{B_k}][A,B1​​,B2​​,...,Bk​​]，其中 AAA 尚未解决，但其他常量 B1,B2,...,BkB_1, B_2, ..., B_kB1​,B2​,...,Bk​ 已经被解决，那么 AAA 也可以被标记为已解决。\n检查所有的正子句，然后验证所有的负子句。\n算法：ForwardChaining(S,{Q1,Q2,...,Qn}S, \\{Q_1, Q_2, ..., Q_n\\}S,{Q1​,Q2​,...,Qn​})\n输出：如果Q1,Q2,...,QnQ_1, Q_2, ..., Q_nQ1​,Q2​,...,Qn​ 被 SSS 蕴含，则返回 TRUE，否则返回 FALSE。\n\n让所有的命题变量设置为 未解决 的。\n循环\n选择正语句 c∈Sc \\in Sc∈S，如 c=[A,B1‾,B2‾,...,Bk‾]c = [A, \\overline{B_1}, \\overline{B_2}, ..., \\overline{B_k}]c=[A,B1​​,B2​​,...,Bk​​]，其中 AAA 是未解决的 但是 B1,B2,...,BkB_1, B_2, ..., B_kB1​,B2​,...,Bk​ 是已解决的。\n如果 ccc 存在，则标记 AAA 为已解决。检查是不是所有 Q1,Q2,...,QnQ_1, Q_2, ..., Q_nQ1​,Q2​,...,Qn​ 被标记为已解决，如果是则返回 TRUE，否则返回 2 循环。\n未找到返回 FALSE。\n\n性质：\n\n正向推理在命题逻辑情况下是正确的（sound）且反驳完备的（refutation-complete）。\n正向推理速度比反向推理要快得多。对于命题逻辑情况，正向推理是一个多项式时间算法。\n实际上，它可以被实现为具有 O(∣S∣)O(|S|)O(∣S∣) 次迭代的算法，即迭代次数与知识库的大小成线性关系。\n\n 2. FOL 的 Horn 语句 和 Prolog 语言\n可以使用量词扩展 Horn 语句，也就是 FOL 的 Horn 语句，例如 [P(x),Q1(x)‾,Q2(y)‾][P(x), \\overline{Q_1(x)}, \\overline{Q_2(y)}][P(x),Q1​(x)​,Q2​(y)​] 表示 ∀x,∀y,(P(x)∨¬Q1(x)∨¬Q2(y))\\forall x, \\forall y, (P(x) \\lor \\neg Q_1(x) \\lor \\neg Q_2(y))∀x,∀y,(P(x)∨¬Q1​(x)∨¬Q2​(y))。\nFOL 的 Horn子句的可满足性是不可判定的；没有保证终止的蕴涵检查算法。\n一阶逻辑版本的Horn子句是Prolog语言的基础。\nProlog 语言是一种声明式(Declarative)逻辑编程语言。\nProlog仅支持一种术语（term）数据类型，可以是：\n\nAtoms 原子：以小写字母开头的抽象命名实体，例如 a\nNumbers 数字：支持浮点数和整数。\nVariables 变量：大写字母或者下划线开头，可以取任意值：X, _good\n复合术语(Compound term)：\n\n例如 is_sunny(july, spain)。\n\nis_sunny 是 函数符 (functor)\njuly, spain 是参数 (arguments)\n\n\n特殊情况：\n\n原子（Atom） 是没有参数的复合术语。\n列表（List） 是一种复合术语，例如 [uk, 1, [uk, spain]]\n字符串，例如 &quot;Hello World&quot;\n\n\n\n\n\n一个 Prolog 程序是由一组 子句（clauses） 组成的，可以分为两种类型：\n\n规则（Rules）是定义术语之间关系的 Horn 子句 (有多个参数的正子句)\n\n例如 HEAD :- BODY，即 BODY→HEADBODY \\to HEADBODY→HEAD，也可以说是 [HEAD,BODY‾][HEAD, \\overline{BODY}][HEAD,BODY]。\n规则左侧 HEAD 只能是一个术语。\n规则右侧的 BODY 可以包含术语的合取和析取：\n\na, b, c，等价于 a∧b∧ca \\land b \\land ca∧b∧c\na; b 等价于 a∨ba \\lor ba∨b\na, b; c 等价于 (a∧b)∨c(a \\land b) \\lor c(a∧b)∨c\n\n\n\n\n事实（Facts） 陈述已知为真的信息。(只有一个参数的正子句)\n\n一个空 BODY 的子句可以称之为事实，例如 a.，表示 a = TRUE。\n复合术语：cat(tom)，表示 tom 是只猫。\n复合术语关联：length(List, L) 表示使用 L 代表列表的长度。\n\n\n查询(query)，即需要验证的公式 (负子句)。\n\n使用 $?- BODY 验证。\n\n\n\n当用户输入查询时，Prolog 会尝试证明它（即证明查询被蕴涵）。如果查询包含变量，Prolog 还需要找到使查询可满足的变量赋值。\nProlog 使用 SLD 归结 来处理否定查询，尝试推导出空子句。\n例如：\n123cat(kitty).cat(X) :- parent(X, Y), cat(Y).parent(tom, kitty)\n此时我们使用查询 ?- cat(X).\n那么会得到：\n123X = kitty;X = tom;false.\n 六. 描述逻辑 Description Logics\n描述逻辑（Description logics, DLs）是围绕对象的类别构建的。描述逻辑具有类似集合的特性：\n\n∩\\cap∩ 表示类别的交集\n∪\\cup∪ 表示类别的并集\n⊆\\subseteq⊆ 表示子类\n\n优点：\n\n直观\n无变量\n限制充分，以支持高效推理\n\n a. 带补集的属性概念语言 ALC\n带补集的属性概念语言 (Attributive Concept Language with Complements, ALC) 是描述逻辑的一种。\n I. ALC语法：\n\n逻辑符号：\n\n概念生成操作符 ∀,∃,∩,∪,¬\\forall, \\exist, \\cap, \\cup, \\neg∀,∃,∩,∪,¬\n连接符：⊆,≡\\subseteq, \\equiv⊆,≡\n断言操作符：:::\n括号\n\n\n非逻辑符号：\n\n概念（Concepts）\n\n也称为类，例如：Person（人）、Dog（狗）、Employee（员工）等\n相当于一阶逻辑（FOL）中的一元谓词\n以大写字母开头\n\n\n角色（Roles）\n\n定义概念之间的关系，例如：child（孩子）、madeOf（由…组成）、ofAge（年龄）等\n相当于一阶逻辑（FOL）中的二元谓词\n以小写字母开头\n\n\n个体（Individuals）\n\n即概念的具体实例，例如：peter（彼得）、bottle（瓶子）等\n相当于一阶逻辑（FOL）中的零元函数（常量）\n以小写字母开头\n\n\n\n\n\n II. 概念（Concepts）定义方式\n一个概念可以通过以下方式定义：\n\n原子概念（Atomic concept）：一个命名的概念，例如：Person（人）\n∀r.C\\forall r.C∀r.C，表示一个个体的概念。例如 ∀.child.Girl\\forall. child.Girl∀.child.Girl，即该个体所有子女都是女孩。\n∃r.C\\exist r.C∃r.C，表示一个个体的概念。\n¬C\\neg C¬C，表示非 CCC 的概念，例如 ¬Female\\neg Female¬Female 表示非女性。（如果个体包括家具，则一张桌子也可以属于 ¬Female\\neg Female¬Female）\nC∩C′C \\cap C&#x27;C∩C′ 表示交集概念。\nC∪C′C \\cup C&#x27;C∪C′ 表示并集概念。\n\n III. 量词的形式化解释\n\n定义：\n\n令 C1C_1C1​ 和 C2C_2C2​ 是概念，rrr 是一个角色\n令 P1(x)P_1(x)P1​(x) 和 P2(x)P_2(x)P2​(x) 是分别对应概念 C1C_1C1​ 和 C2C_2C2​ 的谓词，R(x,y)R(x, y)R(x,y) 对应角色 rrr 的谓词。\n\n\n则：\n\nC2≡∀r.C1C_2 \\equiv \\forall r.C_1C2​≡∀r.C1​ 表示 C2C_2C2​ 是一个概念，包含的个体是仅与概念 C1C_1C1​ 中的个体通过 rrr 关系关联的个体。等价于：∀x.P2(x)  ⟺  ∀y.(R(x,y)→P1(y))\\forall x.P_2(x) \\iff \\forall y.(R(x, y) \\to P_1(y))∀x.P2​(x)⟺∀y.(R(x,y)→P1​(y))\nC2≡∃r.C1C_2 \\equiv \\exist r.C_1C2​≡∃r.C1​ 表示 C2C_2C2​ 是一个概念，包含的个体是至少与概念 C1C_1C1​ 中的个体中的一个通过 rrr 关系关联的个体。等价于：∀x.P2(x)  ⟺  ∃y.(R(x,y)∧P1(y))\\forall x.P_2(x) \\iff \\exist y.(R(x, y) \\land P_1(y))∀x.P2​(x)⟺∃y.(R(x,y)∧P1​(y))\n\n\n\n IV. 句子 Sentences\n句子 定义了概念和/或角色之间的关系。\n\n\n新概念的定义：例如 HasDaughter≡∃child.FemaleHasDaughter \\equiv \\exist child. FemaleHasDaughter≡∃child.Female 表示一个个体有女儿的概念。\n\n\n公理（Axioms）：表示必须成立的陈述。例如 Mother⊆FemaleMother \\subseteq FemaleMother⊆Female\n\n\n V. 断言 Assertions\n\n概念断言（Concept assertions）：jane:Femalejane : Femalejane:Female，表示个体属于类。\n角色断言（Role assertions）：(jane,peter):child(jane, peter) : child(jane,peter):child，表示两个个体的关系\n\n VI. TBOX 和 ABOX\nALC 清楚地区分了数据和概念性知识。\n\nTBOX (术语生命)：\n\n描述适用于整个知识库的事实——与具体个体无关\n使用句子实现\n可类比于数据库中的模式（schema）\n\n\nABox（断言声明）：\n\n关于具体个体的知识——与一般知识无关\n使用断言实现\n可类比于数据库中的表内容\n\n\n\n VII. ALC 中的推理\nALC的解释、蕴含和可满足性定义域 FOL 类似。\n\nALC的设计使其是可判定的。\n可满足性的证明是 NP完全问题。\n一些变体具有更好的性能保证\n一些扩展在一般情况是不可判定的\n\n 总结\n 知识系统和问题的可判断性\n\n\n\n知识系统\n可判断性\n\n\n\n\nFOL\n不可判断的\n\n\nPropositional logic\nNP-complete\n\n\nCSP(有限定义域)\nNP-complete\n\n\nCSP(无限定义域)\n不可判断的\n\n\nHorn clauses (FOL)\n不可判断的\n\n\nHorn clauses (propositional)\n多项式的(polynomial)\n\n\n\n 三. 推理系统 (Reasoning System)\n 1. 理想的(Idealised)推理系统\n理想的推理系统包含：\n\n知识库 KBKBKB\n语句 α\\alphaα\n证明 KB⊨αKB \\models \\alphaKB⊨α，也就是说 ∃J,J⊨KB∧α\\exists \\mathcal{J},  \\mathcal{J} \\models KB \\land \\alpha∃J,J⊨KB∧α\n\n或者：\n\n知识库 KBKBKB\n公式 β\\betaβ\n证明 ∃μ.KB,μ⊨β\\exists \\mu. KB, \\mu \\models \\beta∃μ.KB,μ⊨β\n\n总而言之，推理就是要证明知识库是否蕴含某一个语句/公式。\n 2. 推理系统的属性\n I. 推导(Derivation)\n推导是基于推理系统从知识库中能够挖掘出的信息/结论。\n从一个从句的集合 SSS 到 ccc 的推导(derivation) 是一个逐渐推断(infer) 从句 c1,c2,…,cnc_1, c_2, \\dots, c_nc1​,c2​,…,cn​ 的过程，其中 c=cnc = c_nc=cn​, cic_ici​ 由 S∪{c1,c2,…,ci−1}S \\cup \\{c_1, c_2, \\dots, c_{i-1}\\}S∪{c1​,c2​,…,ci−1​} 推断出。我们写作 S⊢cS \\vdash cS⊢c。\n\n推导是一个逐渐推断的过程，推理系统会提供推断的规则。\n\n基础规则：如果 α∈S\\alpha \\in Sα∈S，那么一般有 S⊢αS \\vdash \\alphaS⊢α。\n\n\n推导和蕴含的差别：\n\n推导是基于推理系统得到的结论。蕴含是基于知识库系统的是一个事实。\nS⊢cS \\vdash cS⊢c 是推理系统得到的结果。S⊨cS \\models cS⊨c 是知识系统的一个事实。\n\n\n\n II. 其他属性\n\n合理性(Sound)：通过该推导系统推导出的所有语句，在语义上（知识系统中）都是真命题。(证明的都是对的)\n\n如果一个推理系统是合理的，那么如果 S⊢cS \\vdash cS⊢c 则 S⊨cS \\models cS⊨c。即推导的所有语句都是正确的。\n如果一个推理系统是合理的，那么将推导 ccc 加入到知识库并不会改变其评估。即 S  ⟺  S∧cS \\iff S \\land cS⟺S∧c。\n\n\n完整性(Complete)：所有在语义(知识系统)上为真的陈述（公式）都可以通过该逻辑系统的推理规则导出。(对的都可以证明)\n\n如果一个推理系统是完整的，那么如果 S⊨cS \\models cS⊨c，则 S⊢cS \\vdash cS⊢c。即所有正确的语句都被可以推导出。\n\n\n反驳完整性(Refutation-Complete)：所有不可满足的知识库都可以通过该推导系统推导出 FALSE\\text{FALSE}FALSE。（注意与合理性和错误性定义的区别）\n\n如果 SSS 是不可满足的，那么 S⊢FALSES \\vdash \\text{FALSE}S⊢FALSE。\nFOL 通常使用反驳完整性来证明蕴含。\n\n\n可判断性(Decidability)：一个逻辑系统是可判定的，那么存在一个算法，能够在有限时间内决定任意给定公式是否是可满足的。\n\n III. FOL的推理系统\n 1. FOL 的合理、完整性\n\n\n\n\n\n\n\n\n\nNo FOL reasoning system is both sound and complete.\n没有一个FOL的推理系统即合理又完整。\n\nFOL语言的子集存在即合理又完整的推理系统。\n存在不完整但合理的，但反驳完整性的FOL推理系统。此时通常使用将被证明蕴含的句子的反义加入到知识系统证明其不可满足性来证明其是否被蕴含。\n\n如Z3的推理系统，但Z3狭义上不属于一种推理系统，而是一种求解器。\n\n\n\n 2. FOL 推理系统的的可判断性\n\nFOL语言是不可判断的。由图灵证明得出（参考形式语言与自动机理论）。\nFOL是半可判断的：\n\n若公式可满足，可以在有限时间内证明其满足性。\n若公式不可满足，那么可能永不终止。\n\n\n\n 3. 推理系统的类型\n I. CNF 的 归结推理(Resolution)\n归结推理(Resolution Reasoning)是一种推理方法，它是基于 CNF 的命题逻辑 (Propositional Logic) 和 归结(Resolution) 进行的。\n归结的定义：令 PPP 为一个文字(literal)，α\\alphaα, β\\betaβ 是一个文字的集合。如果 CNF 包含两个子句 [P,α][P, \\alpha][P,α] 和 [P‾,β][\\overline{P}, \\beta][P,β]，那么就称新子句 [α,β][\\alpha, \\beta][α,β] 为该CNF的归结(Resolution)。\n 1. 归结推理系统的推断规则\n归结系统的每一个从句的推断都是由归结得来。在归结推理系统中，对于一个CNF: (P∨α)∧(¬P∨β)(P \\lor \\alpha)\\land(\\neg P \\lor \\beta)(P∨α)∧(¬P∨β) 和 归结 (α∨β)(\\alpha \\lor \\beta)(α∨β)，我们有 (P∨α)∧(¬P∨β)⊢(α∨β)(P \\lor \\alpha)\\land(\\neg P \\lor \\beta) \\vdash (\\alpha \\lor \\beta)(P∨α)∧(¬P∨β)⊢(α∨β)。\n 2. 归结的推论：\n\n归结是被该 CNF 蕴含的(entailed)。\n只有当 [P][P][P] 和 [P‾][\\overline{P}][P] 才能归结出 [][][]，也就是其蕴含 FALSE\\text{FALSE}FALSE，即 P∧¬P⊨FALSEP \\land \\neg P \\models \\text{FALSE}P∧¬P⊨FALSE。\n\n\n归结的蕴含证明\n假设知识系统为 (P∨α)∧(¬P∨β)(P \\lor \\alpha)\\land(\\neg P \\lor \\beta)(P∨α)∧(¬P∨β)，此时有两种解释：\n\n\n当 J[P]=False\\mathcal{J}[P] = \\text{False}J[P]=False 时，为了满足知识系统则 J[β]=True\\mathcal{J}[\\beta] = \\text{True}J[β]=True，那么 α∨β\\alpha \\lor \\betaα∨β 为 True\\text{True}True，即 J⊨α∨β\\mathcal{J} \\models \\alpha \\lor \\betaJ⊨α∨β\n\n\n当 J[P]=True\\mathcal{J}[P] = \\text{True}J[P]=True 时，为了满足知识系统则 J[α]\\mathcal{J}[\\alpha]J[α]\n\n\n\n\n 3. 归结推理系统的属性：\n 归结系统的合理、完整性\n\n因为归结是被 CNF 蕴含的，所以归结推理系统是合理的 (Sound)。\n\n因此将归结加入到公式中并不会改变其的评估。\n\n\n归结推理是反驳完整的。即所有不满足的语句都可以被推理出。\n\n即如果知识库 SSS 不可满足，那么 S⊢[]S \\vdash []S⊢[]。\n归结推理系统是基于其反驳完整性进行的。\n\n\n\n 归结系统的可判断性\n具体可以参考下面 FOL 的归结系统。\n 4. 归结推理系统的推理本质\n归结演绎是基于反驳的证明方法。通过将否定的假设添加到知识库中找出矛盾(不可满足的)。\n如果我们要证明 S⊨γS \\models \\gammaS⊨γ，那么就只需要证明 S∧¬γS \\land \\neg \\gammaS∧¬γ 是不可满足的。\n因此我们只需要将假设的否定加入到知识库中，找到其的矛盾(证明不可满足性)，从而证明蕴含。\n即证明 (S∪¬γ)⊢[](S \\cup \\neg \\gamma) \\vdash [](S∪¬γ)⊢[]，则说明 S⊨γS \\models \\gammaS⊨γ。否则 S⊭γS \\not \\models \\gammaS⊨γ。\n 5. 归结推理算法步骤\n输入：知识库/子句的集合 SSS，需要证明蕴含的子句 γ\\gammaγ\n\n让 S′S&#x27;S′ 为 CNF 上的 ¬γ\\neg \\gamma¬γ\n让 S=S∪S′S = S \\cup S&#x27;S=S∪S′ (将假设的否定加入到知识库中)\n如果 []∈S[] \\in S[]∈S，那么返回 ENTAILED\\text{ENTAILED}ENTAILED (也就是存在两个互补语句归结出，即 [P][P][P] 和 [P‾][\\overline{P}][P])。\n如果存在 [P,α],[P‾,β]∈S[P, \\alpha], [\\overline{P}, \\beta] \\in S[P,α],[P,β]∈S，那么将 [α,β][\\alpha, \\beta][α,β] 加入到 SSS 中，跳转 3.3.3. 进行循环。\n否则返回 NOT ENTAILED\\text{NOT ENTAILED}NOT ENTAILED\n\n II. FOL 的归结推理\nFOL 的归结推理是基于扩展的 CNF 进行的，它是基于下面两个假设进行的：\n\n不存在平等连接词，如 ===。\n转化为 CNF 后不包含存在量词 ∃\\exists∃。\n\n满足这两点基本能保证系统是反驳完全的，即如果 SSS 是不可满足的，那么 S⊢[]S \\vdash []S⊢[]。\n 1. FOL的归结类型\n\n基础归结：一个全部变量 + 一个项(term)\n\n假设变量 xxx 由全部量词 ∀\\forall∀ 绑定，ttt 是一个项，那么如果 FOL 存在两个子句 [P(x),A(x)][P(x), A(x)][P(x),A(x)] 和 [P(t)‾,B][\\overline{P(t)}, B][P(t)​,B]，则该 FOL 存在归结 [A(t),B][A(t), B][A(t),B]。\n这是因为如果 ∀x.[P(x),A(x)]\\forall x. [P(x), A(x)]∀x.[P(x),A(x)] 成立，那么带入 ttt 得到 [P(t),A(t)][P(t), A(t)][P(t),A(t)] 成立，此时就符合基本的归结了。\n\n两个全部变量归结：\n\n假设变量 x1,x2x_1, x_2x1​,x2​ 是由全部量词 ∀\\forall∀ 绑定，那么如果 FOL 存在两个子句 [P(x1),A(x1)][P(x_1), A(x_1)][P(x1​),A(x1​)] 和 [P(x2)‾,B][\\overline{P(x_2)}, B][P(x2​)​,B]，那么该 FOL 存在归结 [A(x1),B][A(x_1), B][A(x1​),B] 和 [A(x2),B][A(x_2), B][A(x2​),B]。\n这是因为我们可以让 x1=x2x_1 = x_2x1​=x2​，反之亦然。\n\n复杂归结：\n\n假设变量 x1,x2,x3,x4x_1, x_2, x_3, x_4x1​,x2​,x3​,x4​ 是全部量词 ∀\\forall∀ 绑定，fff 和 ggg 是一个一元函数，PPP 是一个二元谓词，那么如果 FOL 存在两个子句 [P(f(x1),x2),A][P(f(x_1), x_2), A][P(f(x1​),x2​),A], 和 [P(x3,g(x4))‾,B][\\overline{P(x_3, g(x_4))}, B][P(x3​,g(x4​))​,B]，那么此时 FOL 存在归结 [A,B][A, B][A,B]\n也就是此时让 x3=f(x1)x_3 = f(x_1)x3​=f(x1​)，x2=g(x4)x_2 = g(x_4)x2​=g(x4​)\n 2. 消除假设\n I. 消除存在量词的方法：Skolemisation\nSkolemisation 是一个引入常量来替换存在变量的方法，通过证明转化后的语句的可满足性来证明语句的正确性。\n\n零元 Skolem 函数：\n\n对于每个由存在性 ∃\\exists∃ 绑定的变量，引入一个新的 常量 或者是 零元的函数 来代替变量，并消除存在性。我们将这个函数/变量称为 Skolem 函数。\n例如，∃x.P(x)\\exists x. P(x)∃x.P(x)，引入 aaa，将句子代替为 P(a)P(a)P(a)。\n如果 ∃x.P(x)\\exists x. P(x)∃x.P(x)，那么就说明 P(a)P(a)P(a) 是可满足的，反之亦然，这俩是等价的。\n因为没有对 aaa 添加更多的限制，所以只需要找到一个满足转化后的句子的 aaa 的值，就证明了 ∃x.P(x)\\exists x. P(x)∃x.P(x) 成立，此时 x=1x = 1x=1。至于怎么找到这个可满足性就是推理系统需要处理的事了。\n\n多元 Skolem 函数：\n\n如果一个谓词不止被一种量词变量限制，那么我们需要对这个存在性所依赖的变量的每个值都使用 Skolem 函数代替。\n如果一个存在量词受到其他量词变量的约束，那么 Skolem 函数是依赖于这些量词的，应该使用多元 Skolem 函数。\n例如，∀x.∃y.P(x,y)\\forall x. \\exists y. P(x, y)∀x.∃y.P(x,y) 是对每一个 xxx 都存在一个 yyy，因此这个 yyy 是依赖于 xxx 的，因此此时 Skolem 函数是多元的，该句子应该转化为 ∀x.P(x,a(x))\\forall x. P(x, a(x))∀x.P(x,a(x))。\n而对于 ∃y.∀x.P(x,y)\\exists y. \\forall x. P(x, y)∃y.∀x.P(x,y) 的 yyy 是不依赖于 xxx 的，因此该句子转化为 ∀x.P(x,a)\\forall x. P(x, a)∀x.P(x,a)。\n II. 消除平等连接词 ===\n相等是一种关系，因此我们可以把它当做一种谓词。我们可以视作 x=yx = yx=y 为 Equals(x,y)Equals(x, y)Equals(x,y)。\n但是FOL没有谓词的解释机制。我们只能通过添加限制来保证 Equals(x,y)Equals(x, y)Equals(x,y) 等价于 ===。\n重点：我们的方法不能保证 Equals 的解释一定如我们所期望的那样，但它足以证明不满足性。\n在离散数学中，同时满足自反性、对称性和传递性的关系被称为等价关系。这种等价关系不一定是等于。\n\n添加自反性(reflexivity)：∀x. Equals(x,x)\\forall x.\\ Equals(x, x)∀x. Equals(x,x)\n添加对称性(symmetry)：∀x. ∀y.(Equals(x,y)→Equals(y,x))\\forall x.\\ \\forall y. (Equals(x, y) \\to Equals(y, x))∀x. ∀y.(Equals(x,y)→Equals(y,x))\n添加传递性(transitivity)：∀x. ∀y.∀z.(Equals(x,y)∧Equals(y,z)→Equals(x,z))\\forall x.\\ \\forall y. \\forall z. (Equals(x, y) \\land Equals(y, z) \\to Equals(x, z))∀x. ∀y.∀z.(Equals(x,y)∧Equals(y,z)→Equals(x,z))\n\n其次为每个函数添加等于的限制：\n\n对于任意一个单元谓词 PPP, ∀x.∀y. Equals(x,y)→P(x)  ⟺  P(y)\\forall x. \\forall y.\\ Equals(x, y) \\to P(x) \\iff P(y)∀x.∀y. Equals(x,y)→P(x)⟺P(y)\n对于任意一个单元函数 fff，∀x.∀y. Equals(x,y)→Equals(f(x),f(y))\\forall x. \\forall y.\\ Equals(x, y) \\to Equals(f(x), f(y))∀x.∀y. Equals(x,y)→Equals(f(x),f(y))\n对于任意一个多元谓词，使用排列组合的进行一次相等判断。\n\n该方式并不高效，它会产生大量的新句子。更有效的处理是在推理系统中就对等于给予特殊处理，例如新的添加推断规则，而不是在知识库中添加限制。\n 3. 归结推理系统的可判断性\n\n\n\n\n逻辑命题\nFOL\n\n\n\n\n证明蕴含(不可满足性)\n有限的迭代内\n有限的迭代内\n\n\n反驳蕴含(可满足性)\n有限的迭代内\n可能永不停止\n\n\n\n在证明蕴含方面：\n\n逻辑命题中：\n\n归结推理系统是可以在有限的时间内证明的。即在逻辑命题中它是可判断的。\n\n这是因为具有有限的子句，因此其能够保证终止。\n\n\n即使是最短的不可满足情况的推导也可能需要指数(Exponential)数量的子句。即其时间复杂度是指数型的。\n\n迭代的次数（运行的时间）取决于子句的生成顺序。越早生成出空语句越早停止。\n\n\n\n\n在 FOL 中：\n\n归结系统可能永不停止。即在 FOL 中它是不可判断的。\n没有固定的时间复杂度，是没有定义的(Undefined)。\n\n\n\nUNSAT 问题（证明不可满足性）是一个NP-hard问题，是 co-NP-complete 问题 (其否定是 NP-complete问题)。\n 4. 推理性能改善的建议\n\n分解问题（Decompose the problem into subproblems）\n\n将大问题拆分成多个较小的子问题，各自独立求解。\n这样做有助于减小每次求解的复杂度，并能够更好地并行化处理。\n\n\n打破对称性（Break the symmetry of the problem）\n\n许多问题中存在对称性（例如变量或解法等价）。\n通过识别并消除这些对称性，可以减少重复搜索，从而提高效率。\n\n\n改变问题形式化表达（Change the formulation）\n\n根据问题特性，使用更高效或适合的数学模型或逻辑表达形式。\n\n\n改进求解器（Improve the solver）\n\n采用更强大的算法或优化技术，比如使用启发式搜索、剪枝策略或更快的求解工具。\n变量优先级\n\n\n\n a. 变量优先级\n变量优先级是选择对多个约束有强制性影响的变量。高优先级的变量能够通过推理传播影响其他变量，从而减少搜索空间。\n如果选择？\n\n分析变量的传播能力\n\n解算器会分析每个变量的潜在影响，选择能够最大程度触发约束传播的变量。\n\n\n利用启发式（Heuristics）方法\n\n解算器通常使用多种启发式技巧来预测哪些变量最重要，从而快速优化搜索过程。\n启发式方法是一种“智能”猜测，可以显著提高性能，尤其是在复杂的约束问题中。\n\n\n用户提供的洞察\n\n在某些情况下，用户可以为解算器提供关于问题结构的洞察，例如哪些变量更重要，从而帮助解算器做出更明智的优先级决策。\n\n\n\n 四. 规划 Planning\n\n规划是一种推理问题：确定需要执行哪些动作（计划）以使某些条件（目标）为真。\n规划是人工智能的核心：作为通过计算手段研究智能行为的重要领域。\n总体上，规划是一个非常复杂的现实世界问题：解决现实中的规划问题通常充满挑战。\n\n I. 经典规划 Classical planning\n经典规划方法为了简化问题，作出了一些假设：\n\n环境是确定性的：每个动作的结果都是确定的。\n环境是可观察的：代理能够完全感知环境的状态。\n环境是静态的：环境只会因代理的动作而改变，不受外部因素的干扰。\n\n a. 规划领域定义语言（Planning Domain Definition Language）：\n\n系统状态：使用流项（fluents）描述，可以是正的或负的谓词。\n目标（Goals）：流项的合取。\n动作模式（Action schemas）：定义可以改变系统状态的原子操作。\n\n每个动作模式由以下部分组成：\n\n前置条件（Precondition）：动作发生所需满足的条件。一个流项的列表。\n效果（Effect）：动作对系统状态的改变。包括一个删除列表（delete list）和一个添加列表（add list）的流项。\n\n b. 规划问题（Planning Problem）：\n\n定义：给定一个规划领域和一个目标。\n目标：找到一系列动作，将初始状态转换为满足目标的状态。\n解决方法：可以使用搜索算法来求解。\n\n II. 贝叶斯网络（Bayesian Networks）\n\n现实生活中的不确定性：\n\n如果 A 是去年参加了 C++ 模块考试的学生，那么 A 很可能通过了 C++ 考试。\n如果某人 A 发烧且咳嗽，那么 A 很可能患有新冠肺炎。\n\n\n概率知识库：\n\n使用 P(x1,x2,...,xN)P(x_1, x_2, ..., x_N)P(x1​,x2​,...,xN​) 表示关联 N 个事实的概率函数。\n其中 xix_ixi​ 表示第 iii 个事件的概率\n此函数展示了整个系统的联合概率分布。\n\n\n挑战：\n\n当 NNN 很大时，此函数会变得非常复杂。\n同时，也不清楚如何构建或具体化该函数。\n\n\n\n网络结构：\n\n节点(Node)\n概率\n\n 五. 具体问题\n 1. SAT 问题\n I. 问题描述\n给定 CNF 中的命题公式，找到满足该命题公式的解释或证明该命题不可满足。\n II. 问题性质\nSAT 问题是一个 NP-complete 问题。\n III. 问题分析\n令 SSS 为基于 CNF 的知识库，SSS 是有限数量的命题变量。\n尝试所有可能的组合值，如果找到一个组合使得 SSS 满足，则解决了这个问题。否则 SSS 是不可满足的。\n但事实上，我们不需要枚举出所有可能的组合。一旦我们有了部分分配，我们可能就已经能够得到结论，这种部分分配不满足 SSS，例如 S=α∧βS = \\alpha \\land \\betaS=α∧β，那么在 α=False\\alpha = Falseα=False 时无论 β\\betaβ 为什么都不会满足 SSS，此时就无需枚举 β\\betaβ 的组合。\n IV. 问题的解法：DPLL 算法\nDPLL 是基于深度优先搜索 (DFS) 的：\n\n选择一个命题变量，将搜索分为两个分支：当变量为 TrueTrueTrue 时和 FalseFalseFalse 时。\n根据值进行简化公式。如果简化公式包含空子句，则它是不可满足的，无需在此分支进行进一步搜索。\n\n算法描述：\n\n\nDPLL(S) 方法，用于递归。\n输入：子句的集合 SSS\n输出：可满足返回 TrueTrueTrue，否则返回 FalseFalseFalse\n\n如果 []∈S[] \\in S[]∈S 那么返回 FalseFalseFalse\n如果 SSS 为空，那么返回 TrueTrueTrue\n否则选择一个变量 A∈SA \\in SA∈S\n令 S' = Propagate(S, A)。\n令 S'' = Propagate(S, !A)。\n返回 DPLL(S') or DPLL(S'')\n\n\n\nPropagate(S, A) 方法，用于简化。\n输入：子句的集合 SSS，文字 AAA\n输出：一个新集合 S′S&#x27;S′\n\n让 S′=∅S&#x27; = \\emptyS′=∅\n对于全部 c∈Sc \\in Sc∈S:\nif A∈cA \\in cA∈c，那么跳过该句子。（因为此时AAA让整个ccc都为真）\nelif A‾∈c\\overline{A} \\in cA∈c，那么让 S′=S′∪{c−A‾}S&#x27; = S&#x27; \\cup \\{c - \\overline{A}\\}S′=S′∪{c−A}。（因为 AAA 对 ccc 的评估没有影响了）\nelse S′=S′∪{c}S&#x27; = S&#x27; \\cup \\{c\\}S′=S′∪{c}。（该子句不受到 AAA 分配的影响）\n\n\n\nDPLL 也实现了一些加速：\n\n如果一个子句只包含一个文字，那么就将这个文字设置为 TrueTrueTrue。\n\n例如 {[A],[B,C]}\\{[A], [B, C]\\}{[A],[B,C]} 中可以令 A=TrueA = TrueA=True\n\n\n如果某一个命题变量在所有子句中仅出现在一个极性(polarity)中，例如只出现 AAA 或者只出现 A‾\\overline{A}A，那么我们就将这个命题变量设置为 TrueTrueTrue (正极性) 或者 FalseFalseFalse (负极性)。\n\n例如 {[A,B],[A,C]}\\{[A, B], [A, C]\\}{[A,B],[A,C]} 中可以令 A=TrueA = TrueA=True\n\n\n算法极大地依赖于选择哪个变量进行赋值，即 DPLL(S) 中的第 333 行。使用智能启发式算法来选择变量 AAA。\n\n 2. 约束满足问题 (Constraint Satisfaction Problem, CSP)\n I. 问题描述\n给出：\n\n变量的集合 x1,x2,...,xn{x_1, x_2, ..., x_n}x1​,x2​,...,xn​\n定义域 D1,D2,...,Dn{D_1, D_2, ..., D_n}D1​,D2​,...,Dn​\n\n定义域可以是有限也可以是无限的。\n\n\n约束(constraints)的集合 CCC\n\n对于每一个变量值 xi∈Dix_i \\in D_ixi​∈Di​ 找到一个值，使得限制 CCC 满足，或证明这个值不存在。\n其描述可以具体看(三.3.I 和 三.3.II)\n II. 问题性质\n约束满足问题是 SAT 问题的扩展，常用于建模数学问题。CSP 公式比 SAT 公式包含更多关于问题结构的信息。\nSAT 问题则是将定义域限制为 TrueTrueTrue 和 FalseFalseFalse。\n\n如果 CSP 问题拥有有限的定义域，那么其表达能力等同于 SAT 问题。（可以双向翻译）\n\n有些求解器可能会将 CSP 转化为 SAT。但通常会向 SAT 求解器提供有关问题结构的提示。\n\n\n无限定义域的 CSP 问题无法转化为 SAT。\nCSP 的公式通常更加紧凑和直观。\n\nCSP是一个面向现实生活的问题描述。CSP 不像 FOL 那样具有表现力；它不太可能是一个好的选择，例如，对于定理证明。\n 3. 图顶点染色问题 (Vertex Colouring Problem)\n给定一个无向无权图 G=(V,E)G = (V, E)G=(V,E)，其中 VVV 是顶点集，EEE 是边集，此外给定 kkk 种颜色。或者给每一个顶点 v∈Vv \\in Vv∈V 拥有一个颜色集合 L(v)L(v)L(v)，顶点 vvv 只能在该集合中选择颜色。\n问题是让所有的顶点都拥有一个颜色，并且没有两个相邻的顶点颜色相同。\n 五. Z3 python库\n 安装\npip install z3-solver\n 使用 smt2 作为z3的输入\nsmt2作为输入的python样例：\n1234567891011121314smt2program = &quot;&quot;&quot;(declare-const A Bool)(declare-const B Bool)(assert (and (xor A B) A))&quot;&quot;&quot;import z3s = z3.Solver()                           # z3解算器s.add(z3.parse_smt2_string(smt2program))  # 将smt2解析成约束条件，并添加到解算器中status = s.check()                        # 获取是否可满足print(status)                             # 打印可满足状态if status == z3.sat:                        print(s.model())                        # 打印模型\n输出结果：\n12sat[A = True, B = False]\n其中变量 smt2program 内容就是smt2的语法：\n\n\n注释：smt2 使用 ; 注释。\n\n\n函数：smt2 采用 括号前缀表示法 (parenthesised prefix notation)，由最早的函数式编程语言之一 LISP 使用而闻名。在这种表示法中，每对括号都是一个函数调用，括号中的第一个单词是函数名称，其余都是参数。形式如：(&lt;function name&gt; &lt;parameter 1&gt; &lt;parameter 2&gt; ...)。\n\n\n\n\n\n函数\n描述\n例子\n\n\n\n\nand\n逻辑和，可以用两个或多个参数\n(and A B C)\n\n\nor\n逻辑或，可以用两个或多个参数\n(or A B C)\n\n\nnot\n逻辑否\n(not A)\n\n\n=&gt;\n推导(Implication),即→\\to→\n(=&gt; A B)\n\n\n=\n等于，即  ⟺  \\iff⟺\n(= A B)\n\n\ndeclare-const\n声明一个变量。第一个参数是变量名称，第二个参数是变量类型\n(declare-const A Bool)\n\n\ndeclare-fun\n声明一个函数第一个参数是函数名第二个参数是一个括号组，内部是函数参数类型第三个参数是返回类型\n(declare-fun square (Int Int) Int)\n\n\ndeclare-datatype\n声明一个枚举(enumeration)数据类型第一个参数是一个数据参数的括号组，括号组中第一个参数是数据类型名称，第二个是参数名称(变量或者模板)第二个参数是一个构造函数的括号组，该括号组中参数是一个构造函数内容的括号组，括号组内容第一个参数是构造函数名称，其他参数为变量类型\n(declare-datatypes () ((Animal dog cat fox)))\n\n\nforall\n全部量词，第一个变量是一个变量的括号组，表示变量和变量类型第二个参数是一个谓词函数的括号组\n(forall ((x MyType) (y MyType)) (P x y))\n\n\nexists\n存在量词，第一个变量是一个变量的括号组，表示变量和变量类型第二个参数是一个谓词函数的括号组\n(exists ((x MyType) (y MyType)) (P x y))\n\n\nassert\n一个参数，断言该语句为true\nassert A\n\n\n\n 使用python直接作为z3的输入\n相关api如下，或参考该网站：\n\n\n\n类型\napi\n解释\n样例\n\n\n\n\n结算器\nSolver()\n获取结算器\ns = z3.Solver()\n\n\n变量声明\n布尔：Bool(name)整型：Int(name)\nname是一个字符串，表示变量名字\nA = z3.Bool('A')a = z3.Int('a')\n\n\n变量类型\n布尔：BoolSort()整型：IntSort\n用于函数类型声明\n\n\n\n布尔操作符\n逻辑与：And(??, ??, ..., ??)逻辑或：Or(??, ??, ..., ??)逻辑否：Not(??)逻辑推理：Implies(??, ??)逻辑等于：?? == ??\n返回True或者False\nAnd(A, B, C) A == B\n\n\n非布尔操作符\n可以直接使用python操作符+, &gt;,&gt;= 等求和：z3.Sum([])，参数是数组三元运算符：z3.If(A, B, C)，相当于 A ? B : C\n返回数值\na + b\n\n\n函数\nFunction(name, paraType, ..., paraType, returnType)\n函数名、参数类型、返回类型类型使用变量类型\nOnTop = Function('OnTop', IntSort(), IntSort(), BoolSort())s3.add(OnTop(A, B))\n\n\n断言/公式输入\nSolver().add(&lt;formula&gt;)\n每一个 add 相当于加入一个断言\ns.add(And(A, B))\n\n\n推理\nSolver().check()\n返回是否满足z3.sat 满足z3.unsat 不满足\nif s.check() == z3.sat:\n\n\n模型输出\nSolver().model().model().eval(??)\n返回符合断言的一种模型返回模型的特定变量。??是python的变量\nprint(s.model())print(s.model().eval(A))\n\n\n量词\nForAll(list, fun(param, ..., param))Exists(list, fun(param, ..., param))\nlist是量词参数，使用的应该是python的变量 fun是定义的Function()函数\nx = z3.Int('x')y = z3.Int('y')P = z3.Function('P', z3.IntSort(), z3.IntSort(), z3.BoolSort())s.add(z3.ForAll([x, y], P(x, y)))\n\n\n枚举型\n创建type = Datatype(type_name)type.declare(param_name)type = type.create()访问type.param_nametype.constructor(int)()z3.Const(const_name, type)\n创建类型及其应用\n\n\n\n\n 技巧\n\n证明蕴含(entailment)：\n\nZ3只能证明可满足性，即是否存在某一种例子可以使得所有断言都成立，也可以说是 ∃J,J⊨S∧α\\exists \\mathcal{J}, \\mathcal{J} \\models S\\land\\alpha∃J,J⊨S∧α。\n但是无法直接证明蕴含，即 ∀J,J⊨S→J⊨α\\forall \\mathcal{J}, \\mathcal{J} \\models S \\to \\mathcal{J} \\models \\alpha∀J,J⊨S→J⊨α。\n简单说就是只能证明存在，但是不能证明全部。\n此时我们可以将全部转化为存在，即利用 S⊨α→S∧¬α 不可满足S \\models \\alpha \\to S \\land \\neg\\alpha \\text{ 不可满足}S⊨α→S∧¬α 不可满足，将我们想要证明的公式 α\\alphaα 反转 ¬α\\neg \\alpha¬α 再证明是不是不可满足的即可。\n\n增加语句的数量减少限制从而提高效率\n\n例如要求一个队列中不能有重复的数，可以想到语句为 ∀xy,x≠y→list(x)≠list(y)\\forall x y, x \\neq y \\to list(x) \\neq list(y)∀xy,x=y→list(x)=list(y)\n很明显执行这个语句的时间复杂度是 Θ(n2)\\Theta(n^2)Θ(n2)\n可以修改为 mi≠mk,∀i&lt;km_i \\neq m_k, \\forall i &lt; kmi​=mk​,∀i&lt;k，其中 1&lt;k≤n1 &lt; k \\leq n1&lt;k≤n 进行枚举。\n例如长度为 333 的队列中，语句表示为：\nk=2,m1≠m2k = 2, m_1 \\neq m_2k=2,m1​=m2​\nk=3,m1≠m3,m2≠m3k = 3, m_1 \\neq m_3, m_2 \\neq m_3k=3,m1​=m3​,m2​=m3​\n时间复杂度为 O(n2)O(n^2)O(n2)，效率要比 Θ(n2)\\Theta(n^2)Θ(n2) 好得多。\n\n\n考虑代表解：\n一旦决定一个代表解的时候：\n\n引入符号(notation)\n定义规则\n定义常数\n\n\n\n公式组定义：\n\n辅助符号 NNN，例如集合，在公式上方定义。\n每组规则在单独的行中定义。\n规则组可以参数化，每个参数的定义域在右侧定义。\n\n例如 mi≠mk,∀i&lt;km_i \\neq m_k, \\forall i &lt; kmi​=mk​,∀i&lt;k，其中 i,ki, ki,k 是参数而不是限制。\n\n\n公式索引在括号中给出，以供以后引用（即使从未引用过这个公式，也给出索引）。\n\n使用 equation (i) 引用单个公式。\n使用 formulation (i)-(j) 引用多个公式。\n\n\n非逻辑符号定义在公式末尾。\n\n包括 D\\mathcal{D}D，例如 D=N\\mathcal{D} = ND=N。\n\n\n公式的每一行都在正式公式组下方进行解释。\n\n例如 equation (1) define ... rules\n\n\n\n\n\n 六. OR-Tools python库\n 安装\n!pip install ortools\n 相关api\n\n\n\n类型\napi\n解释\n样例\n\n\n\n\n模型\ncp_model.CpModel()\n模型，用于输入限制\nmodel = cp_model.CpModel()\n\n\n求解器\ncp_model.CpSolver()solver.Solve(model)solver.Value(var)\n获取求解器和求解cp_model.OPTIMA：最佳的cp_model.FEASIBLE：可行的\nsolver = cp_model.CpSolver()status = solver.Solve(model)\n\n\n变量声明\n整型：model.NewIntVar(min, max, name)布尔：model.NewBoolVar(name)\nmin最小值，max最大值，name是变量名\n整型：x = model.NewIntVar(0, 10, 'x')布尔：a = model.newBoolVar('a')\n\n\n一般限制\nmodel.Add(constraint)\n限制可以是python相关语法不能添加单变量，如果要添加某个变量为true，应该写为 a==1a == 1a==1\nmodel.Add(x &gt; y)\n\n\n推理限制\nmodel.Add(con).OnlyEnforceIf(a)model.AddImplication(a, b)  (bool only)\n如果 a 成立，那么 con 才成立等价于 a→cona \\to cona→con只能用在线性限制中，如Add, AddBoolOr, AddBoolAnd\nmodel.Add(x &gt; y).OnlyEnforceIf(a)\n\n\n不等于限制\nmodel.AddAllDifferent([])\n[ ][\\ ][ ]内部的所有变量都不相同\nmodel.AddAllDifferent([a, b, c])\n\n\n布尔限制\n或：model.AddBoolOr([])否定：bool_var.Not()\n[ ][\\ ][ ]内部的所有变量使用或运算\nmodel.AddBoolOr([a, b, c])\n\n\n最大最小值限制\n最大值：model.AddMaxEquality(var, list)最小值：model.AddMinEquality(var, list)\nvar 是 list 中的最大或者最小值\nmodel.AddMaxEquality(a, [b, c, d])\n\n\n属于内部值限制\nmodel.AddAllowedAssignments(list, set)\nlist 所有值必须在 set 中\nmodel.AddAllowedAssignments([a], [b, c])\n\n\n\n 技巧\n\n布尔变量与语句链接：\n\n布尔无法直接赋值为相关符号操作，例如 a == (b &gt; c) 是错误的。\n布尔应该使用   ⟺  \\iff⟺ 进行赋值。如上一个例子，可以转化为 a  ⟺  (b&gt;c)a \\iff (b &gt; c)a⟺(b&gt;c)\nOrTool中没有   ⟺  \\iff⟺，但是有 →\\to→。那么上述的代码就可以为:\n\n\n\n12model.Add(b &gt; c).OnlyEnforceIf(a)model.Add(b &lt;= c).OnlyEnforceIf(a.Not())\n\n可以使用 sum 计算布尔值为 True 的数量。\n\n 杂项\n\n大语言模型(Large Language Models, LLMs)属于符号学人工智能吗？\n\n虽然LLMs从训练集中学习模式，包括一些形式化的模式，但是LLMs并不使用形式化推理，而是基于统计相关性。\nLLMs看起来像是在推理，实际上只是在预测人类会通过输入会说些什么。\n因此LLMs并不属于符号学人工智能。但是可以与符号学人工智能一起使用。\n\n\n\n","slug":"笔记/笔记-SAI-符号人工智能","date":"2024-10-18T00:40:00.000Z","categories_index":"笔记","tags_index":"Algorithm,AI,Optimization","author_index":"zExNocs"},{"id":"359ddc0f0d8ca8ada4d26ac9b618d2df","title":"SDL","content":" 🔖介绍\nSDL是 c 语言的库，因此其主要是面向过程的函数。\n该笔记主要用于记录一些SDL常用的类和接口，以及其介绍。\n目前收录的库主要有下面几种：\n\nSDL 本体\nSDL_ttf 文字渲染\nSDL_image 图片渲染\nSDL_mixer 音媒体\nSDL_gfx 图形绘制\n\n SDL 文档\n\nSDL wiki\n\n SDL 常用类和相关接口\n带 ~ 的表示非类内部函数。\n 基础函数接口\n 1. 初始化相关\n\nint SDL_Init(Uint32 flags)：SDL初始化\n\nflags：相关标记\n\nSDL_INIT_EVERYTHING：初始化所有\n\n\n返回值\n\n0 表示初始化成功\n负数表示初始化失败\n\n\n\n\nSDL_bool SDL_SetHint(char* name, char* value)：SDL设置建议\n\nname：建议名称\n\nSDL_HINT_IME_SHOW_UI：显示 IME (候选词列表)\n\n\nvalue：启用值\n\n1：表示开启\n\n\n\n\nint IMG_Init(int flags)：SDL图片初始化\n\nflags：相关标记，标记之间用 | 来相隔\n\nIMG_INIT_JPG：jpg 格式图片\nIMG_INIT_PNG：png 格式图片\n\n\n返回值：返回初始化成功的值\n\n\nint Mix_Init()：音乐初始化\n\n返回值：返回初始化成功的值\n\n\nint Mix_OpenAudio(int frequency, Uint16 format, int channels, int chunksize)：打开播放器\n\n一般直接使用 Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048)\n返回值\n\n0：成功\n-1：失败\n\n\n\n\nint TTF_Init()：文字初始化\n\n返回值\n\n0：成功\n-1：失败\n\n\n\n\n\n SDL_Window 窗口类\n\n\n~ SDL_Window* SDL_CreateWindow(char* strTitle, int x, int y, int w, int h, Uint32 flags)：创建窗口函数\n\nstrTitle：窗口标题。例如 u8&quot;你好，世界&quot;。\nx：窗口所在屏幕横坐标\n\nSDL_WINDOWPOS_CENTERED：屏幕正中间\n\n\ny：窗口所在屏幕纵坐标\n\nSDL_WINDOWPOS_CENTERED：屏幕正中间\n\n\nw：窗口宽度\nh：窗口高度\nflags：相关标记\n\nSDL_WINDOW_SHOWN：展示窗口\n\n\n\n\n\n~ SDL_ShowSimpleMessageBox(Uint32 flags, char* strTitile, char* strMessage, SDL_Window* pWindow)：弹信息子窗口\n\nflags：窗口类型\n\nSDL_MESSAGEBOX_ERROR：错误类型窗口\n\n\nstrTitile：窗口标题\nstrMessage：窗口信息\npWindow：父窗口指针\n\n\n\n SDL_Renderer 渲染器\n用于控制如何在窗口 Window 类绘制图像，可以渲染 Texture 类。\n\n~ SDL_Renderer* SDL_CreateRenderer(SDL_Window* pWindow, int index, Uint32 flags)：创建渲染器函数\n\npWindow：渲染器所渲染的窗口\nindex：渲染器索引。初始值为 -1\nflags：相关标记，标记之间用 | 来相隔\n\nSDL_RENDERERR_ACCELERRATED：硬件加速\nSDL_RENDERER_PRESENTVSYNC：垂直同步\nSDL_RENDERER_TARGETTEXTURE：渲染目标为纹理\n\n\n\n\n~ SDL_RenderCopy(SDL_Renderer* pRenderer, )：TODO\n\npRenderer：渲染器指针\n\n\n~ SDL_RenderPresent(SDL_Renderer* pRenderer)：更新画面(类似于双缓冲)。\n\npRenderer：渲染器指针\n\n\n~ SDL_RenderClear()：TODO\n~ SDL_RenderClear()：TODO\n~ SDL_SetRenderDrawColor：TODO\n\n SDL_Surface 平面类\n平面类指的是内存中的图像表示，可以看做是一张位图，包含了图像的像素数据、宽度、高度和像素格式等信息。主要用于在CPU端进行图像操作，例如加载图像文件、处理像素数据、创建临时的图像等。\n平面类可以被修改绘制。\n\n~ SDL_Surface* IMG_Load(char* strPath)：加载图片，以 Surface 类的形式保存\n\nstrPath：图片路径\n\n\n~ SDL_Surface* TTF_RenderUTF8_Blended(TTF_font* pFont, char* strText, SDL_Color oColor)：加载文字，以 Surface 类的形式保存\n\npFont：字体类型\nstrText：文字\noColor：字体颜色\n\n\n\n SDL_Texture 纹理类\n纹理类是用于GPU端进行像素处理的对象，适合高效地图像渲染。包含了图像数据在显存中的表示。\n纹理类无法被修改，通常是使用平面类转化成纹理类，然后使用渲染器将其放在窗口上。\n\n~ SDL_Texture* SDL_CreateTexturreFromSurface(SDL_Renderer* pRenderer, SDL_Surface* pSurface)：将 Surface 类转化为 Texture 类\n\npRenderer：渲染器\npSurface：被转化的平面类\n\n\n\n SDL_Event 事件类\n\ntype：事件类型属性\n\nSDL_QUIT：退出类型\nSDL_MOUSEMOTION：鼠标移动类型\n\n\nmotion：鼠标移动类型相关参数\n\nx：当前鼠标横坐标\ny：当前鼠标纵坐标\n\n\n~ bool SDL_PollEvent(SDL_Event* pEvent)：拉取事件\n\npEvent：被获取的事件/被赋值的事件\n如果没有事件返回 false\n\n\n\n SDL_Color 颜色类\n TTF_Font 字体类\n\n~ TTF_Font* TTF_OpenFont(char* strPath, int iSize)：加载文字类型文件\n\nstrPath：文字类型路径\niSize：字体大小\n\n\n\n Mix_Music 音乐类\n\n~ Mix_Music* Mix_LoadMUS(char* strPath)：加载音乐\n\nstrPath：路径\n\n\n\n","slug":"笔记/笔记-SDL相关","date":"2024-07-01T16:05:30.000Z","categories_index":"笔记","tags_index":"SDL,CPP","author_index":"zExNocs"},{"id":"c540c9b9a4bdc44ea456b40df3a36e31","title":"塔防游戏笔记","content":" 🔖介绍\n该笔记主要参考于 v佬 Voidmatrix 的 C++双人塔防游戏开发 课程。\n该笔记的复刻项目源码为：点击传送\n本笔记的内容排序可能不会按照课程排序，而是根据内容进行分类归纳。\n本笔记主要由下面几个部分组成：\n一. 游戏引擎 (框架解剖)\n二. 塔防游戏用到的技术/技巧 (技术解剖)\n三. 游戏开发用到的设计模式 (技术解剖)\n四. 笔者的内容扩展 (框架扩展)\n五. 开发步骤 (实践步骤)\n六. 补充\n本笔记从各个游戏组成成分进行解剖，并介绍其功能和作用，然后开始介绍游戏开发的步骤。\n此外，本笔记额外添加了课程中没有的一些功能，例如对可绘制平面的封装来实现前景和背景分离。\n\n 一. 游戏引擎\n 基本框架介绍\n正如所有游戏设计那样。\n 数据文件的概念和设计\n在本游戏设计中，数据文件主要有三个方面组成，分别是地图文件map.csv、配置文件config.json和关卡文件level.json组成。\n 1. 地图文件\n地图文件是使用 csv 格式储存的二维网格数组文件。\n每个单元格储存每个瓦片tile的数据，每个数据格式为 terrian\\decoration\\direction\\special，都为整型：\n\nterrian：地形瓦片。表示地形图片的 id 索引。\ndecoration：装饰瓦片。表示装饰图片的 id 索引。如果没有装饰，则为 -1。\ndirection：行进路线。表示敌人的行进路线，上下左右。如果不进行走路，则为 -1。\nspecial：特殊标志。例如防守位点、敌人生成点。如果没有特殊标志，则为 -1。\n\n在本游戏中，特殊标志约定 0 为防守位点，1 ~ 8 表示敌人不同的生成点。\n\n\n\n 2. 配置文件\n配置文件是使用 json 储存各种数据和角色数值的文件。\n其整体是一个对象类，储存了三大对象类，分别是 basic 基础数据、player 玩家数据和 enemy 敌人数据。\n其形式和层级如下：\n\nbasic：对象型。储存基础数据。\n\nwindow_title：字符串型。窗口标题。\nwindow_width：整型。窗口宽度。\nwindow_height：整形。窗口高度。\n\n\nplayer：对象型。储存玩家的属性。\n\nspeed：整型。玩家的速度，以 单位 作为单位，表示一个网格，即每秒移动网格的距离。\nnormal_attack_interval：浮点型。普通攻击的时间间隔。\nnormal_attack_damage：整型。普通攻击的伤害值。\nskill_interval：浮点型。技能的攻击间隔。\nskill_damage：整型。技能的伤害值。\n\n\ntower：对象型。储存各类防御塔的属性。防御塔可以升级。\n\n&#123;typeName&#125;：对象型。储存该类防御塔的各种属性。\n\ninterval：浮点型的数组。表示各个等级时的攻击间隔。\ndamage：整型的数组。表示各个等级的伤害。\nview_range：整型的数组。表示各个等级的视野范围，以 单位 作为单位。\ncost：整型的数组。表示卖出的价格。\nupgrade_cost：整型的数组。表示升级到下一个等级需要的花费。\n\n\n\n\nenemy：对象型。储存各类敌人的属性。\n\n&#123;typeName&#125;：对象型。储存各类敌人的属性。\n\nhp：整型。敌人的血量。\nspeed：浮点型。敌人的速度。\ndamage：整型。敌人的攻击伤害。\nreward_ratio：浮点型。奖励的概率。\nrecover_interval：整型。恢复的间隔。\nrecover_range：整型。恢复的范围。以单位为单位。-1 表示不进行恢复。\nrecover_intensity：整型。恢复的强度。\n\n\n\n\n\n 3. 关卡文件\n关卡文件是使用 json 文件来控制每波次的怪物生成。\n其整体是一个数组类型，该数组类型储存成员为对象类型，表示每个波次的数据。数组的长度就是波次的数量。\n对于每个波次，其形式如下：\n\ninterval：整型。表示距离上个波次结束后多少秒开始本次本波次。\nrewards：整型。表示完成这个波次后奖励的金币数。\nspawn_list：对象型的数组型。表示一个生成事件。\n\ninterval：整型。表示距离上个生成事件过后多少秒后开始生成。\npoint：整型。表示怪物的出生点位置。\nenemy：字符串型。表示该生成事件生成的怪物类型。\n\n\n\n注意每个波次的结束指的是该波次生成的所有敌人被清空。每个波次的开始是在上个波次结束后经过 interval 秒开始。\n而每个生成事件的结束是该生成事件生成完敌人后结束，而不是该敌人死亡后结束。每个生成事件的开始是在上个生成事件结束后经过 interval 秒后开始。\n 引擎框架类及其作用\n 1. GameManager 游戏管理器\n 介绍\n是游戏的主要引擎。用于初始化窗口、渲染器，并启动游戏的主循环。\n在我的项目中称之为 BaseEngine 而不是 GameManager。\n 方法和功能\n\n 二. 塔防游戏中用到的技术/技巧\n 1. 洋流图预烘焙寻路\n游戏中有很多寻路算法，例如比较常用的 A* 寻路算法。但是如果在塔防游戏中使用 A* 算法可能会出现一些无法预料的情况。\n在塔防游戏中，我们更偏向于让敌人按照指定的路径(静态的)来寻走而不是动态生成的。这种静态的路径我们可以称之为 洋流图。\n洋流图将会在地图缓存的阶段进行生成，这个过程可以称之为预烘焙。\n在该项目中，我们使用 Route 类来储存洋流图。\nRoute 类本质上是一个 从某个点出发(出发点) 所经历所有点的路径 类，是一种点的容器/索引类。\n在地图缓存阶段，我们将所有怪物刷怪点为出发点来储存这些路径，并\n初始化 Route类注意的点：\n\n何时停止储存\n\n超过地图边界\n点重复储存\n到达终点\n下一个目标点是非移动点\n\n\n循环路径处理\n\n在原视频中，实际上并没有对循环路径进行更多的处理。如果真的会出现循环路径，\n\n\n\n为什么要用 Route 类而不直接用 Tile 类来进行控制敌人移动呢？\n在该项目中，我个人更偏向于直接使用 Tile 类来直接控制敌人移动。\n实际上，如果使用 Route 类而不直接使用 Tile 类一方面可以实现 Tile 类与 敌人类的解耦，而让与移动更有关联的 Route 类 来和敌人类进行关联。另一方面可以在不同的Tile类型或者直接手动编写Route来实现多层地图路径，也就是说在一条路径中即使经历过重复的点，可以在不同经历次数中有不同的移动方向。\n\n 三. 游戏开发用到的设计模式\n 1. 单例设计模式\n 介绍\n单例设计模式(Singleton Design Pattern)指的是使用该设计模式的类在进程中最多只有一个实例。\n其最大的特点就是不允许外部来创建该类的实例，而是提供一个内部静态函数/方法来间接创建该类：\n\n构造函数 的访问类型是私有的(private)或者保护的(protected)。\n赋值构造函数和 = 符号重载为 delete 的方式来防止子类使用基类的构造。\n\n具体内容可以参考 VoidGameSpace 这个文章: 点击跳转\n 游戏开发中使用样例\n一般游戏开发中的各种 Manager 会使用单例设计模式来实现。\n可以使用 模板 + 继承 的方式实现各个衍生的 Manager 返回其指定的类而不是其基类。\n\n 四. 笔者的内容扩展\n除了课程中讲述的基础内容外，结合之前我大作业的经历以及对游戏引擎的理解 (和对优雅实现的追求)，我本人使用了下面的方法对该游戏项目进行了进一步扩展：\n 1. 使用智能指针管理内存\n 2. 背景与前景分离\n 3. 游戏引擎类的虚函数\n 4. 使用观察者设计模式设计所有可更新、可绘制对象\n与课程中的内容不同的是，我并不是将各自的 Manager 类直接在主循环的数据更新操作中一一调用进行更新，而是使用 Updatable、Renderable 接口和在引擎中定义该接口的容器来进行统一更新。而各自的 Manager 类进行的操作是在引擎类的接口容器中添加或删除自己管理的对象。\n该做法的优点是选择让底层代码去贴合高层代码（先确定高层代码的需求，是一种多态性的实现），降低了高层代码对底层代码的依赖性，增加了灵活性、可维护性和可测试性，也增加了引擎的可扩展性。\n该做法基于的思想是使用 观察者设计模式，其基本思想如下：\n观察者设计模式的本质实际上是一种观察者的容器，每当事件触发时就通知容器中的所有观察者进行更新。\n所有互动游戏都是时间性模拟的(游戏引擎架构（第二版）)。主循环中的数据更新部分就是一种基于时间对可更新对象进行更新数据的操作，大部分可更新对象都是随着时间自动进行更新的，那么就相当于这些可更新对象属于一种观察者，而被观察的事件是时间，即每当时间进行流动的时候（或者说是流动一定的时间后）进行更新。\n基于上述的理念，我将游戏主循环中的“数据更新”理解成 “因为时间进行流动，所以要对这些对象进行更新”，因此就有了这种将时间作为观察对象进行数据更新的观察者模型：当到达一定的时间后 (1000 / FPS毫秒)，通知所有观察者。而对于这些根据时间进行自动更新的对象来说，被通知的动作就是更新 on_update()。\n一般来说这些基于时间进行更新的对象包括正在移动的对象、主动更新的对象、计时器等。\n除了基于时间进行更新的对象以外还有一些被动更新的对象，例如被其他对象杀死的对象、等待用户输入处理的对象等。\n此外，几乎所有的渲染都是根据数据进行绘制的，因此所有物体的渲染也可以被视为一种观察者模型，观察者是所有可绘制的对象，而被观察的事件是数据更新。即每次数据更新都需要通知物体进行渲染。\n综上所述，所有基于时间进行更新的对象是一种观察者模型，其观察的事件是时间；所有可绘制的对象是一种观察者模型，其观察的事件是数据更新。\n 5. 将渲染功能丢给瓦片\n与课程中 Tile 结构体只是储存数据不同，我使用\n\n 五. 开发步骤\n 1. 构造基础的游戏框架 (GameManager类)：\n\n初始化 SDL 组件，创建相关窗口、渲染器，并分析可能发生的错误。\n创建主循环函数。\n\n\n 六. 补充：\n 1. SDL 有关内容\n参考 这篇笔记。\n 2. cJSON 有关内容\ncJSON 主要是包含 cJSON 结构体。\ncJSON 结构体是一个类似于双向链表的树形结构，使用next 和 prev 指针指向相同层的前后数据，使用 child 指针指向下一层的数据(对象类型的子数据或者数组类型的成员，统称为子节点)。\n因为 cJSON 是使用c语言进行编写，所以其是一个面向过程的类型，不具有成员函数/方法。\n &gt; cJSON 结构体变量\n\nint type：该节点的数据类型。\n\ncJSON_Invalid：不合理的类型\ncJSON_False：布尔false 类型\ncJSON_True：布尔true 类型\ncJSON_NULL：null 类型\ncJSON_Number：数字类型\ncJSON_String：字符串类型\ncJSON_Array：数组类型\ncJSON_Object：对象类型\ncJSON_Raw：raw json，生 json 类型\n\n\nchar* string：如果该节点是一个内部节点，那么该变量储存该节点的名字。\nchar* valuestring：如果该节点是字符串类型或者raw json，那么该变量储存该字符串。\nint valueint：如果该节点是数字的整型类型，那么该变量储存该整型。\ndouble valuedouble：如果该节点是数字的浮点类型，那么该变量储存该浮点型。\ncJSON* next：如果该节点是某个对象类型的子数据 或者 数组类型的成员，那么该变量指向下一个节点。\ncJSON* prev：如果该节点是某个对象类型的子数据 或者 数组类型的成员，那么该变量指向上一个节点。\ncJSON* child：如果节点是 对象类型 或者 数组类型，那么该变量指向其子节点。\n\n &gt; cJSON 函数\n\ncJSON* cJSON_Parse(char* str)：将字符串str解析成 cJSON 类并返回该对象类型的指针。\ncJSON* cJSON_GetObjectItem(cJSON* object, char* string)：返回对象类型object中名字为 string 子数据。\n\n &gt; cJSON 宏定义\n\n#define cJSON_ArrayForEach(cJSON* element, cJSON* array)：遍历数组类型array的所有成员作为element。\n\n一般使用下面的代码来读取一个 .json 文件：\n1234567891011// 打开文件std::ifstream file(&quot;文件名.json&quot;);if(!file.good()) &#123; 报错 + 退出 &#125;// 使用stringstream来读取整个字符串std::stringstream str_stream;str_stream &lt;&lt; file.rdbuf();file.close();// 解析cJSON* root = cJSON_Parse(str_stream.str().c_str());\n 3. 项目创建和环境搭建\n 下载相关库\n选择带 VC 的包下载\n\nSDL 本体\nSDL_ttf 文字渲染\nSDL_image 图片渲染\nSDL_mixer 音媒体\nSDL_gfx 图形绘制\ncJSON\n\n 导入库\n在项目根目录中新增 thirdparty 文件夹，将下载的库解压放入其中。\n使用相对路径将库添加到项目中：\n右键选择相应的解决方案资源管理器，如本项目中的 TowerrDefenseGame_Copybat，选择 属性：\n\n导入头文件：依次点击 C/C++ → 常规 → 附加包含目录 → &lt;编辑...&gt; → 新行，输入 ..\\thirdparty\\&lt;相关库&gt;\\include。\n导入静态链接器：\n\n目录：依次点击 链接器 → 常规 → 附加库目录 → &lt;编辑...&gt; → 新行，输入 ..\\thirdparty\\&lt;相关库&gt;\\lib\\x64\n输入：依次点击 链接器 → 输入 → 附加依赖项 → &lt;编辑...&gt;，输入所有 thirdparty\\&lt;相关库&gt;\\lib\\x64 路径下所有后缀 .lib 的文件名和后缀。123456SDL2.libSDL2main.libSDL2_ttf.libSDL2_mixer.libSDL2_image.libSDL2_gfx.lib\n\n\n\n导入动态链接器：将动态链接器 dll后缀文件 复制到相应的解决方案目录下。\n导入源码库：将源码库的 .c 文件直接拖拽到 解决方案资源管理器 &gt; 解决方案 &gt; 源文件 中。\n\n","slug":"笔记/笔记-塔防游戏笔记","date":"2024-06-25T20:47:56.000Z","categories_index":"笔记","tags_index":"Game Engine,SDL,CPP","author_index":"zExNocs"},{"id":"f6a638c0d2b2761842a94c4b2e02a042","title":"如何提交文章到VoidGameSpace上","content":"本文章仅适用于VoidGameSpace论坛及其GitHub库。\n该教程目前仅适用于Windows系统。\n官方博客传送面板\n 如何使用github进行提交\n 一. 确认Git安装\nGit下载地址: Link\n测试Git：打开 cmd 或者 PowerShell，输入 git -v 可以查看到当前Git的版本。\n 二. 配置Git设置和SSH\n\n使用下面两个指令配置Git全局设置：\n\n12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱&quot;\n\n配置ssh设置：可以参考这个文章\n\n\n使用 ssh-keygen -t rsa -C &quot;你的邮箱&quot;，一路回车生成SSH。\n找到文件C:\\User\\用户名\\.ssh\\id_rsa.pub，使用记事本打开并复制里面的内容。\n打开GitHub在Settings界面左边找到SSH and GPG keys进入。\n点击 New SSH key，在title中填入合适的标题，在SSH中填入刚刚复制的内容。\n本地指令输入 ssh -T git@github.com 验证是否配置成功。\n\n 三. fork库到自己的库中\n打开 GitHub库 网页，点击右上角 Fork 按钮，复制该库到自己的库中。\n选择owner为自己的账户，Repository name可以设置为默认GameDevWebsite。\nDescription用来描述这个库，可以随便写一些，例如：VoidGameSpace论坛的Fork库。\n点击 Create fork 按钮。\n 四. clone库到本地\n进入自己的库中找到刚刚fork的GameDevWebsite库，一般为 https://github.com/用户名/GameDevWebsite\n找到 &lt;&gt; Code 绿色按钮，在本地中使用 PowerShell 打开想要部署的位置 or 在部署的位置中右键选择在终端打开 or 使用cmd cd 到要部署的文件夹，使用下面三种方式之一克隆库到本地\n\n使用HTTPS，复制web URL，输入git clone 复制的URL部署。这个方法需要你在终端登录到Git中。\n使用SSH，复制SSH key，输入git clone 复制的SSH_key部署。\n点击Download ZIP，下载压缩包到要部署的文件夹并解压。\n\n 五. 编写自己的文档\n在部署的项目目录GameDevWebsite中，路径source\\_posts\\创建自己的文件夹，并在文件夹中创建.md文件，参考GitHub库中元数据说明，编写自己的文章。\n另外，markdown的编写可以参考官方文档：Link\n 六. 提交文档到自己fork的库中\n使用 PowerShell 打开项目目录GameDevWebsite，或者在目录中右键点击在终端打开，或者使用cmd cd到目录。\n\n创建自己的分支(可选，新手建议直接修改main分支)：使用 git checkout -b 分支名 创建并切换到新的分支。(分支的作用是保证main分支的干净，一般只有最终版本才会合并到main分支)。如果你已经创建过分支，就不需要再创建该分支了。\n添加所有文件到暂存区： git add .\n提交添加的文件： git commit -m &quot;修改描述&quot;。为了养成好习惯，修改描述要有一定的准则。例如你修改文档可以写 &quot;docs(你的名字): 添加了xxx文章&quot;。具体准则可以自行搜索学习一下。\npush库：如果你使用的是新建的分支，使用git push origin 分支名 将新分支push到库中。如果你使用的是main分支或者是已经创建的库，那么使用 git push 将提交的内容push到库中。\n\n 七. 拉取申请\n找到自己fork的库，点击左上方 Pull requests按钮，进入页面点击右上方New pull request按钮。左边是合并的基库，右边是申请合并的库。在右边申请的库中选择自己的库和分支(如果没有创建分支就选择main)，然后填写一些申请描述即可。\n 八. 等待审核\n建议留言压力v佬(bushi)\n","slug":"随笔/随笔-如何提交文章到VoidGameSpace上","date":"2024-05-28T14:06:44.000Z","categories_index":"随笔","tags_index":"VoidGameSpace,Hexo","author_index":"zExNocs"},{"id":"adebda0f2ffe945e89a74452ba03c888","title":"让Aurora支持KaTeX和Emoji","content":" ✒️背景\n最早接触markdown是在洛谷的个人博客时使用的。其中有一个功能我特别喜欢用，就是用$$符号展示出的公式，类似于这样：f(x)=eΔkTf(x)=e^{\\frac{\\Delta}{kT}}f(x)=ekTΔ​，以至于以后只要用到有关字母公式的地方就会喜欢性地打出$$。\n但是我在使用Aurora的时候，发现它并不能直接使用$$公式，研究发现是Hexo默认的markdown渲染器不支持KaTeX，故有此文章来研究如何让Hexo支持。\n 🔖内容\nHexo的markdown渲染器有很多种：Hexo多种Markdown渲染器对比分析。\nHexo自带的markdown渲染器不支持KaTeX，也不支持emoji。而网络上常见的pandoc在部署到Aurora时会出现很多问题。这里我使用的是markdown-it-plus，它原生就支持emoji和KaTeX插件。具体步骤如下：\n\n卸载原生渲染器 npm un hexo-renderer-marked --save\n安装新渲染器 npm i hexo-renderer-markdown-it-plus --save\n添加选项：在根目录下_config.yml添加以下字段：\n\n12345678910markdown_it_plus:    highlight: true    html: true    xhtmlOut: true    breaks: true    langPrefix:    linkify: true    typographer:    quotes: “”‘’    pre_class: highlight\n\n添加css：在根目录下_config.aurora.yml找到injects字段，并添加css，参考如下：\n\n12345678#! ---------------------------------------------------------------#! Injections#! @docs https://aurora.tridiamond.tech/guide/site-meta.html#custom-meta#! ---------------------------------------------------------------injects:  scripts:  css:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css&quot;&gt;\n\n清理并重新生成Hexo hexo clean &amp; hexo g -d\n\n 📘Reference\n\nHexo多种Markdown渲染器对比分析: https://zsyyblog.com/b73ceb85.html\nhexo-renderer-markdown-it-plus官方文档：https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus\nAurora官方插件文档：https://aurora.tridiamond.tech/cn/configs/site-meta.html\n\n","slug":"随笔/随笔-让Hexo支持KaTeX和Emoji","date":"2024-05-27T13:05:16.000Z","categories_index":"随笔","tags_index":"Hexo","author_index":"zExNocs"},{"id":"73d7dfafb67dace1acc85c5d06f9d410","title":"记录网友怪话","content":"←返回导航\n\n\n\n\n","slug":"随笔/随笔-记录网友怪话","date":"2024-05-25T14:52:15.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"42a0ebda98bbb32611bf2a3997bf2270","title":"梗图","content":"←返回导航\n 娱乐向\n\n\n\n\n\n\n\n\n\n\n\n\n 提问向\n\n提问的艺术\n\n\n\n\n\n提问收费表\n\n\n\n","slug":"随笔/随笔-梗图","date":"2024-05-25T13:55:45.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"49266c0927eaad653ea21227e55d59fb","title":"LAC - Formal Languages and Automata Theory 形式语言与自动机理论","content":" ✒️背景\n课程原名为Languages and Computation(语言与计算)，但是这很明显是一个比较笼统的名字。本课程的主要内容还是将有关形式语言与自动机理论的知识。\n关于自动机，早在学习算法竞赛的时候有学过AC自动机(Aho-Corasick automaton, 是字典树 + KMP算法 + 自动机的结合)的知识，但是并没有建立有关自动机的系统性概念。\n此外，在学习做游戏AI的时候，有接触过关于状态设计模式的概念，游戏AI是一个巨大的状态自动机，因此我也利用这个方法在我CPP课程的游戏里设计了敌人的AI，具体可以参考这个笔记: 简单游戏引擎开发笔记。\n 🔖介绍\n本笔记主要参考 课程课件 与 视频-形式语言与自动机+哈工大(BV1oE4116794)。\n本笔记主要分为下面六个主要部分(并不是按照课程顺序排序，而是相似课程归纳)：\n\n一. 基本概念\n二. 正则语言(Regular)\n\n正则文法(Regular Grammar)\n\n正则表达式(Regular Expressions)\n\n\n有限状态自动机(FSA)\n\n确定的有穷自动机(DFA)\n非确定的有穷自动机(NFA)\n\n\n泵原理(Pumping Lemma)\n\n\n三. 上下文无关语言(CFL)\n\n上下文无关文法(CFG)\n非确定性下推自动机(PDA)\n确定性上下文无关语言(DCFL)\n\n确定性下推自动机(DPDA)\n\n\n泵原理(Pumping Lemma)\n\n\n四. 上下文相关语言(CSL)\n\n上下文相关文法(CSG)\n线性有界非确定性图灵机\n泵原理(Pumping Lemma)\n\n\n五. 递归可枚举语言(REL)\n\n递归可枚举文法(REG)\n图灵机(Turing machines)\n\n\n六. 其他\n\n每种语言通常由文法、自动机、泵原理来解释。\n\n 一. 基本概念\n\n\n字符：指的是可打印符号和一些不可见的控制字符，是不可分割的符号/字符/字形。通常由小写字母 a b ca\\ b\\ ca b c 表示。\n\n\n字母表 Σ\\SigmaΣ：字符的非空有穷集合。通常由希腊字母表示。\n\n\n字符串：隶属于某字母表 Σ\\SigmaΣ 中字符组成的有穷序列。通常由小写字母 x y zx\\ y\\ zx y z 表示。\n\n空字符串 ε\\varepsilonε：由0个字符的串，隶属于任何字母表 Σ\\SigmaΣ。空字符串不是字符，即 ε∉Σ\\varepsilon \\notin \\Sigmaε∈/Σ。由 epsilon  ε\\varepsilonε表示。\n字符串长度 ∣x∣|x|∣x∣：表示字符串由多少个字符组成，递归定义为：∣x∣={0x=ε∣y∣+1x=ya|x| = \n\\begin{cases}\n  0 &amp; x = \\varepsilon \\\\\n  |y| + 1 &amp; x = ya\n\\end{cases}\n∣x∣={0∣y∣+1​x=εx=ya​\n\n字符 aaa 和字符串 xxx 之间的连接：连接头 axaxax，连接尾 xaxaxa。\n字符串 xxx 和 字符串 yyy 之间的连接：xyxyxy 或者 x⋅yx \\cdot yx⋅y。其中 ε⋅x=x⋅ε=x\\varepsilon \\cdot x = x \\cdot \\varepsilon = xε⋅x=x⋅ε=x。\n字符串的幂：xn=xn−1⋅x(n≥1)x^n = x^{n - 1} \\cdot x (n \\geq 1)xn=xn−1⋅x(n≥1) 且 x0=εx^0 = \\varepsilonx0=ε。\n\n\n\n字符串的集合：通常由 大写字母 AAA BBB 表示。\n\n空集 ∅\\varnothing∅。注意 ∅≠{ε}\\varnothing \\neq \\{\\varepsilon\\}∅={ε}。 ∅\\varnothing∅ 的长度为 000，而 {ε}\\{\\varepsilon\\}{ε} 长度为 111。\n集合 AAA 和 集合 BBB 之间的连接：记为 ABABAB 或者 A⋅BA \\cdot BA⋅B，公式为(排列组合)：A⋅B={w∣w=x⋅y,x∈A∧y∈B}A \\cdot B = \\{w | w = x \\cdot y, x \\in A \\wedge y \\in B\\}\nA⋅B={w∣w=x⋅y,x∈A∧y∈B}\n\n集合的幂：An=An−1⋅A(n≥1)A^n = A^{n - 1} \\cdot A (n \\geq 1)An=An−1⋅A(n≥1) 且 A0={ε}A^0 = \\{\\varepsilon\\}A0={ε}。其中，∅n=∅(n≥1)\\varnothing ^ n = \\varnothing (n \\geq 1)∅n=∅(n≥1) 且 ∅0={ε}\\varnothing ^ 0 = \\{\\varepsilon\\}∅0={ε}。\n\n\n\n字母表的幂：Σn\\Sigma ^ nΣn 表示隶属于字母表 Σ\\SigmaΣ 且所有长度为 nnn 的字符串集合 (是字符串的集合而不是字符的集合，字符之间排列组合)。\n\n其中 Σ0={ε}\\Sigma ^0 = \\{\\varepsilon\\}Σ0={ε}。\n注意 Σ≠Σ1\\Sigma \\neq \\Sigma ^1Σ=Σ1，前者是字符的集合，后者是长度为 111 的字符串的集合。\n克林闭包 (Kleene Closure) Σ∗\\Sigma ^*Σ∗：Σ∗=⋃i=0∞Σi=Σ0∪Σ1∪Σ2∪...\\Sigma ^* = \\bigcup_{i=0}^{\\infty} \\Sigma^i = \\Sigma^0 \\cup \\Sigma^1 \\cup \\Sigma^2 \\cup ...\nΣ∗=i=0⋃∞​Σi=Σ0∪Σ1∪Σ2∪...\n\n有 ∅∗=∅0={ε}\\varnothing ^ * = \\varnothing ^ 0 = \\{\\varepsilon\\}∅∗=∅0={ε}。\n\n\n正闭包 (Positive Closure) Σ+\\Sigma ^+Σ+：Σ+=⋃i=1∞Σi=Σ1∪Σ2∪Σ3∪...\\Sigma ^+ = \\bigcup_{i=1}^{\\infty} \\Sigma^i = \\Sigma^1 \\cup \\Sigma^2 \\cup \\Sigma^3 \\cup ...\nΣ+=i=1⋃∞​Σi=Σ1∪Σ2∪Σ3∪...\n\n那么 Σ∗=Σ+∪{ε}\\Sigma ^* = \\Sigma ^+ \\cup \\{\\varepsilon\\}Σ∗=Σ+∪{ε}。\n有 ∅+=∅\\varnothing ^ + = \\varnothing∅+=∅。\n\n\n\n\n\n子集的集合：定义 P(Q)={S∣S⊆Q}\\mathbb{P}(Q) = \\{S|S \\subseteq Q\\}P(Q)={S∣S⊆Q}，即 P(Q)\\mathbb{P}(Q)P(Q) 是  QQQ 的所有子集的集合(集合的集合)，包括空集。\n\n数量上 ∣P(Q)∣=2∣Q∣|\\mathbb{P}(Q)| = 2^{|Q|}∣P(Q)∣=2∣Q∣。\n\n\n\n语言(Language) LLL：若 Σ\\SigmaΣ 为字母表， LLL 是字符串的集合，且 L⊆Σ∗L \\subseteq \\Sigma ^*L⊆Σ∗，那么就称语言 LLL 是字母表 Σ\\SigmaΣ 上的语言。\n\n语言是一种字符串的集合。\n∅,{ε}\\varnothing, \\{\\varepsilon\\}∅,{ε} 是任何字母表上的语言。\n\n\n\n文法(Grammar) GGG：是一种语言结构的规则集合，可以是自然语言也可以是形式语言(例如正则表达式)。文法规定了哪些字符串是有效的(符合文法规则的)，哪些是无效的。\n\n文法通常由 终结符、非终结符、产生式 集合组成，定义了如何使用起始符号(Start Symbol)和产生式集合来构建合法的语言。\n终结符(Terminal Symbol)是语言的最基本符号，是构成语言的最小单元，且无法使用文法规则更改成其他符号。终结符可以是任何字符或符号。\n\n字符相比终结符更宏大。例如跳脱出理论，本笔记中所有的字都属于&quot;字符&quot;，用来描述非终结符的符号也属于&quot;字符&quot;。但在形式语言理论的描述中，我们的字符通常指的是终结符。\n在形式语言理论的描述中，字母表也可以被视为终结符的集合，字符串也可以被视为终结符的序列。\n\n\n非终结符(Nonterminal Symbol)，也可以叫 变元 和 文法范畴，是一种文法变量，是一种描述语言结构的符号。可以通过文法规则进行组合和转换，生成新的结构。\n产生式(Production) 描述如何将一个非终结符替换为终结符 和/或 其他非终结符序列。\n\n由被称为头或者左部的终结符、产生式符号 →\\to→ (读作定义为)、被称为体或右部的终结符 和/或 非终结符的序列 组成。\n\n例如 A→aBA \\to aBA→aB，其中 A,BA, BA,B 是非终结符，aaa 是终结符。读作 AAA 定义为 aBaBaB。\n例如 A→αA \\to \\alphaA→α，其中 AAA 是非终结符，α\\alphaα 是终结符 和/或 非终结符的序列，如 aBaBaB 属于一种 α\\alphaα。\n\n\n一个左部可以拥有多个右部，不同右部之间用 ∣|∣ 隔开。\n\n例如 A→aB∣a∣εA \\to aB|a|\\varepsilonA→aB∣a∣ε\n\n\n非终结符 AAA 的全体产生式被称为 AAA 产生式。\n\n\n文法的规约和派生(Specification and Derivation)：\n\n从 字符串 到 非终结符/变元 的分析过程称之为 递归推理 或 规约 (Specification)。\n\n规约是自底向上的，由产生式的 体向头 的方向分析。\n例如给出一个字符串来推理出文法产生该语言的过程。\n\n\n从 文法变元 到 字符串 的分析过程称之为 推导 或 派生 (Derivation)。\n\n派生是自顶向下的，由产生式的 头向体 的方向分析。\n一次派生的符号是 ⇒G\\underset{G}{\\Rightarrow}G⇒​，多次派生的符号是 ⇒G∗\\overset{*}{\\underset{G}{\\Rightarrow}}G⇒​∗​。\n只改变符号中最左边变元的派生过程被称为 最左派生，一次派生的符号是 ⇒lm\\underset{lm}{\\Rightarrow}lm⇒​，多次派生的符号是 ⇒lm∗\\overset{*}{\\underset{lm}{\\Rightarrow}}lm⇒​∗​。\n只改变符号中最右边变元的派生过程被称为 最右派生，一次派生的符号是 ⇒rm\\underset{rm}{\\Rightarrow}rm⇒​，多次派生的符号是 ⇒rm∗\\overset{*}{\\underset{rm}{\\Rightarrow}}rm⇒​∗​。\n任何派生都有其最左派生和最右派生，即 A⇒G∗w  ⟺  A⇒lm∗w  ⟺  A⇒rm∗wA \\overset{*}{\\underset{G}{\\Rightarrow}} w \\iff A \\overset{*}{\\underset{lm}{\\Rightarrow}} w \\iff A \\overset{*}{\\underset{rm}{\\Rightarrow}} wAG⇒​∗​w⟺Alm⇒​∗​w⟺Arm⇒​∗​w\n\n\n\n\n\n\n\n自动机(Automata) AAA：可以被称为机器(machine)。用于模拟具有有限个状态的机器或系统的行为，可以根据输入来改变当前状态，并且能够自动地按照预定的规则进行操作。自动机往往用于识别语言。\n\n自动机通常由状态集合 QQQ、可被识别的字母表 Σ\\SigmaΣ、状态转移函数 δ\\deltaδ、初始状态(集合)、接受状态集合 F∈QF \\in QF∈Q 和其他组成成分组成。\n往往用 L(A)L(A)L(A) 来表示该自动机可以识别的语言集合。\n确定性自动机：每个状态接收任何输入转移的状态唯一，在识别语言的过程每个阶段状态具有唯一性。\n\n对于任意 q∈Qq \\in Qq∈Q, a∈Σa \\in \\Sigmaa∈Σ，δ(q,a)\\delta(q, a)δ(q,a) 有且只有一个结果，是确定且固定的。\n通常 δ:Q×Σ→Q\\delta: Q\\times\\Sigma \\to Qδ:Q×Σ→Q。\n\n\n非确定性自动机：每个状态接收输入转移的状态不唯一。\n\n对于即对于任意 q∈Qq \\in Qq∈Q, a∈Σa \\in \\Sigmaa∈Σ，δ(q,a)\\delta(q, a)δ(q,a) 可以有多个结果。\n通常 δ:Q×Σ→P(Q)\\delta: Q\\times\\Sigma \\to \\mathbb{P}(Q)δ:Q×Σ→P(Q)。\n非确定性自动机允许使用空输入 ϵ\\epsilonϵ 来进行状态转移。\n\n\n\n\n\n 语言分类——乔姆斯基层次结构\n乔姆斯基层次结构(Chomsky hierarchy)是形式语言理论、计算机科学和语言学领域的一种包含形式文法的层次结构。\n下面表格层次从小到大排序。其中：\n\naaa 表示终结符。\nA,BA, BA,B 表示非终结符。\nα,β,γ\\alpha, \\beta, \\gammaα,β,γ 表示终结符和/或非终结符序列。\nwww 表示终结符序列(字符串)。\nwRw^RwR 表示字符串的反转，即若 w=w1w2...wn−1wnw = w_1 w_2 ... w_{n - 1} w_nw=w1​w2​...wn−1​wn​，那么 wR=wnwn−1...w2w1w^R = w_n w_{n - 1} ... w_2 w_1wR=wn​wn−1​...w2​w1​。\n\n\n\n\n类型\n语言\n自动机\n文法产生式约束\n实例\n\n\n\n\n类型3\n正则语言(Regular)\n有限状态自动机\nA→a,A→aBA\\to a, A \\to aBA→a,A→aB (右正则)  A→a,A→BaA\\to a, A \\to BaA→a,A→Ba (左正则)\nL={an∣n&gt;0}L = \\{a^n | n &gt; 0 \\}L={an∣n&gt;0}\n\n\n类型2.5\n确定性上下文无关(DCFL)\n确定性下推自动机\nA→αA \\to \\alphaA→α\nL={wcwR}L = \\{wcw^R\\}L={wcwR}\n\n\n类型2\n上下文无关(CFL)\n非确定性下推自动机\nA→αA \\to \\alphaA→α\nL={wwR}L = \\{ww^R\\}L={wwR}\n\n\n类型1\n上下文相关(CSL)\n线性有界非确定性图灵机\nαAβ→αγβ\\alpha A \\beta \\to \\alpha \\gamma \\betaαAβ→αγβ\nL={anbncn∣n&gt;0}L = \\{a^nb^nc^n|n &gt; 0\\}L={anbncn∣n&gt;0}\n\n\n类型0\n递归可枚举(REL)\n图灵机\nγ→α\\gamma \\to \\alphaγ→α\nL={w∣终止图灵机}L = \\{w|\\text{终止图灵机}\\}L={w∣终止图灵机}\n\n\n\n\n 二. 正则语言(Regular Language)\n 正则文法 (Regular Grammar)\n正则文法可以使用一个四元组 G=(N,Σ,P,S)G = (N,\\Sigma,P,S)G=(N,Σ,P,S) 来表示。\n\nNNN 表示非终结符的有限集合。\nΣ\\SigmaΣ 表示终结符的有限集合。且 N∩Σ=∅N \\cap \\Sigma = \\emptysetN∩Σ=∅。\nPPP 是产生式的有限集合。\nSSS 是开始的非终结符，S∈NS \\in NS∈N。\n\n正则文法中对产生式 PPP 有以下两种形式(约束)：\n\n左线性文法 (Left-Linear Grammar)：\n\nA→aA \\to aA→a\nA→BaA \\to BaA→Ba\nA→εA \\to \\varepsilonA→ε\n\n\n右线性文法 (Right-Linear Grammar)：\n\nA→aA \\to aA→a\nA→aBA \\to aBA→aB\na→εa \\to \\varepsilona→ε\n\n\n\n 正则表达式 (Regular Expression)\n正则表达式是用来识别正则语言的一种文法。正则表达式有很多种，在形式语言中，只考虑下面标准正则表达式：\n\n\n定义：\n\n∅\\varnothing∅ 是正则表达式，表示空语言。\nε\\varepsilonε 是正则表达式，表示空字符串语言 {ε}\\{\\varepsilon\\}{ε}。\n∀a∈Σ,a\\forall a \\in \\Sigma, a∀a∈Σ,a 是一个正则表达式，表示语言 {a}\\{a\\}{a}。\n如果 r,sr, sr,s 分别是语言 R,SR, SR,S 的正则表达式，那么 r+s,rs,r∗,(r)r + s, rs, r^*, (r)r+s,rs,r∗,(r) 是正则表达式，分别表示语言 R∪S,R⋅S,R∗,RR \\cup S, R \\cdot S, R^*, RR∪S,R⋅S,R∗,R。\n\n优先级，从高到低：\n\n括号： (r)(r)(r)\n闭包： r∗r^*r∗\n串联/乘： rsrsrs\n并联/加： r+sr + sr+s\n\n\n代数定律(可以转化为语言(集合)来验证)：\n\n元相关：\n\nεE=Eε=E\\varepsilon E = E \\varepsilon = EεE=Eε=E (单位元 ε\\varepsilonε)\n∅E=E∅=∅\\varnothing E = E \\varnothing = \\varnothing∅E=E∅=∅ (零元 ∅\\empty∅)\n∅+E=E+∅=E\\varnothing + E = E + \\varnothing = E∅+E=E+∅=E (单位元 ∅\\empty∅)\n\n\n并运算：\n\nE+F=F+EE + F = F + EE+F=F+E (加法交换律)\nE+(E+G)=(E+F)+GE + (E + G) = (E + F) + GE+(E+G)=(E+F)+G (加法结合律)\nE+E=EE + E = EE+E=E (幂等律)\n\n\n连接运算：\n\nEF≠FEEF \\neq FEEF=FE (不满足乘法交换律)\nEE∗=E∗E        (=E+)EE^* = E^*E \\ \\ \\ \\ \\ \\ \\ \\ (=E^+)EE∗=E∗E        (=E+)\nE∗E∗=E∗E^*E^* = E^*E∗E∗=E∗\nE(FG)=(EF)GE(FG) = (EF)GE(FG)=(EF)G (乘法结合律)\nE(F+G)=EF+EGE(F + G) = EF + EGE(F+G)=EF+EG (左乘法分配律)\n(F+G)E=FE+GE(F + G)E = FE + GE(F+G)E=FE+GE (右乘法分配律)\n\n\n闭包运算：\n\n(E∗)∗=E∗(E^*)^* = E^*(E∗)∗=E∗\n∅∗=ε\\varnothing ^* = \\varepsilon∅∗=ε\nε∗=ε\\varepsilon ^ * = \\varepsilonε∗=ε\nε+EE∗=E∗\\varepsilon + EE^* = E^*ε+EE∗=E∗\nE∗(E+ε)=E∗E^*(E + \\varepsilon) = E^*E∗(E+ε)=E∗ (可由上面的证明)\n(E+F)∗=(E∗F∗)∗(E + F)^* = (E^*F^*)^*(E+F)∗=(E∗F∗)∗\n(ε+E)∗=E∗(\\varepsilon + E) ^ * = E^*(ε+E)∗=E∗ (可由上面的证明)\n\n\n推论：\n\n(E+F)∗=F∗+(E+F)∗EF∗(E+F)^* = F^* + (E+F)^*EF^*(E+F)∗=F∗+(E+F)∗EF∗\n\nF∗F^*F∗ 表示不存在 EEE。\n(E+F)∗EF∗(E+F)^*EF^*(E+F)∗EF∗ 表示至少存在一个 EEE。\n\n\n(E+F)∗=(E+F)∗E∗=E∗(E+F)∗(E+F)^* = (E+F)^*E^* = E^*(E+F)^*(E+F)∗=(E+F)∗E∗=E∗(E+F)∗\n\n证明$ (E+F)^* = (E+F)*E*$：\n\n首先后者肯定包含前者 (让后面的 E∗=εE^* = \\varepsilonE∗=ε)\n前者通过下面步骤包含后者：\n\nL((E+F)∗E∗)⊆L((E+F)∗(E+F)∗)L((E+F)^*E^*) \\subseteq L((E+F)^*(E+F)^*)L((E+F)∗E∗)⊆L((E+F)∗(E+F)∗)\nL((E+F)∗(E+F)∗)=L(E+F)∗L((E+F)^*(E+F)^*) = L(E+F)^*L((E+F)∗(E+F)∗)=L(E+F)∗\n因此 L((E+F)∗E∗)⊆L(E+F)∗L((E+F)^*E^*) \\subseteq L(E+F)^*L((E+F)∗E∗)⊆L(E+F)∗\n\n\n\n\n(E+F)∗=E∗(E+F)∗(E+F)^* = E^*(E+F)^*(E+F)∗=E∗(E+F)∗ 同理。\n\n\n(E+F)∗E(E+F)∗=(E+F)∗EF∗=F∗E(E+F)∗(E+F)^*E(E+F)^* = (E + F)^*EF^* = F^*E(E+F)^*(E+F)∗E(E+F)∗=(E+F)∗EF∗=F∗E(E+F)∗\n\n都表示至少存在一个 EEE。\n前者的 EEE 表示任意位置(总是存在第一个和最后一个 EEE)。\n中间的 EEE 表示最后一个 EEE。\n后者的 EEE 表示第一个 EEE。\n\n\n\n\n\n\n\n\n\n\n\n正则表达式与语言(字符串集合)之间的转化：\n\n基础定义：假设 EEE 为正则表达式，那么 L(E)L(E)L(E) 为该正则表达式可识别的语言。\n\nL(∅)=∅L(\\varnothing) = \\varnothingL(∅)=∅\nL(ε)={ε}L(\\varepsilon) = \\{\\varepsilon\\}L(ε)={ε}\nL(x)={x}, where x∈ΣL(x) = \\{x\\}\\text{, where } x \\in \\SigmaL(x)={x}, where x∈Σ\nL(E+F)=L(E)∪L(F)L(E + F) = L(E) \\cup L(F)L(E+F)=L(E)∪L(F)\nL(EF)=L(E)⋅L(F)L(EF) = L(E) \\cdot L(F)L(EF)=L(E)⋅L(F)\nL(E∗)=L(E)∗L(E^*) = L(E)^*L(E∗)=L(E)∗\nL((E))=L(E)L((E)) = L(E)L((E))=L(E)\n\n\n包含关系(正则表达式的放缩)：\n\n\n并运算：\n\nL(E0)⊆L(F)∧L(E1)⊆L(F)  ⟺  L(E0+E1)⊆L(F)  ⟺  (L(E0)+L(E1))⊆L(F)L(E_0) \\subseteq L(F) \\land L(E_1) \\subseteq L(F) \\iff L(E_0 + E_1) \\subseteq L(F) \\iff (L(E_0) + L(E_1)) \\subseteq L(F)L(E0​)⊆L(F)∧L(E1​)⊆L(F)⟺L(E0​+E1​)⊆L(F)⟺(L(E0​)+L(E1​))⊆L(F)\nL(E)⊆L(E+F)L(E) \\subseteq L(E+F)L(E)⊆L(E+F)\n\n\n\n连接运算：\n\nL(E0)⊆L(E1)∧L(F0)⊆L(F1)→L(E0)L(F0)⊆L(E1)L(F1)L(E^0) \\subseteq L(E^1) \\land L(F^0) \\subseteq L(F^1) \\to L(E^0)L(F^0) \\subseteq L(E^1)L(F^1)L(E0)⊆L(E1)∧L(F0)⊆L(F1)→L(E0)L(F0)⊆L(E1)L(F1)\n\n\n\n闭包：\n\nL(ε)⊆L(E∗)L(\\varepsilon) \\subseteq L(E^*)L(ε)⊆L(E∗)\nL(E)⊆L(E∗)L(E) \\subseteq L(E^*)L(E)⊆L(E∗)\nL(EE...EE∗)⊆L(E∗)L(EE...EE^*) \\subseteq L(E^*)L(EE...EE∗)⊆L(E∗)\nL(E∗)⊆L((E+F)∗)L(E^*) \\subseteq L((E+F)^*)L(E∗)⊆L((E+F)∗)\nL(E(E+F)∗)⊆L((E+F)∗)L(E(E+F)^*) \\subseteq L((E+F)^*)L(E(E+F)∗)⊆L((E+F)∗)\n\nL(E(E+F)∗)⊆L((E+F)(E+F)∗)⊆L((E+F)∗)L(E(E+F)^*) \\subseteq L((E+F)(E+F)^*) \\subseteq L((E+F)^*)L(E(E+F)∗)⊆L((E+F)(E+F)∗)⊆L((E+F)∗)\n\n\nL((E+F)∗E)⊆L((E+F)∗)L((E+F)^*E) \\subseteq L((E+F)^*)L((E+F)∗E)⊆L((E+F)∗)\n\n同上\n\n\n\n\n\n\n\n\n\n如何证明两个正则表达式相等：\n\nE=F  ⟺  L(E)=L(F)E = F \\iff L(E) = L(F)E=F⟺L(E)=L(F)。\n正则表达式定理：假设正则表达式 E,FE, FE,F 中分别有变量 L0,L1,...L_0, L_1, ...L0​,L1​,...，如果将这些变量替换为具体的一个字符 a,b,ca, b, ca,b,c 能使得 L(E)=L(F)L(E) = L(F)L(E)=L(F)，那么恒有 L(E)=L(F)L(E) = L(F)L(E)=L(F)。\n\n例如 L(aa∗)=L(a∗a)L(aa^*) = L(a^*a)L(aa∗)=L(a∗a)，那么有 L(L0L0∗)=L(L0∗L0)L(L_0L_0^*) = L(L_0^*L_0)L(L0​L0∗​)=L(L0∗​L0​)。其中 L0L_0L0​ 可以替换为任意其他的正则表达式，例如 L((ab+c)(ab+c)∗)=L((ab+c)∗(ab+c))L((ab + c)(ab + c)^*) = L((ab + c)^*(ab + c))L((ab+c)(ab+c)∗)=L((ab+c)∗(ab+c))。\n该定理不适用于集合。\n\n\n集合相等定理：如果 L(E)⊆L(F)L(E) \\subseteq L(F)L(E)⊆L(F) 并且 L(F)⊆L(E)L(F) \\subseteq L(E)L(F)⊆L(E)，那么有 L(E)=L(F)L(E) = L(F)L(E)=L(F)。\n集合互斥和自动机：如果 EEE 和 FFF 是正则语言，那么 (E∩F‾)∪E‾∩F(E \\cap \\overline{F}) \\cup {\\overline{E} \\cap F}(E∩F)∪E∩F 是正则的，则必然存在 自动机 识别该串。\n\n如果自动机能够识别某个串，当且仅当 E≠FE \\neq FE=F。\n如果 E=FE = FE=F，那么该自动机不能识别任何一个串。\n\n\n\n\n\n\n证明 (E+F)∗E(E+F)∗=(E+F)∗EF∗(E+F)^*E(E+F)^* = (E + F)^*EF^*(E+F)∗E(E+F)∗=(E+F)∗EF∗\n首先证明 L((E+F)∗EF∗)⊆L((E+F)∗E(E+F)∗)L((E + F)^*EF^*) \\subseteq L((E+F)^*E(E+F)^*)L((E+F)∗EF∗)⊆L((E+F)∗E(E+F)∗)，很明显：\n\nL((E+F)∗)⊆L((E+F)∗)L((E+F)^*) \\subseteq L((E+F)^*)L((E+F)∗)⊆L((E+F)∗)\nL(E)⊆L(E)L(E) \\subseteq L(E)L(E)⊆L(E)\nL(F∗)⊆L((E+F)∗)L(F^*) \\subseteq L((E+F)^*)L(F∗)⊆L((E+F)∗)\n因此有 L((E+F)∗EF∗)⊆L((E+F)∗E(E+F)∗)L((E + F)^*EF^*) \\subseteq L((E+F)^*E(E+F)^*)L((E+F)∗EF∗)⊆L((E+F)∗E(E+F)∗)。\n\n其次证明： L((E+F)∗E(E+F)∗)⊆L((E+F)∗EF∗)L((E+F)^*E(E+F)^*) \\subseteq L((E + F)^*EF^*)L((E+F)∗E(E+F)∗)⊆L((E+F)∗EF∗)：\n\nL((E+F)∗EF∗)=L((E+F)∗(E+F)∗EF∗)L((E+F)^*EF^*) = L((E+F)^*(E+F)^*EF^*)L((E+F)∗EF∗)=L((E+F)∗(E+F)∗EF∗)\nL((E+F)∗)⊆L((E+F)∗)L((E+F)^*) \\subseteq L((E+F)^*)L((E+F)∗)⊆L((E+F)∗)\n\n此时只需要证明 L(E(E+F)∗)⊆L((E+F)∗EF∗)L(E(E+F)^*) \\subseteq L((E+F)^*EF^*)L(E(E+F)∗)⊆L((E+F)∗EF∗)\n我们将 L(E(E+F)∗)L(E(E+F)^*)L(E(E+F)∗) 中的 (E+F)∗(E+F)^*(E+F)∗ 进行分类讨论：\n\n如果 (E+F)∗(E+F)^*(E+F)∗ 中没有 EEE，即 (E+F)∗=F∗(E+F)^* = F^*(E+F)∗=F∗。\n如果 (E+F)∗(E+F)^*(E+F)∗ 中至少有一个 EEE，那么必然存在一个 EEE 其右边只有 FFF 或者为 ε\\varepsilonε，即 (E+F)∗=(E+F)∗EF∗(E+F)^* = (E+F)^*EF^*(E+F)∗=(E+F)∗EF∗。\n\n那么可以得到 (E+F)∗=F∗+(E+F)∗EF∗(E+F)^* = F^* + (E+F)^*EF^*(E+F)∗=F∗+(E+F)∗EF∗。\n那么 L(E(E+F)∗)=L(EF∗)+L(E(E+F)∗EF∗)L(E(E+F)^*) = L(EF^*) + L(E(E+F)^*EF^*)L(E(E+F)∗)=L(EF∗)+L(E(E+F)∗EF∗)。\n\nL(EF∗)⊆L((E+F)∗EF∗)L(EF^*) \\subseteq L((E+F)^*EF^*)L(EF∗)⊆L((E+F)∗EF∗)，此时 (E+F)∗=ε(E+F)^* = \\varepsilon(E+F)∗=ε。\nL(E(E+F)∗EF∗)⊆L((E+F)∗EF∗)L(E(E+F)^*EF^*) \\subseteq L((E+F)^*EF^*)L(E(E+F)∗EF∗)⊆L((E+F)∗EF∗)，此时 (E+F)∗=E(E+F)∗(E+F)^* = E(E+F)^*(E+F)∗=E(E+F)∗。\n\n因此有 L((E+F)∗E(E+F)∗)⊆L((E+F)∗EF∗)L((E+F)^*E(E+F)^*) \\subseteq L((E + F)^*EF^*)L((E+F)∗E(E+F)∗)⊆L((E+F)∗EF∗)。\n综上所述，(E+F)∗E(E+F)∗=(E+F)∗EF∗(E+F)^*E(E+F)^* = (E + F)^*EF^*(E+F)∗E(E+F)∗=(E+F)∗EF∗。\n\n\n\n一些正则表达式模板\n为了方便表示，我们使用 [^a] 表示除了 aaa 以外的其他字符。\n\n偶数个 aaa：([^a]*a[^a]*a)*[^a]*\n奇数个 aaa：[^a]*a([^a]*a[^a]*a)*[^a]* 或 [^a]*a([^a]*+a[^a]*a)*\n\n\n\n 有限状态自动机 (FSA)\n有限状态自动机(Finite State Automaton, FSA)用于表示和控制具有有限个状态的系统。有限状态自动机可以用于识别正则语言。\n它分成两种，确定性有限状态自动机(DFA)和非确定性有限状态自动机(NFA)。\n 1. 确定性有限状态自动机 (DFA)\n确定性有限状态自动机(Deterministic Finite Automaton, DFA)是一种识别正则语言的确定性自动机。通常表示为五元组：\nD=(Q,Σ,δ,q0,F)D = (Q, \\Sigma, \\delta, q_0, F)\nD=(Q,Σ,δ,q0​,F)\n\nQQQ：有穷状态集合。\nΣ\\SigmaΣ：可被识别的字母表。\nδ\\deltaδ：状态转移函数， δ:Q×Σ→Q\\delta : Q \\times \\Sigma \\to Qδ:Q×Σ→Q。\nq0∈Qq_0 \\in Qq0​∈Q：初始状态。\nF⊆QF \\subseteq QF⊆Q：最终状态集。\n\n性质：L(D)L(D)L(D) 表示状态机 DDD 所有可接受的语言。如果 ∃D:DFA,L=L(D)\\exist D: DFA, L = L(D)∃D:DFA,L=L(D)，那么称语言 LLL 是正则语言。\n对于状态转移函数 δ\\deltaδ，通常由函数表示法、状态转移图 或 状态转移表来表示：\n &gt; 函数表示法\n直接由 δ(q1,a)=q2\\delta(q_1, a) = q_2δ(q1​,a)=q2​ 来表示。\n\n函数表示法例子：识别具有奇数长度二进制的DFA\nD=({q0,q1},{0,1},δ,q0,{q1})D = (\\{q_0, q_1\\}, \\{0, 1\\}, \\delta, q_0, \\{q_1\\})\nD=({q0​,q1​},{0,1},δ,q0​,{q1​})\n{δ(q0,0)=q1δ(q0,1)=q1δ(q1,0)=q0δ(q1,1)=q0\\left \\{ \\begin{matrix}\n\\delta(q_0, 0) = q_1 \\\\\n\\delta(q_0, 1) = q_1 \\\\\n\\delta(q_1, 0) = q_0 \\\\\n\\delta(q_1, 1) = q_0\n\\end{matrix} \\right.\n⎩⎪⎪⎪⎨⎪⎪⎪⎧​δ(q0​,0)=q1​δ(q0​,1)=q1​δ(q1​,0)=q0​δ(q1​,1)=q0​​\n\n\n &gt; 状态转移图\n绘制标准：\n\n每个状态 qqq 对应一个节点，用圆圈表示。\n状态转移函数 δ(q1,a)=q2\\delta (q_1, a) = q_2δ(q1​,a)=q2​ 用一条从状态节点 q1q_1q1​ 到 q2q_2q2​ 值为 aaa 的有向边表示。\n开始状态的节点被一个箭头指向。\n结束状态的节点用双圈圆表示。\n\n\n状态转移图例子：识别具有奇数长度二进制的DFA\nD=({q0,q1},{0,1},δ,q0,{q1})D = (\\{q_0, q_1\\}, \\{0, 1\\}, \\delta, q_0, \\{q_1\\})D=({q0​,q1​},{0,1},δ,q0​,{q1​})\n\n\n\n &gt; 状态转移表\n绘制标准：\n\n每个状态 qqq 对应一行，每个字母 aaa 对应一列。\n状态转移函数 δ(q1,a)=q2\\delta (q_1, a) = q_2δ(q1​,a)=q2​ 用第 q1q_1q1​ 行 第 aaa 列填入 q2q_2q2​ 表示。\n开始状态前用箭头 →→→ 表示。\n接受状态前用型号 ⋆\\star⋆ 表示。\n\n\n状态转移表例子：识别具有奇数长度二进制的DFA\nD=({q0,q1},{0,1},δ,q0,{q1})D = (\\{q_0, q_1\\}, \\{0, 1\\}, \\delta, q_0, \\{q_1\\})D=({q0​,q1​},{0,1},δ,q0​,{q1​})\n\n\n\nδ\\deltaδ\n000\n111\n\n\n\n\n→q0\\to q_0→q0​\nq1q_1q1​\nq1q_1q1​\n\n\n⋆ q1\\star \\ q_1⋆ q1​\nq0q_0q0​\nq0q_0q0​\n\n\n\n\n\n 扩展状态转移函数\n扩展状态转移函数用来表示一个状态在接收一个字符串后到达的状态。\nDFA扩展状态转移函数递归定义为：\nδ^:Q×Σ∗→Q\\hat{\\delta} : Q \\times \\Sigma^* \\to Q\nδ^:Q×Σ∗→Q\nδ^(q,x)={qx=εδ^(δ(q,a),y)x=ay\\hat{\\delta}(q, x) = \n\\begin{cases}\nq &amp; x = \\varepsilon \\\\\n\\hat{\\delta}(\\delta(q, a), y) &amp; x = ay\n\\end{cases} \nδ^(q,x)={qδ^(δ(q,a),y)​x=εx=ay​\n那么可以定义DFA所接受的全部语言 L(D)L(D)L(D)：\nL(D)={w∣w∈Σ∗∧δ^(q0,w)∈F}L(D) = \\{w | w \\in \\Sigma ^* \\wedge \\hat{\\delta}(q_0, w) \\in F\\}\nL(D)={w∣w∈Σ∗∧δ^(q0​,w)∈F}\n 最小化 DFA\n对于同一个语言，可以有多种DFA识别。例如识别具有奇数长度二进制的DFA可以有下面两种形式。\n\n直接讨论总长度的奇偶，D1D_1D1​：\n\n\n\n\n\n分别讨论 000 和 111 的奇偶，D2D_2D2​：\n\n\n  \n\n这两个DFA是等价的，即 L(D1)=L(D2)L(D_1) = L(D_2)L(D1​)=L(D2​)。但是很明显 D1D_1D1​ 比 D2D_2D2​ 更加简洁。我们可以使用 填表法 将 D2D_2D2​ 化简为 D1D_1D1​。\n\n填表法步骤：假设一共有 (n+1)(n + 1)(n+1) 个状态，其状态的编号为 [0,n][0,n][0,n]。\n\n画出 n×nn \\times nn×n 的表格，横向的排序为 [0,n−1][0, n - 1][0,n−1] 从低到高，纵向排序为 [n,1][n, 1][n,1] 从高到低。每个坐标下的两个状态视为一个状态组。\n\n一共有 n2n^2n2 个状态组。\n可以将重复的状态组填入 “−-−”，例如在状态组 (x,y)(x, y)(x,y) 中，可以将所有 x≥yx \\geq yx≥y 的状态组填入 “−-−”。\n\n\n将表格中所有 接受状态 与 非接受状态 坐标的空格中填入叉 ×\\times×，并视为&quot;可区分的(Distinguishable)状态组&quot;。\n将其他空白的状态组一一列出。\n将这些状态组分别与所有终结符(字符)带入到状态转移函数 δ\\deltaδ，获得新的状态组。将该状态组与新的状态组归类为同一类状态组。\n只要存在一个状态组是可区分的状态组，那么该类状态组就都是可区分的状态组，填入叉 ×\\times×。\n将所有的空白状态组列出检查并分类后，所有没有被确定为 “可区分的状态组” (没有被填入叉 ×\\times× 的状态组) 都视为 “不可区分的(Indistinguishable)状态组”，即这个状态组中两个状态是等价的，可以相互转化。\n将所有不可区分的状态组两个或多个状态化为一个状态。\n\n注意是一个状态组中两个状态化为一个状态，不是同类状态组之间。同类状态组只是为了方便划分状态组是不是可区分状态组\n例如 如果状态组 (q0,q1)(q_0, q_1)(q0​,q1​) 是不可区分的状态组，那么可以将 q0q_0q0​ 和 q1q_1q1​ 化为同一个状态。此外，如果还有 (q1,q2)(q_1, q_2)(q1​,q2​) 是不可区分的 (此时一定也有 (q0,q2)(q_0, q_2)(q0​,q2​) 是不可区分的状态组)，那么就可以将 q0,q1,q2q_0, q_1, q_2q0​,q1​,q2​ 化为同一个状态，即 q0≡q1≡q2q_0 \\equiv q_1 \\equiv q_2q0​≡q1​≡q2​。\n如果状态组 (q0,q1)(q_0, q_1)(q0​,q1​) 和 (q2,q3)(q_2, q_3)(q2​,q3​) 是同类不可区分的状态组，并不能将这四个状态视为同一个状态，而是分别将 q0,q1q_0, q_1q0​,q1​ 和 q2,q3q_2, q_3q2​,q3​ 视为同一个状态，即 q0≡q1q_0 \\equiv q_1q0​≡q1​ 且 q2≡q3q_2 \\equiv q_3q2​≡q3​。\n\n\n\n\n\n\n填表法化简DFA例子：化简 D2D_2D2​ 为 D1D_1D1​\nD2D_2D2​ 中，我们知道 q1q_1q1​ 和 q2q_2q2​ 是接受状态，q0q_0q0​ 和 q3q_3q3​ 是不可接受状态，那么我们根据填表法步骤 1,21, 21,2 可以画出下面的图：\n\n\n\n\n000\n111\n222\n\n\n\n\n333\n\n×××\n×××\n\n\n222\n×××\n\n−-−\n\n\n111\n×××\n−-−\n−-−\n\n\n\n此时只剩下状态组 (q0,q3)(q_0, q_3)(q0​,q3​) 和 (q1,q2)(q_1, q_2)(q1​,q2​) 是未知的。\n我们先转化 (q0,q3)(q_0, q_3)(q0​,q3​)：\n(q0,q3):{(δ(q0,0),δ(q3,0))=(q1,q2)未知是否可区分(δ(q0,1),δ(q3,1))=(q2,q1)未知是否可区分(q_0, q_3):\n\\begin{cases}\n(\\delta(q_0, 0), \\delta(q_3,0)) = (q_1, q_2) &amp; \\text{未知是否可区分} \\\\\n(\\delta(q_0, 1), \\delta(q_3,1)) = (q_2, q_1) &amp; \\text{未知是否可区分}\n\\end{cases}\n(q0​,q3​):{(δ(q0​,0),δ(q3​,0))=(q1​,q2​)(δ(q0​,1),δ(q3​,1))=(q2​,q1​)​未知是否可区分未知是否可区分​\n那么此时我们将 (q0,q3)(q_0, q_3)(q0​,q3​) 和 (q1,q2)(q_1, q_2)(q1​,q2​) 视为同一类状态组，即：\n\n如果 (q1,q2)(q_1, q_2)(q1​,q2​) 是可区分的，那么 (q0,q3)(q_0, q_3)(q0​,q3​) 也是可区分的。\n如果到最后都不能确定 (q1,q2)(q_1, q_2)(q1​,q2​) 是可区分的，那么 (q1,q2)(q_1, q_2)(q1​,q2​) 和 (q0,q3)(q_0, q_3)(q0​,q3​) 都是不可区分的。\n\n我们转化 (q1,q2)(q_1, q_2)(q1​,q2​)：\n(q1,q2):{(δ(q1,0),δ(q2,0))=(q0,q3)未知是否可区分(δ(q1,1),δ(q2,1))=(q3,q0)未知是否可区分(q_1, q_2):\n\\begin{cases}\n(\\delta(q_1, 0), \\delta(q_2,0)) = (q_0, q_3) &amp; \\text{未知是否可区分} \\\\\n(\\delta(q_1, 1), \\delta(q_2,1)) = (q_3, q_0) &amp; \\text{未知是否可区分}\n\\end{cases}\n(q1​,q2​):{(δ(q1​,0),δ(q2​,0))=(q0​,q3​)(δ(q1​,1),δ(q2​,1))=(q3​,q0​)​未知是否可区分未知是否可区分​\n此时所有的状态组都检查完毕，那么剩下没有确定为可区分的状态组 (q0,q3)(q_0, q_3)(q0​,q3​) 和 (q1,q2)(q_1, q_2)(q1​,q2​) 都被视为不可区分的状态组。也就是说 q0q_0q0​ 和 q3q_3q3​ 是等价的，q1q_1q1​ 和 q2q_2q2​ 是等价的，即 q0≡q3,q1≡q2q_0 \\equiv q_3, q_1 \\equiv q_2q0​≡q3​,q1​≡q2​。\n此时将 q0q_0q0​ 和 q3q_3q3​ 合并为 q0q_0q0​，q1q_1q1​ 和 q2q_2q2​ 合并为 q1q_1q1​，可以画出最简DFA D1D_1D1​：\n\n\n\n DFA转化正则表达式1：递归式法\n若语言 L=L(D)L = L(D)L=L(D) 是某 DFA 可识别的语言，那么存在正则表达式 RRR 满足 L=L(R)L = L(R)L=L(R)。\n\n递归式法的基本思想：\n\n假设 RijR_{ij}Rij​ 是对于任意两个状态 qi,qjq_i, q_jqi​,qj​ 之间转化的正则表达式。\n如果 qiq_iqi​ 和 qjq_jqj​ 不是直接相连的，那么会存在中间状态 qkq_kqk​ 有：\nRij经过k=Rij不经过k+Rik不经过k(Rkk不经过k)∗Rkj不经过kR_{ij}^{\\text{经过k}} = R_{ij}^{\\text{不经过k}} + R_{ik}^{\\text{不经过k}}(R_{kk}^{\\text{不经过k}})^*R_{kj}^{\\text{不经过k}}\nRij经过k​=Rij不经过k​+Rik不经过k​(Rkk不经过k​)∗Rkj不经过k​\n同时对于 RikR_{ik}Rik​ 和中间状态 qk−1q_{k-1}qk−1​ 也同意符合上述公式，直到递归至不存在中间状态，即两个状态之间直接相连接为止，便能求出整个过程的正则表达式 RijR_{ij}Rij​。\n\n递归式法：\n\n假设 Rij(k)R_{ij}^{(k)}Rij(k)​ 表示从状态 qiq_iqi​ 到状态 qjq_jqj​ 但中间状态下角标都不超过 kkk 的全部路径的正则表达式(也就是说只用 [1,k][1,k][1,k] 区间的点作为中间节点)：\n\nRij(k)={x∣δ^(i,x)=j,x经过的状态除两端外都不超过k}R_{ij}^{(k)} = \\{x|\\hat{\\delta}(i, x) = j, x \\text{经过的状态除两端外都不超过}k \\}Rij(k)​={x∣δ^(i,x)=j,x经过的状态除两端外都不超过k}。\nRi,j(0)R_{i,j}^{(0)}Ri,j(0)​ 表示不经过任何中间状态直接由 qiq_iqi​ 到 qjq_jqj​ 的正则表达式。\n\n那么对于DFA：D=({q1,q2,...,qn},Σ,δ,q1,F)D = (\\{q_1, q_2, ..., q_n\\}, \\Sigma, \\delta, q_1, F)D=({q1​,q2​,...,qn​},Σ,δ,q1​,F) 来说，其正则表达式递归公式为：\n⋃j∈FR1j(n)\\bigcup_{j \\in F}R^{(n)}_{1j}\nj∈F⋃​R1j(n)​\nRj(k)=Rij(k−1)+Rik(k−1)(Rkk(k−1))∗Rkj(k−1)R_{j}^{(k)} = R_{ij}^{(k - 1)} + R_{ik}^{(k - 1)} (R_{kk}^{(k - 1)}) ^ * R_{kj}^{(k-1)}\nRj(k)​=Rij(k−1)​+Rik(k−1)​(Rkk(k−1)​)∗Rkj(k−1)​\nRij(0)={{a∣δ(qi,a)=qj}i≠j{a∣δ(qi,a)=qi}∪{ε}i=jR_{ij}^{(0)} = \n\\begin{cases}\n\\{a | \\delta(q_i, a) = q_j\\} &amp; i \\neq j \\\\\n\\{a | \\delta(q_i, a) = q_i\\} \\cup \\{\\varepsilon\\} &amp;  i = j\n\\end{cases}\nRij(0)​={{a∣δ(qi​,a)=qj​}{a∣δ(qi​,a)=qi​}∪{ε}​i=ji=j​\n注意：\n\n当 i=ji = ji=j 的时候，表示起点终点为 iii 所有的环(Cycle)的路径，也就是说在 Rkk(k−1)R_{kk}^{(k - 1)}Rkk(k−1)​ 中本身就包含了 Rkp(k−1)Rpk(k−1)R_{kp}^{(k - 1)}R_{pk}^{(k - 1)}Rkp(k−1)​Rpk(k−1)​ 的环形。\n(∅)∗=ε(\\varnothing)^* = \\varepsilon(∅)∗=ε。 (注意 ε\\varepsilonε 是正则表达式，也就是说L(ε)={ε}L(\\varepsilon) = \\{\\varepsilon\\}L(ε)={ε})\n\n这个递归求解的过程类似于动态规划Floyd算法，即填点法。如果很难理解可以先去看一下 Floyd 算法，这俩过程是非常类似的。\n\n递归式法例子：求识别具有奇数长度二进制的DFA的正则表达式 (D1D_1D1​)\n考虑下面的DFA：\n五元组：D1=({q0,q1},{0,1},δ,q0,{q1})D_1 = (\\{q_0, q_1\\}, \\{0, 1\\}, \\delta, q_0, \\{q_1\\})D1​=({q0​,q1​},{0,1},δ,q0​,{q1​})\n状态转移表：\n\n\n\nδ\\deltaδ\n000\n111\n\n\n\n\n→q0\\to q_0→q0​\nq1q_1q1​\nq1q_1q1​\n\n\n⋆ q1\\star \\ q_1⋆ q1​\nq0q_0q0​\nq0q_0q0​\n\n\n\n状态转移图：\n\n与给出递归式的定义从 111 下标开始不同，这里是从 000 开始的。那么我们修改上述 Rij(−1)R_{ij}^{(-1)}Rij(−1)​ 为不经过任何中间状态从 qiq_iqi​ 转化到 qjq_jqj​ 的正则表达式。那么最终我们要求出 R01(1)R_{01} ^ {(1)}R01(1)​。\n\nk=−1k = -1k=−1，即不经过任何中间状态：\n\n\n\n\nRij(k)R_{ij}^{(k)}Rij(k)​\nk=−1k = -1k=−1\n\n\n\n\nR00(−1)R^{(-1)}_{00}R00(−1)​\nε+∅=ε\\varepsilon + \\emptyset = \\varepsilonε+∅=ε\n\n\nR01(−1)R^{(-1)}_{01}R01(−1)​\n0+10 + 10+1\n\n\nR10(−1)R^{(-1)}_{10}R10(−1)​\n0+10 + 10+1\n\n\nR11(−1)R^{(-1)}_{11}R11(−1)​\nε+∅=ε\\varepsilon + \\emptyset = \\varepsilonε+∅=ε\n\n\n\n为了方便观看，下面全部假设 (0+1)(0 + 1)(0+1) 为 aaa。\n\nk=0k = 0k=0，即经历中间状态 q0q_0q0​：\n\n\n\n\nRij(k)R_{ij}^{(k)}Rij(k)​\nk=0k = 0k=0\n\n\n\n\nR00(0)R^{(0)}_{00}R00(0)​\nR00(−1)+R00(−1)(R00(−1))∗R00(−1)=ε+ε⋅ε∗⋅ε=εR^{(-1)}_{00} + R_{00}^{(-1)} (R_{00}^{(-1)}) ^ * R_{00}^{(-1)} = \\varepsilon + \\varepsilon \\cdot \\varepsilon^* \\cdot \\varepsilon = \\varepsilonR00(−1)​+R00(−1)​(R00(−1)​)∗R00(−1)​=ε+ε⋅ε∗⋅ε=ε\n\n\nR01(0)R^{(0)}_{01}R01(0)​\nR01(−1)+R00(−1)(R00(−1))∗R01(−1)=a+ε⋅ε∗⋅a=a+a=aR^{(-1)}_{01} + R_{00}^{(-1)} (R_{00}^{(-1)}) ^ * R_{01}^{(-1)} = a + \\varepsilon \\cdot \\varepsilon^* \\cdot a = a + a = aR01(−1)​+R00(−1)​(R00(−1)​)∗R01(−1)​=a+ε⋅ε∗⋅a=a+a=a\n\n\nR10(0)R^{(0)}_{10}R10(0)​\nR10(−1)+R10(−1)(R00(−1))∗R00(−1)=a+a⋅ε∗⋅ε=a+a=aR^{(-1)}_{10} + R_{10}^{(-1)} (R_{00}^{(-1)}) ^ * R_{00}^{(-1)} = a + a \\cdot \\varepsilon^* \\cdot \\varepsilon = a + a = aR10(−1)​+R10(−1)​(R00(−1)​)∗R00(−1)​=a+a⋅ε∗⋅ε=a+a=a\n\n\nR11(0)R^{(0)}_{11}R11(0)​\nR11(−1)+R10(−1)(R00(−1))∗R01(−1)=ε+a⋅ε∗⋅a=ε+aaR^{(-1)}_{11} + R_{10}^{(-1)} (R_{00}^{(-1)}) ^ * R_{01}^{(-1)} = \\varepsilon + a \\cdot \\varepsilon^* \\cdot a = \\varepsilon + aaR11(−1)​+R10(−1)​(R00(−1)​)∗R01(−1)​=ε+a⋅ε∗⋅a=ε+aa\n\n\n\n\nk=1k = 1k=1，即经历中间状态 q0,q1q_0, q_1q0​,q1​：\n\n\n\n\nRij(k)R_{ij}^{(k)}Rij(k)​\nk=1k = 1k=1\n\n\n\n\nR00(1)R^{(1)}_{00}R00(1)​\nR00(0)+R01(0)(R11(0))∗R10(0)=ε+a⋅(ε+aa)∗⋅a=ε+aa(aa)∗=(aa)∗R^{(0)}_{00} + R_{01}^{(0)} (R_{11}^{(0)}) ^ * R_{10}^{(0)} = \\varepsilon + a \\cdot (\\varepsilon + aa)^* \\cdot a = \\varepsilon + aa(aa)^* = (aa)^*R00(0)​+R01(0)​(R11(0)​)∗R10(0)​=ε+a⋅(ε+aa)∗⋅a=ε+aa(aa)∗=(aa)∗ —— 因为 ε+EE∗=E∗\\varepsilon + EE^* = E^*ε+EE∗=E∗\n\n\nR01(1)R^{(1)}_{01}R01(1)​\nR01(0)+R01(0)(R11(0))∗R11(0)=a+a⋅(ε+aa)∗⋅(ε+aa)=a+a(aa)∗+aaa(aa)∗=a(ε+aa(aa)∗)+a(aa)∗=a(aa)∗+a(aa)∗=a(aa)∗R^{(0)}_{01} + R_{01}^{(0)} (R_{11}^{(0)}) ^ * R_{11}^{(0)} = a + a \\cdot (\\varepsilon + aa)^* \\cdot (\\varepsilon + aa) = a + a(aa)^* + aaa(aa)^* = a (\\varepsilon + aa(aa)^*) + a(aa)^* = a(aa)^* + a(aa)^* = a(aa)^*R01(0)​+R01(0)​(R11(0)​)∗R11(0)​=a+a⋅(ε+aa)∗⋅(ε+aa)=a+a(aa)∗+aaa(aa)∗=a(ε+aa(aa)∗)+a(aa)∗=a(aa)∗+a(aa)∗=a(aa)∗\n\n\nR10(1)R^{(1)}_{10}R10(1)​\nR10(0)+R11(0)(R11(0))∗R10(0)=a+(ε+aa)⋅(ε+aa)∗⋅a=a+(aa)∗a+aa(aa)∗a=(ε+aa(aa)∗)a+(aa)∗a=(aa)∗a+(aa)∗a=(aa)∗aR^{(0)}_{10} + R_{11}^{(0)} (R_{11}^{(0)}) ^ * R_{10}^{(0)} = a + (\\varepsilon + aa) \\cdot (\\varepsilon + aa)^* \\cdot a = a + (aa)^*a + aa(aa)^*a = (\\varepsilon + aa(aa)^*)a + (aa)^*a = (aa)^*a + (aa)^*a = (aa)^*aR10(0)​+R11(0)​(R11(0)​)∗R10(0)​=a+(ε+aa)⋅(ε+aa)∗⋅a=a+(aa)∗a+aa(aa)∗a=(ε+aa(aa)∗)a+(aa)∗a=(aa)∗a+(aa)∗a=(aa)∗a\n\n\nR11(1)R^{(1)}_{11}R11(1)​\nR11(0)+R11(0)(R11(0))∗R11(0)=(ε+aa)+(ε+aa)⋅(ε+aa)∗⋅(ε+aa)=ε+aa+(aa)∗+(aa)∗aa+aa(aa)∗+aa(aa)∗aa=(ε+aa(aa)∗)+(ε+aa(aa)∗)aa+(aa)∗=(aa)∗+(aa)∗aa+(aa)∗=(aa)∗(ε+aa)=(aa)∗R^{(0)}_{11} + R_{11}^{(0)} (R_{11}^{(0)}) ^ * R_{11}^{(0)} = (\\varepsilon + aa) + (\\varepsilon + aa) \\cdot (\\varepsilon + aa)^* \\cdot (\\varepsilon + aa) = \\varepsilon + aa + (aa)^* + (aa)^*aa + aa(aa)^* + aa(aa)^*aa = (\\varepsilon + aa(aa)^*) + (\\varepsilon + aa(aa)^*) aa + (aa)^* = (aa)^* + (aa)^*aa + (aa)^* = (aa)^*(\\varepsilon + aa) = (aa)^*R11(0)​+R11(0)​(R11(0)​)∗R11(0)​=(ε+aa)+(ε+aa)⋅(ε+aa)∗⋅(ε+aa)=ε+aa+(aa)∗+(aa)∗aa+aa(aa)∗+aa(aa)∗aa=(ε+aa(aa)∗)+(ε+aa(aa)∗)aa+(aa)∗=(aa)∗+(aa)∗aa+(aa)∗=(aa)∗(ε+aa)=(aa)∗\n\n\n\n因此我们可以得出该DFA的正则表达式为 R01(1)=a(aa)∗R_{01} ^ {(1)} = a(aa)^*R01(1)​=a(aa)∗。\n此外，我们还可以得出偶数长度二进制的正则表达式为 R00(1)=(aa)∗R_{00} ^ {(1)} = (aa)^*R00(1)​=(aa)∗。\n实际上我们并不需要将所有的正则表达式求出，而是根据 R01(1)R_{01}^ {(1)}R01(1)​ 的公式递归求解。\n\n\n递归法的优点：\n\n在状态和状态转移函数不变的情况下，可以直接得出所有不同的 初始状态 和 终止状态 的正则表达式。\n是一套完整的算法，适合使用计算机来实现。\n可以一步一步进行化简。\n\n递归法的缺点：\n\n求解过程复杂，假设 nnn 为状态个数，那么需要求解 n3n ^  3n3次，时间复杂度是 O(n3)O(n ^ 3)O(n3)。\n\n DFA转化正则表达式2：状态消除法\n消除法主要的思路是用标记了正则表达式的新路径替换被删掉的路径。\n步骤如下：\n\n增加两个新节点表示新的初始状态和新的最终状态，使用 ε\\varepsilonε 各自连接到初始状态或最终状态。\n\n该步骤将DFA转化成 ε\\varepsilonε-NFA，具体在NFA中解释。\n这一步的目的是为了方便消除所有的状态。\n将原来的初始状态和最终状态修改为普通状态。\n\n\n使用并运算减少两个状态之间的单向边为一条。\n\n这两条边用并运算表示。\n\n\n使用连接和闭包运算逐步删除除了步骤一添加的点以外其他所有点，根据入和出的路径来添加新的边。\n\n添加边的个数为 入的个数 乘以 出的个数。\n对于指向自己的边，使用闭包。\n互相指向的两个状态最终转变成一个状态自己指向自己。\n\n\n\n\n递归式法例子：求识别具有奇数长度 000 的二进制的DFA的正则表达式\n下图是识别具有奇数长度 000 的二进制的DFA。\n\n根据步骤 111，添加两个新节点作为新的初始状态和结束状态：\n\n根据步骤 222，但此时并没有两个状态之间的单向边是多条的情况。\n根据步骤 333，此时删除状态 q0q_0q0​：可知有两个入状态 q0q_0q0​ 的边和一个出状态 q0q_0q0​ 的边。\n第一条入边是 q2−(ε)→q0q_2 -(\\varepsilon)\\to q_0q2​−(ε)→q0​。\n第二条入边是 q1−(0)→q0q_1 -(0)\\to q_0q1​−(0)→q0​。\n唯一条出边是 q0−(0)→q1q_0 -(0)\\to q_1q0​−(0)→q1​。\n此外还有 q0q_0q0​ 指向自己的边 q0−(1)→q0q_0 -(1)\\to q_0q0​−(1)→q0​，这条边被视为 1∗1^*1∗。\n将第一条入边和出边结合，得到 q2−(1∗0)→q1q_2 - (1^*0) \\to q_1q2​−(1∗0)→q1​。\n将第二条入边和出边结合，得到 q1−(01∗0)→q1q_1 - (01^*0) \\to q_1q1​−(01∗0)→q1​。\n根据步骤 222，此时 q1q_1q1​ 指向 q1q_1q1​ 的边有两条，分别是 111 和 (01∗0)(01^*0)(01∗0)，因此将这两条边用并操作结合为 1+(01∗0)1 + (01^*0)1+(01∗0)，得到图为：\n\n根据步骤 333，此时删除状态 q1q_1q1​：可知有一个入状态 q1q_1q1​ 和一个出状态 q1q_1q1​ 的边。\n入状态边是 q2−(1∗0)→q1q_2 - (1^*0) \\to q_1q2​−(1∗0)→q1​。\n出状态边是 q1−ε→q3q_1 - \\varepsilon \\to q_3q1​−ε→q3​。\n此外还有指向自己的边 q3−(1+(01∗0))→q3q_3 - (1 + (01^*0)) \\to q_3q3​−(1+(01∗0))→q3​，被视为 (1+(01∗0))∗(1 + (01^*0))^*(1+(01∗0))∗\n将入状态边和出状态边结合得到 q2−1∗0(1+01∗0)∗→q3q_2 - 1^*0(1 + 01^*0)^* \\to q_3q2​−1∗0(1+01∗0)∗→q3​。\n\n所有点都删除完毕，因此可以知道识别具有奇数长度 000 的二进制的正则表达式为 1∗0(1+01∗0)∗1^*0(1 + 01^*0)^*1∗0(1+01∗0)∗。\n\n\n递归法的优点：\n\n计算比较简单、快速。\n\n递归法的缺点：\n\n适合在纸上来进行演算，不适合计算机去实现。\n得到的不一定是最简式，需要手动化简，化简过程可能会非常复杂。\n\n 2. 非确定有穷自动机 NFA\n非确定的有限状态自动机(Nondeterministic Finite Automata, NFA)是一种识别正则语言的非确定性自动机。通常表示为五元组：\nN=(Q,Σ,δ,P0,F)N = (Q, \\Sigma, \\delta, P_0, F)\nN=(Q,Σ,δ,P0​,F)\n\nQQQ：有穷状态集合。\nΣ\\SigmaΣ：可被识别的字母表。\nδ\\deltaδ：状态转移函数， δ:Q×Σ→P(Q)\\delta : Q \\times \\Sigma \\to \\mathbb{P}(Q)δ:Q×Σ→P(Q) (状态的集合)。\nP0⊆QP_0 \\subseteq QP0​⊆Q：初始状态集合。\nF⊆QF \\subseteq QF⊆Q：最终状态集。\n\n对于状态转移函数 δ\\deltaδ，同DFA一样由函数表示法、状态转移图 或 状态转移表来表示。\n\n函数表示法：与DFA不同，δ\\deltaδ 等于的结果是一个状态的集合，例如 δ(q0,0)={q1,q2}\\delta(q_0, 0) = \\{q_1, q_2\\}δ(q0​,0)={q1​,q2​}。\n状态转移图：与DFA一致，用有向边表示 δ\\deltaδ。\n状态转移表：与DFA不同，填入表格的是一个状态的集合而不是固定的状态。\n\n性质：\n\n关于状态及其转化：\n\n初始状态：与DFA不同，NFA可以有多个初始状态。\n状态转化：同一个输入下，每个状态可以转化为多个状态。也就是对于同一个输入字符串来说，可以有多个路径最终转化成多个状态。\n状态转化：每个状态可以在某一个输入下转化的状态为空集 ∅\\varnothing∅。此时称之为状态机卡住(stuck)，认为该语言无法被NFA识别。\n最终状态：只要存在一个路径转化的最终状态qf∈Fq_f \\in Fqf​∈F，就称这个输入的字符串是被该NFA可接受的。\n\n\nNFA可以接受空输入 ε\\varepsilonε 来进行空转化，即不消耗输入字符下直接转化成另一个状态。接受空转化的NFA称之为 ε−\\varepsilon -ε−NFA。\n\nε−\\varepsilon -ε−NFA 存在的目的是为了简化NFA，例如可以将多个初始/接受状态使用空转移的方式来合并成同一个初始/接受状态。\n\n\nNFA没有增加DFA识别语言的能力，也就是说NFA识别的语言仍然是正则语言：\n\nDFA转化NFA：DFA 本身就可以被视为一种 NFA。\nNFA转化DFA：总是存在 DFA，使得 L(D)=L(N)L(D) = L(N)L(D)=L(N)。具体步骤在下面内容中。\nNFA存在的目的是为了简化DFA.\n\n\n\n 扩展状态转移函数\n扩展状态转移函数用来表示一个状态在接收一个字符串后到达的状态。\nNFA的扩展状态转移函数递归定义为：\nδ^:Q×Σ∗→P(Q)\\hat{\\delta} : Q \\times \\Sigma^* \\to \\mathbb{P}(Q)\nδ^:Q×Σ∗→P(Q)\nδ^(P,x)={Px=εδ^(⋃{δ(q,a)∣q∈P},y)x=ay\\hat{\\delta}(P, x) = \n\\begin{cases}\nP &amp; x = \\varepsilon \\\\\n\\hat{\\delta}(\\bigcup\\{\\delta(q,a)|q\\in P\\}, y) &amp; x = ay\n\\end{cases} \nδ^(P,x)={Pδ^(⋃{δ(q,a)∣q∈P},y)​x=εx=ay​\n那么可以定义NFA所接受的全部语言 L(D)L(D)L(D)：\nL(D)={w∣w∈Σ∗∧δ^(P0,w)∩F≠∅}L(D) = \\{w | w \\in \\Sigma ^* \\wedge \\hat{\\delta}(P_0, w) \\cap F \\neq \\emptyset \\}\nL(D)={w∣w∈Σ∗∧δ^(P0​,w)∩F=∅}\n NFA 转化为 DFA：子集构造法\n对于NFA：N=(QN,Σ,δN,P0,FN)N = (Q_N, \\Sigma, \\delta_N, P_0, F_N)N=(QN​,Σ,δN​,P0​,FN​)，可以构造出DFA：D=(QD,Σ,δD,P0,FD)D = (Q_D, \\Sigma, \\delta_D, P_0, F_D)D=(QD​,Σ,δD​,P0​,FD​)\n\nQD=P(QN)Q_D = \\mathbb{P}(Q_N)QD​=P(QN​)，即DFA的一个状态是NFA状态的集合(包括空集)。\n\nQDQ_DQD​ 是状态集合的集合。\n\n\nFD={Q∣Q⊆QN,Q∩F≠∅}F_D = \\{ Q|Q \\subseteq Q_N, Q \\cap F \\neq \\emptyset \\}FD​={Q∣Q⊆QN​,Q∩F=∅}，即DFA的一个最终状态是包含NFA至少一个最终状态的集合。\n\nQ⊆QNQ \\subseteq Q_NQ⊆QN​ 等价于 Q∈QDQ \\in Q_DQ∈QD​，因此 QQQ 是一个集合，FDF_DFD​ 是一个状态集合的集合。\n\n\n∀P∈QD,δD(P,a)=⋃{δN(q,x)∣q∈P}\\forall P \\in Q_D, \\delta_D(P, a) = \\bigcup \\{ \\delta_N(q, x) | q \\in P \\}∀P∈QD​,δD​(P,a)=⋃{δN​(q,x)∣q∈P}，即将该集合中的所有状态可以被输入 aaa 转化后的状态的集合并集。\n\n一般步骤如下：\n\n画出DFA表格，横向标题(第 111 行)写出各个终结符，纵向可以无限扩展。\n在第 222 行的状态栏处填入 NFA 的初始状态集合 P0P_0P0​，并标入开始符号 →\\to→。\n将集合中所有初始状态分别带入当前列的终结符对应的状态转移方程中，取并集获得状态集合并填入到表格中。\n将未填入过的状态集合填入到新行的状态栏处。\n重复步骤 3,43, 43,4 直到没有出现新的状态集合。\n将所有与 NFA 最终状态 FFF 取交集不为空集的状态集标为最终状态 ⋆\\star⋆。\n\n\n子集构造法例子: 接受全部以01结尾串的NFA转化DFA\n下图是一个接受全部以01结尾串的NFA，其五元组为：\nN=({q0,q1,q2},{0,1},δN,{q0},{q2})N = (\\{q_0, q_1, q_2\\},\\{0, 1\\}, \\delta_N, \\{q_0\\}, \\{q_2\\})\nN=({q0​,q1​,q2​},{0,1},δN​,{q0​},{q2​})\n\n\n\n其状态转移表为：\n\n\n\nδN\\delta_NδN​\n000\n111\n\n\n\n\n→q0\\to q_0→q0​\n{q0,q1}\\{q_0, q_1\\}{q0​,q1​}\n{q0}\\{q_0\\}{q0​}\n\n\nq1q_1q1​\n∅\\varnothing∅\n{q2}\\{q_2\\}{q2​}\n\n\n⋆ q2\\star\\ q_2⋆ q2​\n∅\\varnothing∅\n∅\\varnothing∅\n\n\n\n此时我们构造出其对应的DFA为：\nD=(QD,{0,1},δD,{q0},FD)D = (Q_D, \\{0, 1\\}, \\delta_D,\\{q_0\\}, F_D)\nD=(QD​,{0,1},δD​,{q0​},FD​)\n我们通过步骤 1,21, 21,2 绘制出其状态转移表：\n\n\n\nδD\\delta_DδD​\n000\n111\n\n\n\n\n→{q0}=qA\\to \\{q_0\\} = q_A→{q0​}=qA​\n\n\n\n\n\n根据步骤 333 计算出其转移到的状态集合：\n\n\n\nδD\\delta_DδD​\n000\n111\n\n\n\n\n→{q0}=qA\\to \\{q_0\\} = q_A→{q0​}=qA​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0}=qA\\{q_0\\} = q_A{q0​}=qA​\n\n\n\n此时多出来一个新状态 {q0,q1}\\{q_0, q_1\\}{q0​,q1​}，我们根据步骤 444 将其填入到新行的状态栏处，并根据步骤 333 计算出其转移到的专题集合：\n\n\n\nδD\\delta_DδD​\n000\n111\n\n\n\n\n→{q0}=qA\\to \\{q_0\\} = q_A→{q0​}=qA​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0}=qA\\{q_0\\} = q_A{q0​}=qA​\n\n\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0,q2}=qC\\{q_0, q_2\\} = q_C{q0​,q2​}=qC​\n\n\n\n以此类推，根据步骤 555 最终可以得到：\n\n\n\nδD\\delta_DδD​\n000\n111\n\n\n\n\n→{q0}=qA\\to \\{q_0\\} = q_A→{q0​}=qA​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0}=qA\\{q_0\\} = q_A{q0​}=qA​\n\n\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0,q2}=qC\\{q_0, q_2\\} = q_C{q0​,q2​}=qC​\n\n\n{q0,q2}=qC\\{q_0, q_2\\} = q_C{q0​,q2​}=qC​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0}=qA\\{q_0\\} = q_A{q0​}=qA​\n\n\n\n根据步骤 666，将与 FFF 取交集不为空集的状态集标记为 DFA 的最终状态，只有 {q0,q2}\\{q_0, q_2\\}{q0​,q2​} 符合：\n\n\n\nδD\\delta_DδD​\n000\n111\n\n\n\n\n→{q0}=qA\\to \\{q_0\\} = q_A→{q0​}=qA​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0}=qA\\{q_0\\} = q_A{q0​}=qA​\n\n\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0,q2}=qC\\{q_0, q_2\\} = q_C{q0​,q2​}=qC​\n\n\n⋆ {q0,q2}=qC\\star \\ \\{q_0, q_2\\} = q_C⋆ {q0​,q2​}=qC​\n{q0,q1}=qB\\{q_0, q_1\\} = q_B{q0​,q1​}=qB​\n{q0}=qA\\{q_0\\} = q_A{q0​}=qA​\n\n\n\n因此我们可以得到与该 NFA 等价的 DFA：\nD=({qA,qB,qC},{0,1},δD,qA,{qC})D = (\\{q_A, q_B, q_C\\}, \\{0, 1\\}, \\delta_D, q_A, \\{q_C\\})\nD=({qA​,qB​,qC​},{0,1},δD​,qA​,{qC​})\n\n\n\n\n\n 正则表达式转化 NFA\n假设正则表达式 E,FE, FE,F 转化成NFA后为 N(E),N(F)N(E), N(F)N(E),N(F)。\n使用下面的规则将正则表达式转化为NFA：\n\nN(∅)N(\\varnothing)N(∅)：终止状态为 ∅\\empty∅。\n\nN(ε)N(\\varepsilon)N(ε)：终止状态为初始状态。\n\nN(x)N(x)N(x)：从初始状态到终止状态有一条 xxx 的边。\n\nN(E+F)N(E+F)N(E+F)：两个自动机并行合在一起。\n\nN(EF)N(EF)N(EF)：删除所有 FFF 的起点箭头和 EEE 的接受状态，将所有连接到 EEE 接受状态的点（不是接受状态，接受状态被删除了）全部连接到 FFF 的初始状态。\n\n连向 FFF 初始状态的边值为这个点连一开始连向 EEE 接受状态的值。\n如果 EEE 中有 N(ε)N(\\varepsilon)N(ε)，则不删除 FFF 的起点箭头。(因为是起点空转移到 FFF 的起点，相当于不删除 FFF 的起点箭头)。\n\n\n\n\nN(EF)N(EF)N(EF) 的例子\n假设 N(E),N(F)N(E), N(F)N(E),N(F) 为下图：\n\n那么 N(EF)N(EF)N(EF) 为：\n\n如果 N(E)N(E)N(E) 存在 N(ε)N(\\varepsilon)N(ε)，如下图：\n\n那么 N(EF)N(EF)N(EF) 为：\n\n\n\n\nN(E∗)N(E^*)N(E∗)：将所有连向接受状态的点(不是接受状态)都连回初始状态，并增加一个 N(ε)N(\\varepsilon)N(ε) 的点。\n\n连回初始状态的边值为这个点连向接受状态的值。\n注意很容易忘记增加 N(ε)N(\\varepsilon)N(ε)。\n\n\n\n\nN(E∗)N(E^*)N(E∗) 的例子\n假设 N(E)N(E)N(E) 为下图：\n\n那么 N(E∗)N(E^*)N(E∗) 为：\n\n\n\n\n假设 E,FE, FE,F 使用的是 ε\\varepsilonε-NFA，即只有一个初始状态和结束状态，那么转化会更加简单。\n\n正则表达式转 ε\\varepsilonε-NFA 规则\n假设 E,FE, FE,F 如下图所示：\n\n\nN(∅),N(ε),N(x)N(\\varnothing), N(\\varepsilon), N(x)N(∅),N(ε),N(x) 同上。\nN(E+F)N(E+F)N(E+F) 为：\n\nN(EF)N(EF)N(EF) 为：\n\nN(E∗)N(E^*)N(E∗)为：\n\n\n\n\n 正则语言的泵原理 (Pumping lemma)\n泵原理(Pumping lemma)是用来判断某语言是否可以属于某一类语言的推论。泵原理往往用于证明语言不属于某一类语言。\n正则语言的泵原理(Pumping lemma for regular languages)是用来识别语言是否属于正则语言的推论。\n如果语言 LLL 是正则的，那么 ∃n∈N+,∀w∈L,∣w∣≥n→w=xyz:\\exist n \\in \\mathbb{N}^+, \\forall w \\in L, |w| \\geq n \\to w = xyz:∃n∈N+,∀w∈L,∣w∣≥n→w=xyz:\n\ny≠εy \\neq \\varepsilony=ε\n∣xy∣≤n|xy| \\leq n∣xy∣≤n\n∀k∈N,xykn∈L\\forall k \\in \\mathbb{N}, xy^kn \\in L∀k∈N,xykn∈L\n\n使用泵原理证明语言 LLL 不是正则语言使用反证法，步骤如下：\n\n假设 LLL 是正则的，且 nnn 是泵值(pumping number)。\n取 w=一个特殊情况∈Lw = \\text{一个特殊情况} \\in Lw=一个特殊情况∈L，我们可以知道 w=xyzw = xyzw=xyz 且 ∣xy∣≤n,y≠ε|xy| \\leq n, y \\neq \\varepsilon∣xy∣≤n,y=ε。\n但是我们得出 泵出 xy0zxy^0zxy0z 或 泵入 xy2zxy^2zxy2z ∉L\\notin L∈/L。\n根据泵原理，LLL 是正则的这一假设是错误的，因此 LLL 不是正则的。\n\ntip: 证明过程往往是举一个不符合泵原理的 w∈Lw \\in Lw∈L 例子，例如让项系数都等于 nnn。\n\n泵原理例子：证明语言 L={anbmcn+m∣n,m∈N}L = \\{a^nb^mc^{n+m} | n, m \\in \\mathbb{N}\\}L={anbmcn+m∣n,m∈N} 不是正则的例子\n\n假设 LLL 是正则的，且 nnn 是泵值(pumping number)。\n取 w=anbnc2n∈Lw = a^nb^nc^{2n} \\in Lw=anbnc2n∈L，我们可以知道 w=xyzw = xyzw=xyz 且 ∣xy∣≤n,y≠ε|xy| \\leq n, y \\neq \\varepsilon∣xy∣≤n,y=ε。\n因为 ∣xy∣≤n,y≠ε|xy| \\leq n, y \\neq \\varepsilon∣xy∣≤n,y=ε，因此 y=ap,0&lt;p≤ny = a^p, 0 &lt; p \\leq ny=ap,0&lt;p≤n。\n我们得出 xy0z=an−pbnc2nxy^0z = a^{n - p}b^nc^{2n}xy0z=an−pbnc2n，因为 0&lt;p≤n0 &lt; p \\leq n0&lt;p≤n，因此 n−p+n=2n−p≠2nn - p + n = 2n - p \\neq 2nn−p+n=2n−p=2n，也就是说 xy0z∉Lxy^0z \\notin Lxy0z∈/L。\n根据泵原理，LLL 是正则的这一假设是错误的，因此 LLL 不是正则的。\n\n\n\n证明语言 LLL 是正则往往不使用泵原理，而是：\n\n画出 LLL 的 DFA 或 NFA。\n写出 LLL 等价的正则表达式。\n\n\n 三. 上下文无关语言(CFL)\n 上下文无关文法 CFG\n上下文无关文法(Context-Free Grammar, CFG) 一般由四元组 G=(N,T,P,S)G = (N, T, P, S)G=(N,T,P,S) 表示：\n\nNNN：变元/非终结符的有穷集。\nTTT：终结符的有穷集，即字母表 Σ\\SigmaΣ，由 N∩T=∅N \\cap T = \\varnothingN∩T=∅。\nPPP：产生式的有穷集。\nSSS：初始符号，文法开始的地方，S∈NS \\in NS∈N。\n\n 上下文无关文法例子：识别回文语言\n回文字符串(palindrome)：wRw^RwR 表示字符串的反转，如果字符串 w∈Σ∗:w=wRw \\in \\Sigma^*: w = w^Rw∈Σ∗:w=wR，那么就称 www 是回文字符串。\n递归定义，假如字符串 AAA：\n\n∣A∣=0|A| = 0∣A∣=0 或者 ∣A∣=1|A| = 1∣A∣=1，那么 AAA 是回文字符串。\n如果 ∣A∣|A|∣A∣ 是回文字符串，那么 ∀a∈Σ:aAa\\forall a \\in \\Sigma: aAa∀a∈Σ:aAa 是回文字符串。\n\n回文语言：字母表组成的所有回文字符串的集合构成回文语言，即\nLpal={w∣w∈Σ∗∧w=wR}L_{pal} = \\{w | w \\in \\Sigma^* \\land w = w^R\\}\nLpal​={w∣w∈Σ∗∧w=wR}\n\n回文语言不是正则语言。\n回文语言是上下文无关语言。\n\n正如递归定义，识别回文语言的上下文无关文法为(假设字母表为 {0,1}\\{0, 1\\}{0,1})：\nG=({A},{0,1},{A→ε∣0∣1∣0A0∣1A1},A)G = (\\{A\\}, \\{0, 1\\}, \\{A \\to \\varepsilon|0|1|0A0|1A1\\}, A)\nG=({A},{0,1},{A→ε∣0∣1∣0A0∣1A1},A)\n其他字母表类似。\n CFG 语法树/派生树\nCFG语法分析树又称为派生树(Derivation trees)，是用树的结构来表示CFG文法派生的过程。\n派生树与派生一一对应 (派生定义请看基本概念)，组成成分为：\n\n根节点由初始符号 SSS 表示。\n叶节点由终结符表示。\n内部节点由非终结符/变元表示。\n每一个子树可以表示为父节点的一个产生式，子节点从左到右为该产生式的右部。\n将树的叶节点从左到右(无视高度)结合起来就是该派生树派生出的字符串，被称为 产物。\n\n性质：\n\n确定性；每棵派生树都有唯一的最左(右)派生。\n\n\n派生树的例子\n考虑到这个文法 G=({S,A,B},{a,b},P,S)G = (\\{S, A, B\\},\\{a, b\\},P,S)G=({S,A,B},{a,b},P,S)\nP={S→ABA→aS ∣ εB→Sb ∣ ε}\\begin {aligned}\nP = \\{ &amp; S \\to AB \\\\\n &amp; A \\to aS \\ |\\ \\varepsilon \\\\\n &amp; B \\to Sb \\ |\\ \\varepsilon \\}\n\\end {aligned}\nP={​S→ABA→aS ∣ εB→Sb ∣ ε}​\n该文法的一种到 aaa 的派生为：\nS⇒GAB⇒GaSB⇒GaABB⇒GaBB⇒GaB⇒GaS \\underset{G}{\\Rightarrow} AB \\underset{G}{\\Rightarrow} aSB \\underset{G}{\\Rightarrow} aABB \\underset{G}{\\Rightarrow} aBB \\underset{G}{\\Rightarrow} aB \\underset{G}{\\Rightarrow} a\nSG⇒​ABG⇒​aSBG⇒​aABBG⇒​aBBG⇒​aBG⇒​a\n其派生树为：\n\n\n\n\n\n 歧义 (Ambiguity)\n如果 CFG GGG 使某个字符串有两种不同的派生和派生树，则称该文法 GGG 是歧义的(Ambiguity)。\n判定一个 CFG 是否是歧义的这个问题是不可判定的，即没有固定的算法来证明。\n有一些 CFL 语言 LLL 所有的 CFGCFGCFG 文法都是歧义的，那么称这个语言 LLL 是固有歧义的。\n\n例如 L={aibjck∣i=j or j=k}L = \\{a^ib^jc^k | i = j \\text{ or } j = k\\}L={aibjck∣i=j or j=k} 中任何形式为 anbncna^nb^nc^nanbncn 的串总会有两棵语法树。\n\n\n歧义的例子：没有优先级的算数表达式CFG\n考虑没有优先级的算数表达式文法：Gexp={N,T,P,S}G_{exp} = \\{N, T, P, S\\}Gexp​={N,T,P,S}\n\nN={E,I,D}N = \\{E, I, D\\}N={E,I,D}，分别表示表达式Expression、整型Integer、数字Digital。\nT={0,1,...,9,+,∗,(,)}T = \\{0, 1, ..., 9, +, *, (, )\\}T={0,1,...,9,+,∗,(,)} 表示数字和符号。\nPPP 为：\n\n E→ E+E∣ E∗E∣ (E)∣ II→ DI ∣ DD→  0 ∣ 1 ∣ 2 ∣ 3 ∣ 4 ∣ 5 ∣ 6 ∣ 7 ∣ 8 ∣ 9\\begin{aligned} \n    \\ E \\to\\ &amp; E + E \\\\\n       | \\ &amp; E * E \\\\\n       | \\ &amp; (E)   \\\\\n       | \\ &amp; I     \\\\\n    I \\to\\ &amp; DI\\ |\\ D \\\\\n    D \\to\\ &amp;\\ 0\\ |\\ 1\\ |\\ 2\\ |\\ 3\\ |\\ 4\\ |\\ 5\\ |\\ 6\\ |\\ 7\\ |\\ 8\\ |\\ 9\n\\end{aligned} E→ ∣ ∣ ∣ I→ D→ ​E+EE∗E(E)IDI ∣ D 0 ∣ 1 ∣ 2 ∣ 3 ∣ 4 ∣ 5 ∣ 6 ∣ 7 ∣ 8 ∣ 9​\n\nS=ES = ES=E。\n\n那么对于 1+2∗31 + 2 * 31+2∗3 来说，有下面两种派生树：\n\n先派生加再计算乘 (乘优先级大于加)：\n\n\n\n\n\n先派生乘再派生加 (加优先级大于乘)\n\n\n\n\n因此说文法 GexpG_{exp}Gexp​ 是有歧义的。\n\n\n消除歧义需要重新设计文法，其中一个方法是设计优先级。\n CFG 表达式优先级设计\n策略如下：\n\n不同优先级使用不同的变元。\n优先派生低优先级，在初步构造中 高优先级 视为一个变元。\n括号内部的优先级大于括号本身。\n如果是从左到右计算，则将右边式子作为下一优先级。反之亦然。\n\n因为先派生的是低优先级，所以先派生的是最右边的式子。\n\n\n\n\n优先级设计的例子：有优先级的算数表达式CFG\n有优先级的算数表达式文法：Gexp={N,T,P,S}G_{exp} = \\{N, T, P, S\\}Gexp​={N,T,P,S}\n\nN={E0,E1,E2,I,D}N = \\{E_0, E_1, E_2, I, D\\}N={E0​,E1​,E2​,I,D}。\nT={0,1,...,9,+,∗,(,)}T = \\{0, 1, ..., 9, +, *, (, )\\}T={0,1,...,9,+,∗,(,)} 表示数字和符号。\nPPP 为：\n\n E0→ E0+E1 ∣ E1 E1→ E1∗E2 ∣ E2 E2→ (E0) ∣ II→ DI ∣ DD→  0 ∣ 1 ∣ 2 ∣ 3 ∣ 4 ∣ 5 ∣ 6 ∣ 7 ∣ 8 ∣ 9\\begin{aligned} \n    \\ E_0 \\to\\ &amp; E_0 + E_1\\ |\\ E_1 \\\\\n    \\ E_1 \\to\\ &amp; E_1 * E_2\\ |\\ E_2 \\\\\n    \\ E_2 \\to\\ &amp; (E_0)\\ |\\ I \\\\\n    I \\to\\ &amp; DI\\ |\\ D \\\\\n    D \\to\\ &amp;\\ 0\\ |\\ 1\\ |\\ 2\\ |\\ 3\\ |\\ 4\\ |\\ 5\\ |\\ 6\\ |\\ 7\\ |\\ 8\\ |\\ 9\n\\end{aligned} E0​→  E1​→  E2​→ I→ D→ ​E0​+E1​ ∣ E1​E1​∗E2​ ∣ E2​(E0​) ∣ IDI ∣ D 0 ∣ 1 ∣ 2 ∣ 3 ∣ 4 ∣ 5 ∣ 6 ∣ 7 ∣ 8 ∣ 9​\n\nS=E0S = E_0S=E0​。\n\n那么 1+2∗31+2*31+2∗3 的派生树为：\n\n\n\n\n\n 文法的化简\n文法的化简有下面三个步骤，一般化简的顺序也如下：\n\n消除 ε\\varepsilonε 产生式：A→εA \\to \\varepsilonA→ε。\n消除单元产生式：A→BA \\to BA→B。\n消除无用符号：对文法定义语言没有贡献的符号。\n3.1 消除非产生的无用符号。\n3.2 消除非可达的无用符号。\n\n具体步骤分析：\n\n消除 ε\\varepsilonε 产生式：\n\n定义：\n\n形如 A→εA \\to \\varepsilonA→ε 的产生式被称为 ε\\varepsilonε 产生式。\n如果变元 A⇒G∗εA \\overset{*}{\\underset{G}{\\Rightarrow}} \\varepsilonAG⇒​∗​ε，那么称 AAA 是可空的。\n\n如果 A→εA \\to \\varepsilonA→ε，那么 AAA 是可空的。\n如果 B→αB \\to \\alphaB→α 且 α\\alphaα 中所有的符号都是可空的，那么 BBB 是可空的。\n所有终结符 a∈Ta \\in Ta∈T 都是非可空的。\n\n\n\n\n步骤：\n\n判断：判断哪些变元是可空的。\n删除：删除所有 ε\\varepsilonε 产生式。\n替换：将含有可空变元的一条产生式 A→X1X2...XnA \\to X_1X_2...X_nA→X1​X2​...Xn​，用 一组 产生式 A→Y1Y2...YnA \\to Y_1Y_2...Y_nA→Y1​Y2​...Yn​ 代替。\n\n若 XiX_iXi​ 不是可空的，那么 YiY_iYi​ 为 XiX_iXi​。\n若 XiX_iXi​ 是可空的，那么 YiY_iYi​ 为 XiX_iXi​ 或 ε\\varepsilonε。使用排列组合的方式分别替换为 XiX_iXi​ 或者 ε\\varepsilonε。\nYiY_iYi​ 不能全部为 ε\\varepsilonε。\n假设一个产生式中可空的数量为 nnn：\n\n如果全部都是可空的，那么产生式组的个数为 2n−12^n - 12n−1\n如果存在不可空的，那么产生式组的个数为 2n2^n2n。\n\n\n\n\n\n\n性质：消除 ε\\varepsilonε 产生式后的文法是 L−{ε}L - \\{\\varepsilon\\}L−{ε}，即不存在空串的文法。\n\n\n\n\n消除 ε\\varepsilonε 产生式例子\n考虑下面的文法：\n{S→ABA→AaA ∣ εB→BbB ∣ ε\\begin{cases}\nS \\to AB \\\\\nA \\to AaA\\ |\\ \\varepsilon \\\\\nB \\to BbB\\ |\\ \\varepsilon\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​S→ABA→AaA ∣ εB→BbB ∣ ε​\n判断：\n根据 A→εA \\to \\varepsilonA→ε 和 B→εB \\to \\varepsilonB→ε 可知 A,BA, BA,B 是可空的。\n因为 S→ABS \\to ABS→AB，A,BA, BA,B 是可空的，因此 SSS 是可空的。\n删除：删除所有 ε\\varepsilonε 产生式。\n{S→ABA→AaAB→BbB\\begin{cases}\nS \\to AB \\\\\nA \\to AaA \\\\\nB \\to BbB\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​S→ABA→AaAB→BbB​\n替换：\n{S→AB ∣ A ∣ BA→AaA ∣ aA ∣ Aa ∣ aB→BbB ∣ bB ∣ Bb ∣ b\\begin{cases}\nS \\to AB\\ |\\ A\\ |\\ B \\\\\nA \\to AaA\\ |\\ aA\\ |\\ Aa\\ |\\ a \\\\\nB \\to BbB\\ |\\ bB\\ |\\ Bb\\ |\\ b\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​S→AB ∣ A ∣ BA→AaA ∣ aA ∣ Aa ∣ aB→BbB ∣ bB ∣ Bb ∣ b​\nSSS 是全部可空的，因此产生式组的个数为 22−1=32^2 - 1 = 322−1=3。\nA,BA, BA,B 是部分可空的，因此产生式组的个数为 22=42^2  = 422=4。\n\n\n\n消除单元产生式：A→BA \\to BA→B：\n\n定义：\n\n如果有 A⇒GBA {\\underset{G}{\\Rightarrow}} BAG⇒​B，那么称 [A,B][A, B][A,B] 为单元对。\n\nA→B∈PA \\to B \\in PA→B∈P，则 [A,B][A, B][A,B] 是单元对。\n若 [A,B],[B,C][A, B], [B, C][A,B],[B,C] 是单元对，那么 [A,C][A, C][A,C] 是单元对。\n\n\n\n\n步骤：\n\n判断：判断哪些为单元对。\n删除：删除全部形为 A→BA \\to BA→B 的单元产生式。\n复制：将单元对 [A,B][A, B][A,B] 中 BBB 的产生式复制给 AAA。\n\n\n\n\n\n\n消除单元产生式例子\n考虑下面的文法：\n{S→A ∣ B ∣ 0S1A→0A ∣ 0B→1B ∣ 1\\begin{cases}\nS \\to A\\ |\\ B\\ |\\ 0S1 \\\\\nA \\to 0A\\ |\\ 0 \\\\\nB \\to 1B\\ |\\ 1\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​S→A ∣ B ∣ 0S1A→0A ∣ 0B→1B ∣ 1​\n判断：\n由 S→AS \\to AS→A 和 S→BS \\to BS→B 可以知道单元对 [S,A][S, A][S,A], [S,B][S, B][S,B]，因此也可以知道单元对 [A,B][A, B][A,B]。\n删除：\n删除 S→AS \\to AS→A 和 S→BS \\to BS→B。\n{S→0S1A→0A ∣ 0B→1B ∣ 1\\begin{cases}\nS \\to 0S1 \\\\\nA \\to 0A\\ |\\ 0 \\\\\nB \\to 1B\\ |\\ 1\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​S→0S1A→0A ∣ 0B→1B ∣ 1​\n复制：\n将单元对 [S,A][S, A][S,A], [S,B][S, B][S,B] 中 A,BA, BA,B 产生式复制给 SSS。\n{S→0S1 ∣ 0A ∣ 1B ∣ 0 ∣ 1A→0A ∣ 0B→1B ∣ 1\\begin{cases}\nS \\to 0S1\\ |\\ 0A\\ |\\ 1B\\ |\\ 0\\ |\\ 1 \\\\\nA \\to 0A\\ |\\ 0 \\\\\nB \\to 1B\\ |\\ 1\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​S→0S1 ∣ 0A ∣ 1B ∣ 0 ∣ 1A→0A ∣ 0B→1B ∣ 1​\n\n\n\n消除无用符号：\n\n定义：在 CFG G=(N,T,P,S)G = (N, T, P, S)G=(N,T,P,S) 中，符号 X∈(N∪T)X \\in (N \\cup T)X∈(N∪T)：\n\n如果 S⇒G∗αXβS \\overset{*}{\\underset{G}{\\Rightarrow}}  \\alpha X \\betaSG⇒​∗​αXβ，那么称 XXX 是可达的。\n\n符号 SSS 是可达的。\nA→α∈PA \\to \\alpha \\in PA→α∈P，且 AAA 是可达的，那么 α\\alphaα 所有符号都是可达的。\n\n\n如果 αXβ⇒G∗w,w∈T∗\\alpha X \\beta \\overset{*}{\\underset{G}{\\Rightarrow}} w, w \\in T^*αXβG⇒​∗​w,w∈T∗，那么称 XXX 是产生的。\n\n所有终结符 TTT 都是产生的。\nA→α∈PA \\to \\alpha \\in PA→α∈P，且 α\\alphaα 符号都是产生的，那么 AAA 是产生的。\n\n\n如果 XXX 既是 产生的 也是 可达的，那么 XXX 就是 有用的。否则  XXX 就是 无用符号。\n\n\n步骤：\n\n删除所有非产生的无用符号。\n删除所有非可达的无用符号。\n\n\n\n\n\n\n消除无用符号例子\n考虑下面的文法：\n{S→AB ∣ aA→b\\begin{cases}\nS \\to AB\\ |\\ a \\\\\nA \\to b\n\\end{cases}\n{S→AB ∣ aA→b​\n消除非产生的：\n已知 a,ba, ba,b 是产生的。\n根据 A→bA \\to bA→b 可以知道 AAA 是产生的。\n根据 S→aS \\to aS→a 可以知道 SSS 是产生的。\n那么 BBB 是非产生的，删除得到：\n{S→aA→b\\begin{cases}\nS \\to a \\\\\nA \\to b\n\\end{cases}\n{S→aA→b​\n消除非可达的：\n已知 SSS 是可达的。\nAAA 是不可达的，因此删除得到：\n{S→a\\begin{cases}\nS \\to a\n\\end{cases}\n{S→a​\n\n\n CFG文法范式\n 解析器\n LL(1)解析器\n 消除左递归\n 下推自动机 (PDA)\n下推自动机(Pushdown Automata) PPP 是一个识别上下文无关语言 CFL 的不确定自动机。\n下推自动机相当于NFA增加了一个栈stack，并默认栈的储存是无限的。\n定义：下推自动机通常有七元组表示 P=(Q,Σ,Γ,δ,P,Z0,F)P = (Q, \\Sigma, \\Gamma, \\delta, P, Z_0, F)P=(Q,Σ,Γ,δ,P,Z0​,F)\n\nQQQ：有穷状态集。\nΣ\\SigmaΣ：有穷输入符号集(字母表)。\nΓ\\GammaΓ：有穷栈符号集。\nδ\\deltaδ：状态转移函数， δ:Q×(Σ∪{ε})×Γ→P(Q×Γ∗)\\delta: Q \\times  (\\Sigma \\cup \\{\\varepsilon\\}) \\times \\Gamma \\to P(Q \\times \\Gamma^*)δ:Q×(Σ∪{ε})×Γ→P(Q×Γ∗)\n\n一般表示为 δ(q,a,Z)={(p0,β0),(p1,β1),...}\\delta(q, a, Z) = \\{(p_0, \\beta_0), (p_1, \\beta_1), ...\\}δ(q,a,Z)={(p0​,β0​),(p1​,β1​),...}\n\nqqq 表示当前状态。\naaa 表示当前输入项。\nZZZ 表示当前栈顶。\nppp 表示新的状态。\nβ\\betaβ 表示新的栈状态，类型如下：\n\n入栈：bZbZbZ 表示，其中 ZZZ 是当前栈顶，b∈Γb \\in \\Gammab∈Γ 为新的栈顶。\n出栈：ε\\varepsilonε 表示。\n无任何操作：ZZZ 表示。\n\n\n\n\n\n\nPPP 是初始状态集合, P⊆QP \\subseteq QP⊆Q。\nZ0Z_0Z0​ 是初始栈顶，Z0∈ΓZ_0 \\in \\GammaZ0​∈Γ。\nFFF 是接受状态集合, F⊆QF \\subseteq QF⊆Q。\n\n PDA 状态转移图表示\n对于 δ(q,a,Z)={(p0,β0),(p1,β1),...}\\delta(q, a, Z) = \\{(p_0, \\beta_0), (p_1, \\beta_1), ...\\}δ(q,a,Z)={(p0​,β0​),(p1​,β1​),...}：\n\n由 qqq 节点连向 ppp 节点的有向边。\n边的值为 (a,Z,β)(a, Z, \\beta)(a,Z,β)。\n\n PDA的瞬时描述 (ID)\nPDA的瞬时描述(Instantaneous Description, ID)是来描述当前PDA处于的状态、栈和输入情况。\n一般用三元组 Q×Σ∗×Γ∗:Q \\times \\Sigma^* \\times \\Gamma^*:Q×Σ∗×Γ∗: (q,w,γ)(q, w, \\gamma)(q,w,γ) 来表示。\n\nqqq 表示当前的状态。\nwww 表示剩余输入串，下一个要接收的字符为 www 的第一个字符。\nγ\\gammaγ 表示栈状态。一般第一个字符是栈顶，最后一个字符是初始栈。\n\n瞬时描述转移到下一个瞬时描述的符号是 ⊢p\\vdash_p⊢p​，多次转移符号是 ⊢p∗\\vdash_p^*⊢p∗​\n 空栈和终态\n CFG 转化 PDA\n PDA 转化 CFG\n 泵原理\n 确定性上下文无关语言 (DCFL)\n 确定的下推自动机 (DPDA)\n\n 四. 上下文相关语言 (CSL)\n 上下文相关文法 (CSG)\n\n 五. 递归可枚举语言(REL)\n 递归可枚举语法(REG)\n 图灵机(Turing Machines)\n\n 六. 其他\n 停机问题 (Halting Problem)\n\n 📘Reference\n\n“Formal grammar.” Wikipedia, The Free Encyclopedia, 25 April 2024, en.wikipedia.org/wiki/Formal_grammar. Accessed 14 Jun. 2024.\n“Formal language.” Wikipedia, The Free Encyclopedia, 24 March 2024, en.wikipedia.org/wiki/Formal_language. Accessed 14 Jun. 2024.\n“Chomsky hierarchy.” Wikipedia, The Free Encyclopedia, 22 May 2024, en.wikipedia.org/wiki/Chomsky_hierarchy. Accessed 14 Jun. 2024.\n“Terminal and nonterminal symbols.” Wikipedia, The Free Encyclopedia, 27 Dec. 2023, en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols. Accessed 14 Jun. 2024.\n“Pumping lemma for regular languages.” Wikipedia, The Free Encyclopedia, 30 May 2024, en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages. Accessed 18 Jun. 2024.\n\n\n","slug":"笔记/笔记-LAC-形式语言与自动机","date":"2024-05-25T03:53:20.000Z","categories_index":"笔记","tags_index":"Notes,Automata Theory,Formal Languages,Theory","author_index":"zExNocs"},{"id":"ca7a89ba385cdbc1ce7b55d4c88122bd","title":"AIM - Optimization 优化算法","content":" 背景\n课程原名为Artificial Intelligence Methods(人工智能方法)，但实际上内容都是有关一些优化算法的内容，相比如今环境下主流的大模型、神经网络还是相差甚远。因为部分优化算法中也具备一些学习能力（比如说遗传算法），因此也可以被视为一种弱人工智能。\n 介绍\n本笔记主要分为下面几个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123;  printf(&quot;Hello World!&quot;);  return 0;&#125;","slug":"笔记/笔记-AIM-优化算法","date":"2024-05-25T03:52:11.000Z","categories_index":"笔记","tags_index":"Algorithm,AI,Optimization","author_index":"zExNocs"},{"id":"8e94a57200662cea86ae71df183554b9","title":"ADE - Algorithms Data Structures and Efficiency 算法数据结构和效率","content":" ✒️背景\n早在一年前就知道了这个有关算法和数据结构的课程。作为一个退役OIer，之前有接触过关于这个课程的内容，比如堆、图论等，因此是对这个课程具有很大兴趣的。\n不过这个课程并不是集中于讲解算法和数据结构，而是着重于使用理论对算法效率的分析，比如Big-Oh表示法。学算法竞赛的时候只是经常听说过和使用过时间复杂度、空间复杂度，不过一直以来对它们的理解都停留在算法在时间和空间上对某一或多种变量/输入的增长程度上，可以说是对这一类知识处于一种一知半解的状态。\n建议使用右边的导航选择性地阅读。\n 🔖介绍\n本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。\n本笔记主要分为下面五个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n\n一. 算法效率的评估\n二. Big-Oh表示法和其家族\n三. Master定理\n四. 数据结构\n五. 算法\n\n 一. 🔬算法效率的评估\n如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 程序的运行时间 来评估测量算法效率。\n在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 (关于SPFA，它死了) 。\n由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。\n\n 方法一：Experiment 实验统计\n\n\n\n\n\n\n\n\n\n\n实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。\n具体步骤如下:\n\n写一个程序实施该算法\n使用不同的输入大小和输入信息运行程序\n记录实际运行时间\n绘制并使用统计学分析（如回归分析）\n\n在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注最差的情况，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。\n 缺点 &amp; 局限性\n\n必须用程序实现该算法，可能会很耗时。\n需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。\n效率的评估受到硬件/软件/语言环境的影响。\n\n\n 方法二：Theory 理论分析\n\n\n\n\n\n\n\n\n\n理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。\n跟实验统计一样，我通常指关注最差的情况。\n 特点\n\n具有一定的抽象性。\n能够独立于硬件/软件/语言环境来评估算法的效率。\n能够考虑所有可能的输入。\n\n 缺点 &amp; 局限性\n\n实施过程可能会比较困难，需要一定的知识基础。\n在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。\n\n 评估标准\n在实验统计中，我们往往使用 程序的运行时间 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：原始运算数量。\n 原始运算的定义\n\n\n\n\n\n\n\n\n\n原始运算(primitive operations)是算法执行的基本运算。\n在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将汇编代码、算数运算视作一个原始运算。\n注意，原始运算的定义不是固定的，下面有更具体的说明。在这个笔记中，我们将这些操作视作一个原始运算：\n\n\n\n描述\n伪代码样例\n\n\n\n\n变量赋值\na ← 0\n\n\n数组索引\na[10]\n\n\n变量比较\na == 10\n\n\n算数运算\na + 1\n\n\n函数调用\nfunction()\n\n\n函数返回\nreturn 0\n\n\n\n注意：\n\n在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。\n数组索引需要用到袁术运算是因为它需要在内存中进行索引。\n函数调用属于原始运算是因为它需要在内存中进行索引。\n在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。\n\n对于其他的运算，都可以拆分为这些原始运算：\n\n\n\n描述\n分析\n操作数\n伪代码样例\n\n\n\n\nfor循环，循环次数为nnn\n要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)\n1+n+2n=3n+11+n+2n = 3n+11+n+2n=3n+1\nfor i ← 1 to n do\n\n\nfor循环，循环次数为(n−1)(n-1)(n−1)\n要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)\n1+2(n−1)+2(n−1)=4n−31+2(n-1)+2(n-1) = 4n-31+2(n−1)+2(n−1)=4n−3\nfor i ← 1 to (n-1) do\n\n\nwhile循环，循环次数为nnn\n每次循环只需要判断即可\nnnn\nwhile i &gt; n\n\n\nwhile循环，循环次数为(n−1)(n-1)(n−1)\n每次循环都需要进行判断和减法\n2(n−1)2(n-1)2(n−1)\nwhile i &gt; (n-1)\n\n\nif then判断，then内部原始运算数为kkk\n一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)\n1+k1 + k1+k\nif ... then ...\n\n\n\n\n一个计算原始运算数的例子: arrayMax(A, n)\n一个返回数组最大值arrayMax(A, n)的伪代码：\n123456Algorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)    if A[i] &gt; currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)  return currentMax         # 原始运算为1，函数返回\n综上所述，这个算法的原始运算总数为 2+(4n−3)+2(n−1)+2(n−1)+1=8n−42 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 = 8n - 42+(4n−3)+2(n−1)+2(n−1)+1=8n−4\n\n\n原始运算的个数并不是固定的，例如在计算操作 c←A[i]c \\leftarrow A[i]c←A[i] 中，你也可以认为是444个原始运算：\n\n获取AAA数组的指针储存在寄存器中。\n获取iii储存在寄存器中。\n计算A+iA + iA+i作为A[i]A[i]A[i]的指针储存在寄存器中。\n复制变量ccc的数值写在A+iA + iA+i指针的内存中。\n\n当然在这个笔记中，你也可以认为只有222个原始运算：\n\n根据iii索引获取A[i]A[i]A[i]数组位置 (数组索引)。\n将变量ccc的数值赋值给A[i]A[i]A[i] (变量赋值)。\n\n但是无论是444还是222，这个操作永远不可能会是2n2n2n，即它的增长率永远不可能会超过常数级(增长率的定义在下面)。\n\n\n\n\n\n\n\n\n\n原始运算的个数只与算法的效率有关，与正确性无关。\n 使用原始运算估算运行时间\n增长率(Growth Rate)指的是函数的因变量随着自变量的增加而增长的速率。\n\n\n\n\n\n\n\n\n\n对于算法来说，假设它的最差情况的运行时间为T(n)T(n)T(n)，那么T(n)T(n)T(n)的增长率是该算法的固有属性，是不受硬件/软件环境影响的。\n我们可以使用原始运算来估算运行时间，假设：\n\n原始运算的个数为P(n)P(n)P(n)。\n最快的原始运算所需要的时间为aaa，是一个常数。\n最慢的原始运算所需要的时间为bbb，是一个常数。\n\n可以得出：aP(n)≤T(n)≤bP(n)aP(n) \\leq T(n) \\leq bP(n)aP(n)≤T(n)≤bP(n)\n由于a和b都是常数，那么我们认为T(n)T(n)T(n)和P(n)P(n)P(n)具有相同的增长率。很明显T(n)T(n)T(n)和P(n)P(n)P(n)的导数肯定是不同的，因此增长率并不等同于导数。\n但是增长率有一种只可意会不可言传的感觉：这种增长率具体形式是什么样的？如何定义哪两个函数具有相同的增长率？那么就需要用到我们的Big-Oh表示法了。\n 二. 🏠Big-Oh表示法和其家族\n 基本知识\n我们需要一种函数分类(Classification of Functions)来通过缩放的行为将函数分组在一起，同一组的函数具有这样的相似性：\n\n删除不必要的细节。\n相对快速、简单。\n处理运行时可能会发生的“奇怪的”函数(例如分段函数)。\n在数学上拥有明确的定义。\n\n其中一种最佳的方法是使用Big-Oh表示法和其家族(Big-Oh notation and family)：\n\nOOO: Big-Oh\nΩ\\OmegaΩ: Big-Omega\nΘ\\ThetaΘ: Big-Theta\nooo: little-oh\nω\\omegaω: little-omega\n\n本笔记只集中于前四个的定义和Big-Oh的相关理论。\n\n Big-Oh：O(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is O(g(n))f(n) \\ is \\ O(g(n))f(n) is O(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∃c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ \\leq } \\color{black} c \\ g(n)\n∃c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣≤c g(n)\n注意:\n\n量词顺序是 ∃ ∃ ∀\\exist \\ \\exist \\ \\forall∃ ∃ ∀\nccc 和 n0n_0n0​必须是常数，不能随着nnn变化。不然这是没有意义的。\n注意符号&gt;,≥,≤&gt;,\\geq,\\leq&gt;,≥,≤的区分。相比之下是比较严格的(例如，n0n_0n0​ 不能等于 000, nnn 可以等于 n0n_0n0​)。\n\n此外，Big-Oh可以会被定义为：\nlim sup⁡n→∞f(n)g(n)&lt;∞\\limsup_{n\\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty \nn→∞limsup​g(n)f(n)​&lt;∞\n\n\n\n\n\n\n\n\n\nBig-Oh只规定了f(n)f(n)f(n)的增长率的上限(upper bound on the growth rate of the function)。\n 特点\n\nBig-Oh不关注算法或者是“算法最差的运行时间”，而是只关注于函数。也就是说它并不是对算法进行分类，而是对函数进行分类。\n一般f(n)f(n)f(n)表示运行时间，nnn表示输入的个数，所以Big-Oh中描述的函数一般为 f:N+→R+f: \\mathbb{N^+} \\to \\mathbb{R^+}f:N+→R+，g(n)g(n)g(n)也类似。\nBig-Oh只规定了f(n)f(n)f(n)的增长率的上限，也就是说，当nnn足够大时，f(n)f(n)f(n)的增长速率不大于g(n)g(n)g(n)。\nBig-Oh中g(n)g(n)g(n)的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于f(n)=1f(n) = 1f(n)=1可以是O(1)O(1)O(1)，但也可以是O(n)O(n)O(n)。因此g(n)g(n)g(n)的增长率越小越能反应出f(x)f(x)f(x)的增长率。\n\n 性质\nBig-Oh作为一个二元关系(binary relation)，拥有以下性质：\n\nBig-Oh具有自反性(Reflexive, e.g. xRxx R xxRx)，即 f(n)f(n)f(n) 是 O(f(n))O(f(n))O(f(n))。\nBig-Oh不具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)，例如 f(n)=1f(n) = 1f(n)=1 是 O(n)O(n)O(n)，但是 f(n)=nf(n) = nf(n)=n 不是 O(1)O(1)O(1)。\nBig-Oh具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。即如果 ∀n≥n1,f(n)≤c1g(n)\\forall n \\geq n_1, f(n) \\leq c_1g(n)∀n≥n1​,f(n)≤c1​g(n)，且∀n≥n2,g(n)≤c2h(n)\\forall n \\geq n_2, g(n) \\leq c_2h(n)∀n≥n2​,g(n)≤c2​h(n)，那么总有 ∀n≥n3,f(n)≤c1c2h(n),n3=max⁡(n1,n2)\\forall n \\geq n_3, f(n) \\leq c_1c_2h(n), n_3=\\max(n_1,n_2)∀n≥n3​,f(n)≤c1​c2​h(n),n3​=max(n1​,n2​)。\n\n综上所述，Big-Oh具有自反性和传递性，因此Big-Oh更像是⊂,∈,≤\\subset, \\in, \\leq⊂,∈,≤,而不是===，因此有一种表示方法是将Big-Oh视作集合，使用n∈O(n)n \\in O(n)n∈O(n)。此时也有会 O(lower_order)⊂O(heigher_order)O(lower\\_ order) \\subset O(heigher\\_ order)O(lower_order)⊂O(heigher_order)。\n此外，也有一种说法是使用f(n)=O(n)f(n) = O(n)f(n)=O(n)，其中等于号是一种单向的等于。但是本笔记中更偏向于使用“是”或者“is”来表示。\n 推论 &amp; 方法\n\n推论1：存在三个函数f(n)f(n)f(n), g(n)g(n)g(n), p(n)p(n)p(n)和正数k,b∈N+k, b\\in \\mathbb{N^+}k,b∈N+，如果f(n)f(n)f(n)是O(g(n))O(g(n))O(g(n))，且f(n)=k p(n)+bf(n)=k\\ p(n) + bf(n)=k p(n)+b，那么有p(n)p(n)p(n)是O(g(n))O(g(n))O(g(n))。\n\n\n证明推论1\n假设有c0&gt;0,n0&gt;0c_0 &gt; 0, n_0 &gt; 0c0​&gt;0,n0​&gt;0，对于n1≥n0n_1 \\geq n_0n1​≥n0​，有：\nf(n1)≤c0 g(n1)f(n_1) \\leq c_0 \\ g(n_1)f(n1​)≤c0​ g(n1​)，那么有：\nk p(n1)+b≤c0 g(n1)k\\ p(n_1) + b \\leq c_0 \\ g(n_1)k p(n1​)+b≤c0​ g(n1​)，整理得：\np(n1)≤c0kg(n1)−bkp(n_1) \\leq \\frac{c_0}{k}g(n_1) - \\frac{b}{k}p(n1​)≤kc0​​g(n1​)−kb​\n当n足够大时候，假设此时n1≥n2n_1 \\geq n_2n1​≥n2​，有 cg(n1)≥2bcg(n_1) \\geq 2bcg(n1​)≥2b\n从而有 p(n1)≤c02kg(n1)p(n_1) \\leq \\frac{c_0}{2k}g(n_1)p(n1​)≤2kc0​​g(n1​)\n设 c1=c2k&gt;0c_1=\\frac{c}{2k}&gt;0c1​=2kc​&gt;0，我们得到：\np(n1)≤c1 g(n1)p(n_1) \\leq c_1\\ g(n_1)p(n1​)≤c1​ g(n1​)，即\n存在 c1c_1c1​，n2n_2n2​使得 ∀n&gt;n2,p(n)≤c1 g(n)\\forall n &gt; n_2, p(n) \\leq c_1\\ g(n)∀n&gt;n2​,p(n)≤c1​ g(n)\n因此p(n)p(n)p(n)是O(g(n))O(g(n))O(g(n))。\n\n\n\n推论2 （乘法）：如果f1(n)f_1(n)f1​(n) 是 O(g1(n))O(g_1(n))O(g1​(n)), f2(n)f_2(n)f2​(n) 是 O(g2(n))O(g_2(n))O(g2​(n))，那么 f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 O(g1(n)g2(n))O(g_1(n)g_2(n))O(g1​(n)g2​(n))。\n\n\n证明推论2\n∵f1(n)∵ f_1(n)∵f1​(n) 是 O(g1(n))O(g_1(n))O(g1​(n))\n∴f1(n)≤c1 g1(n)  for all  n≥n1∴ f_1(n) \\leq c_1\\ g_1(n)\\ \\text{ for all } \\ n \\geq n_1∴f1​(n)≤c1​ g1​(n)  for all  n≥n1​\n∵f2(n)∵ f_2(n)∵f2​(n) 是 O(g2(n))O(g_2(n))O(g2​(n))\n∴f2(n)≤c2 g2(n)  for all  n≥n2∴ f_2(n) \\leq c_2\\ g_2(n)\\ \\text{ for all } \\ n \\geq n_2∴f2​(n)≤c2​ g2​(n)  for all  n≥n2​\n∵f1(n),f2(n),g1(n),g2(n)≥0∵ f_1(n), f_2(n), g_1(n), g_2(n) \\geq 0∵f1​(n),f2​(n),g1​(n),g2​(n)≥0\n那么有 n0=max⁡(n1,n2)n_0 = \\max(n_1, n_2)n0​=max(n1​,n2​)\nf1(n)f2(n)≤c1c2g1(n)g2(n)  for all  n≥n0f_1(n)f_2(n) \\leq c_1c_2g_1(n)g_2(n) \\ \\text{ for all } \\ n \\geq n_0f1​(n)f2​(n)≤c1​c2​g1​(n)g2​(n)  for all  n≥n0​\n因此f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 O(g1(n)g2(n))O(g_1(n)g_2(n))O(g1​(n)g2​(n))\n\n\n\n推论3 （加法）：如果 f(n)=1+h(n)f(n) = 1 + h(n)f(n)=1+h(n)，且当n→∞n \\to \\inftyn→∞ 时 h(n)→0h(n) \\to 0h(n)→0，那么 f(n)f(n)f(n) 是 O(1)O(1)O(1)。\n\n\n证明推论3\n∵∵∵ 当n→∞n \\to \\inftyn→∞ 时 h(n)→0h(n) \\to 0h(n)→0\n∴∴∴ ∃n0&gt;0, ∀n≥n0,h(n)≤1\\exist n_0 &gt; 0,\\ \\forall n \\geq n_0, h(n) \\leq 1∃n0​&gt;0, ∀n≥n0​,h(n)≤1\n∴∴∴ ∃n0&gt;0, ∀n≥n0,f(n)≤2\\exist n_0 &gt; 0,\\ \\forall n \\geq n_0, f(n) \\leq 2∃n0​&gt;0, ∀n≥n0​,f(n)≤2\n∴∴∴ f(n)f(n)f(n) 是 O(1)O(1)O(1) 取 c=2,n0=n1c = 2, n_0 = n_1c=2,n0​=n1​ 且 h(n1)&lt;=1h(n_1) &lt;= 1h(n1​)&lt;=1\n\n\n一些常用的 h(n)h(n)h(n):\n\nn2/2nn^2/2^nn2/2n\nn2000/2n100n^{2000}/2^{\\frac{n}{100}}n2000/2100n​\n(log(n))100/n0.1(log(n))^{100} / n^{0.1}(log(n))100/n0.1\n\n综合推论2和3，可知如果 f(n)=g(n)(1+h(n))f(n) = g(n)(1 + h(n))f(n)=g(n)(1+h(n))，且当n→∞n \\to \\inftyn→∞ 时 h(n)→0h(n) \\to 0h(n)→0，那么 f(n)f(n)f(n) 是 O(g(n))O(g(n))O(g(n))。\n因此我们总结了获取Big-Oh的通用方法 —— 删除规则(Drop Rules)：\n\n删除低阶(lower-order)项 (根据推论2, 3)。阶排名可以看下面常用表示表。\n删除常数(constant)项系数 (根据推论1,总能找到 kkk 使得系数变成 111)。\n\n 例子\n\n证明arrayMax(A, n)是 O(n)O(n)O(n) 的例子 (定义)\n由上述计算原始运算数的例子可知，arrayMax(A, n)的原始运算记数为 f(n)=8n−4f(n) = 8n - 4f(n)=8n−4\n设g(n)=ng(n) = ng(n)=n，因此需要求证 ∃c&gt;0,∃n0&gt;0,∀n≥n0,f(n)≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​,f(n)≤c g(n)，整理可得：\n{n≤4c−8c&gt;8n≥4c−8c&lt;8−4≤0c=8\\begin{cases}\nn \\leq \\frac{4}{c - 8} &amp; c &gt; 8 \\\\\nn \\geq \\frac{4}{c - 8} &amp; c &lt; 8 \\\\\n-4 \\leq 0 &amp; c = 8\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​n≤c−84​n≥c−84​−4≤0​c&gt;8c&lt;8c=8​\n由于我们规定是 ∀n≥n0\\forall n \\geq n_0∀n≥n0​，因此我们只能取 n≥8n \\geq 8n≥8。\n当我们取 n=8n = 8n=8时，很明显任意n0&gt;0n_0 &gt; 0n0​&gt;0都可以证明成立。此时我们可以取 n0=1n_0 = 1n0​=1。\n当我们取 n&gt;8n &gt; 8n&gt;8时，很明显任意n0&gt;4c−8n_0 &gt; \\frac{4}{c - 8}n0​&gt;c−84​都可以证明成立。此时我们可以取 n0=4c−8n_0 = \\frac{4}{c - 8}n0​=c−84​。\n实际上，上述情况只需要求出一组(c,n0)(c,n_0)(c,n0​)即可，因此我们可以直接取c=8,n0=1c = 8, n_0 = 1c=8,n0​=1。不过这里给出了一种选取(c,n0)(c,n_0)(c,n0​)的具体方法。\n因此arrayMax(A, n)的时间复杂度是 O(n)O(n)O(n)。\n\n\n\n对于分段函数Big-Oh的证明 (定义)\n如何计算下面函数的Big-Oh:\nf(n)={nif n is even1if n is oddf(n) = \n\\begin{cases}\nn &amp; \\text{if } n \\text{ is even} \\\\\n1 &amp; \\text{if } n \\text{ is odd}\n\\end{cases}\nf(n)={n1​if n is evenif n is odd​\n因为Big-Oh是规定的函数增长率的上限，因此我们应该取增长率最大的函数，即f(n)=nf(n) = nf(n)=n，此时当c=1,n0=1c = 1, n_0 = 1c=1,n0​=1可以证明出f(n)f(n)f(n)是O(n)O(n)O(n)，而无法证明出f(n)f(n)f(n)是O(1)O(1)O(1)。\n\n\n\n求 f(n)=n2+nf_(n) = n^2 + nf(​n)=n2+n 的Big-Oh (定理2, 3)\nf(n)=n2+n=n2(1+1n)f(n) = n^2 + n = n^2(1 + \\frac{1}{n})f(n)=n2+n=n2(1+n1​)\n因为自反性，n2n^2n2 是 O(n2)O(n^2)O(n2)。\n因为当n→∞n \\to \\inftyn→∞ 时 1n→0\\frac{1}{n} \\to 0n1​→0，根据推理3可知 1+1n1 + \\frac{1}{n}1+n1​ 是 O(1)O(1)O(1)。\n因此根据推理2，f(n)f(n)f(n) 是 O(n2∗1)=O(n2)O(n^2 * 1) = O(n^2)O(n2∗1)=O(n2)\n\n\n\n求 f(n)=5n4+3n3f_(n) = 5n^4 + 3n^3f(​n)=5n4+3n3 的Big-Oh (删除规则)\n\n删除低阶3n3^n3n，因此f(n)f(n)f(n) 是 O(5n4)O(5n^4)O(5n4)\n删除常数555，因此f(n)f(n)f(n) 是 O(n4)O(n^4)O(n4)\n\n\n\n Big-Oh公约\n遵循这个公约可以更好地去分析算法以及给出最大的信息。\n\n使用最小且正确的增长率函数表示Big-Oh。例如说 2n2n2n 是 O(n)O(n)O(n) 而不是 O(n2)O(n^2)O(n2)，尽管后者也是正确的。\n使用最简的函数表示Big-Oh。例如说 2n2n2n 是 O(n)O(n)O(n) 而不是 O(2n)O(2n)O(2n)。\n\n 其他\n对于 nO(1)n^{O(1)}nO(1)来说，相当于是 {nf(n) ∣ f(n) is O(1)}\\{ n^f(n)\\ |\\ f(n) \\text{ is } O(1)\\}{nf(n) ∣ f(n) is O(1)}。\n也就是说 {n1,n2,n3,...}⊂nO(1)\\{n^1, n^2, n^3, ...\\} \\subset n^{O(1)}{n1,n2,n3,...}⊂nO(1)，{n12,n13,n14...}⊂nO(1)\\{n^\\frac{1}{2}, n^\\frac{1}{3}, n^\\frac{1}{4}... \\} \\subset n^{O(1)}{n21​,n31​,n41​...}⊂nO(1)\n\n\n\n\n\n\n\n\n\nnO(1)n^{O(1)}nO(1) is any function that is no worse than (Big-Oh of) some power law.\nnO(1)n^{O(1)}nO(1)表示任何不超过指数级的函数。\n\n Big-Omega：Ω(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is Ω(g(n))f(n) \\ is \\ \\Omega (g(n))f(n) is Ω(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∃c&gt;0,∃n0&gt;0,∀n≥n0:f(n)≥c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : f(n) \\color{red} \\boldsymbol{ \\geq } \\color{black} c \\ g(n)\n∃c&gt;0,∃n0​&gt;0,∀n≥n0​:f(n)≥c g(n)\n注意：\n\n量词顺序是 ∃ ∃ ∀\\exist \\ \\exist \\ \\forall∃ ∃ ∀。\n与Big-Oh不同，最后的符号是 ≥\\geq≥ 而不是 ≤\\leq≤。\n\n此外，Big-Omega可以会被定义为：\nlim inf⁡n→∞f(n)g(n)&gt;0\\liminf_{n\\to \\infty} \\frac{f(n)}{g(n)} &gt; 0 \nn→∞liminf​g(n)f(n)​&gt;0\n 特点\n\nBig-Omega规定了f(n)f(n)f(n)的增长率的下限，也就是说，当nnn足够大时，f(n)f(n)f(n)的增长速率不小于g(n)g(n)g(n)。\nBig-Omega中g(n)g(n)g(n)的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于f(n)=n3−nf(n) = n^3 - nf(n)=n3−n 可以是 Ω(n3)\\Omega(n^3)Ω(n3)，但也可以是 Ω(n2)\\Omega(n^2)Ω(n2)。因此g(n)g(n)g(n)的增长率越大越能说明f(n)f(n)f(n)的增长率。\n一般可以用来描述算法的最佳情况。\n\n 性质\n类似于Big-Oh，Big-Omega作为一个二元关系拥有下面的性质：\n\nBig-Omega具有自反性(Reflexive, e.g. xRxx R xxRx)。\nBig-Omega不具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)。\nBig-Omega具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。\n\nBig-Omega更像是 ≥\\geq≥。\n 推论 &amp; 方法\n\n推论1：f(n) is O(g(n))  ⟺  g(n) is Ω(f(n))f(n) \\text{ is } O(g(n))\\iff g(n) \\text{ is } \\Omega(f(n))f(n) is O(g(n))⟺g(n) is Ω(f(n))\n推论2 （乘法）：如果f1(n)f_1(n)f1​(n) 是 Ω(g1(n))\\Omega(g_1(n))Ω(g1​(n)), f2(n)f_2(n)f2​(n) 是 Ω(g2(n))\\Omega(g_2(n))Ω(g2​(n))，那么 f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 Ω(g1(n)g2(n))\\Omega(g_1(n)g_2(n))Ω(g1​(n)g2​(n))。\n\n删除规则依然适用于Big-Omega，但是注意删除法则跟Big-Oh一样是删除低阶函数而不是删除高阶函数。\n例如 f(n)=n3−nf(n) = n^3 - nf(n)=n3−n中，应该删除的是nnn。找到n3n^3n3后我们就可以找比n3n^3n3阶级低的函数来代替。\n\n Big-Theta：θ(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is Θ(g(n))f(n) \\ is \\ \\Theta (g(n))f(n) is Θ(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∃c′&gt;0,∃c′′&gt;0,∃n0&gt;0,∀n≥n0:c′ g(n)≤f(n)≤c′′ g(n)\\exist c&#x27; &gt; 0, \\exist c&#x27;&#x27;&gt;0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : c&#x27;\\ g(n) \\leq f(n) \\leq c&#x27;&#x27; \\ g(n)\n∃c′&gt;0,∃c′′&gt;0,∃n0​&gt;0,∀n≥n0​:c′ g(n)≤f(n)≤c′′ g(n)\n此外，Big-Theta可以被定义为：\n\n\n\n\n\n\n\n\n\nf(n) is Θ(g(n))  ⟺  f(n) is O(g(n)) and f(n) is Ω(g(n))f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } f(n) \\text{ is } \\Omega(g(n))\nf(n) is Θ(g(n))⟺f(n) is O(g(n)) and f(n) is Ω(g(n))\nf(n) is Θ(g(n))  ⟺  f(n) is O(g(n)) and g(n) is O(f(n))f(n) \\text{ is } \\Theta(g(n)) \\iff f(n) \\text{ is } O(g(n)) \\text{ and } g(n) \\text{ is } O(f(n))\nf(n) is Θ(g(n))⟺f(n) is O(g(n)) and g(n) is O(f(n))\n 性质\nBig-Theta作为一个二元关系拥有下面的性质：\n\nBig-Theta具有自反性(Reflexive, e.g. xRxx R xxRx)。\nBig-Theta具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)：如果 f(n)f(n)f(n) 是 Θ(g(n))\\Theta(g(n))Θ(g(n))，那么 g(n)g(n)g(n) 是 Θ(f(n))\\Theta(f(n))Θ(f(n))。可以根据Big-Theta的第二定义和Big-Omega的推论1得出。\nBig-Theta具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。\n\nBig-Theta更像是 ≈\\approx≈。\n\n little-oh：o(n)\n 定义\n假设有两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is o(g(n))f(n) \\ is \\ o(g(n))f(n) is o(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∀c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣&lt;c g(n)\\color{red} \\boldsymbol{ \\forall } \\color{black} c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ &lt; } \\color{black} c \\ g(n)\n∀c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣&lt;c g(n)\n注意:\n\n量词顺序是 ∀ ∃ ∀\\forall \\ \\exist \\ \\forall∀ ∃ ∀。\n因为是对于全部的 ccc 存在 n0n_0n0​，因此 n0n_0n0​ 的数值可以依赖于 ccc。\n与Big-Oh不同，最后的符号是 &lt;&lt;&lt; 而不是 ≤\\leq≤。\n\nlittle-oh也可以被定义为：\nlim⁡n→∞f(n)g(n)=0\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = 0\nn→∞lim​g(n)f(n)​=0\n 性质\nlittle-oh作为一个二元关系(binary relation)，拥有以下性质：\n\nlittle-oh不具有自反性(Reflexive, e.g. xRxx R xxRx)。即f(n)=nf(n) = nf(n)=n 不是 o(n)o(n)o(n)。\nlittle-oh不具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)。\nlittle-oh具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。\n\nlittle-oh 更像是严格的 &lt;&lt;&lt;。\n 特点\n\n与Big-Oh类似，little-Oh定义是函数的严格无法到达的上限。\nlittle-oh的意思是，当nnn足够大时，f(n)f(n)f(n)的增长速率小于g(n)g(n)g(n)。\nlittle-oh中 g(n)g(n)g(n) 阶级越小，越能说明 f(n)f(n)f(n) 的增长率。\n\n 推论 &amp; 方法\n\n推论1：如果f(n)f(n)f(n) 是 o(g(n))o(g(n))o(g(n))，那么 f(n)f(n)f(n) 一定是 O(g(n))O(g(n))O(g(n))\n正如 &lt; → ≤&lt;\\ \\to\\ \\leq&lt; → ≤ 一样，很明显 O(g(n))⊂o(g(n))O(g(n)) \\subset o(g(n))O(g(n))⊂o(g(n))。\n推论2 （乘法1）：如果f1(n)f_1(n)f1​(n) 是 o(g1(n))o(g_1(n))o(g1​(n)), f2(n)f_2(n)f2​(n) 是 o(g2(n))o(g_2(n))o(g2​(n))，那么 f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 o(g1(n)g2(n))o(g_1(n)g_2(n))o(g1​(n)g2​(n))。\n推论3 （乘法2）：如果f1(n)f_1(n)f1​(n) 是 o(g1(n))o(g_1(n))o(g1​(n)), f2(n)f_2(n)f2​(n) 是 O(g2(n))O(g_2(n))O(g2​(n))，那么 f1(n)f2(n)f_1(n)f_2(n)f1​(n)f2​(n) 是 o(g1(n)g2(n))o(g_1(n)g_2(n))o(g1​(n)g2​(n))。\n\n与Big-Oh类似，little-Oh也可以使用删除规则。与Big-Oh不同的是，little-Oh不能选择事实删除规则后的函数，而只能选择比该函数阶级更大的函数。\n 例子\n\n证明 f(n)=n2+nf(n) = n ^ 2 + nf(n)=n2+n 是 o(n3)o(n^3)o(n3)\n要证明f(n)=n2+nf(n) = n ^ 2 + nf(n)=n2+n 是 O(n3)O(n^3)O(n3)，则需要证明 ∀c&gt;0,∃n0&gt;0,∀n≥n0:f(n)&lt;c g(n)\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : f(n) &lt; c \\ g(n)∀c&gt;0,∃n0​&gt;0,∀n≥n0​:f(n)&lt;c g(n)。\n代入和整理可得 ∀c&gt;0,∃n0&gt;0,∀n≥n0:cn2−n−1&gt;0\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : cn^2-n-1 &gt; 0∀c&gt;0,∃n0​&gt;0,∀n≥n0​:cn2−n−1&gt;0。\n由公式可得，若 cn2−n−1=0cn^2-n-1 = 0cn2−n−1=0，且nr&gt;0n_r &gt; 0nr​&gt;0，可解得 nr=1+4c+12c&gt;0n_r = \\frac{1 + \\sqrt{4c + 1}}{2c} &gt; 0nr​=2c1+4c+1​​&gt;0。\n且当 n&gt;nrn &gt; n_rn&gt;nr​ 时，cn2−n−1&gt;0cn^2 - n - 1 &gt; 0cn2−n−1&gt;0 恒成立，那么可以取 n0=nr+1=1+4c+12c+1n_0 = n_r + 1 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1n0​=nr​+1=2c1+4c+1​​+1，使得 ∀n≥n0:f(n)&lt;c g(n)\\forall n \\geq n_0 : f(n) &lt; c \\ g(n)∀n≥n0​:f(n)&lt;c g(n) 恒成立。\n因此，f(n)=n2+nf(n) = n ^ 2 + nf(n)=n2+n 是 O(n3)O(n^3)O(n3)，此时对于所有的 ccc 取 n0=1+4c+12c+1n_0 = \\frac{1 + \\sqrt{4c + 1}}{2c} + 1n0​=2c1+4c+1​​+1。\n\n\n 关于Big-Oh和little-oh的定义上的思考：\n如果将Big-Oh的定义改为：∃c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣&lt;c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ &lt; } \\color{black}c \\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣&lt;c g(n)，称为 O&lt;O_&lt;O&lt;​，而原定义称为 O≤O_{\\leq}O≤​，\n那么实际上，对于 g(n)&gt;0g(n) &gt; 0g(n)&gt;0， f(n)f(n)f(n) 是 O&lt;(g(n))  ⟺  f(n)O_&lt;(g(n)) \\iff f(n)O&lt;​(g(n))⟺f(n) 是 O≤(g(n))O_{\\leq}(g(n))O≤​(g(n))。\n唯一的区别是对于 f(n)=0,g(n)=0f(n) = 0, g(n) = 0f(n)=0,g(n)=0 来说 000 是 O≤(0)O_{\\leq}(0)O≤​(0) 而不是 O&lt;(0)O_&lt;(0)O&lt;​(0)。\n而我们想要定义Big-Oh的渐进符号为 ≤\\leq≤，就得要求 000 是 O(0)O(0)O(0)，因此使用 ≤\\leq≤ 而不是 &lt;&lt;&lt;。\n同理，对于little-oh如果定义改为：∀c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣≤c g(n)\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\color{red} \\boldsymbol{ \\leq } \\color{black}c \\ g(n)∀c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣≤c g(n)，称为 o≤o_{\\leq}o≤​，而原定义称为 o&lt;o_{&lt;}o&lt;​。\n此时 o&lt;o_{&lt;}o&lt;​ 与 o≤o_{\\leq}o≤​ 定义的唯一区别也是当 f(n)=0,g(n)=0f(n) = 0, g(n) = 0f(n)=0,g(n)=0 的时候，此时 000 是 o≤(0)o_{\\leq}(0)o≤​(0) 而不是 o&lt;(0)o_{&lt;}(0)o&lt;​(0)。\n而我们想要定义little-oh的渐进符号是 &lt;&lt;&lt;，就得要求 000 不是 o(0)o(0)o(0)，那么使用的是 &lt;&lt;&lt; 而不是 ≤\\leq≤。\n实际上，对于Big-Oh和little-oh最主要的区别是 ∃c\\exist c∃c 和 ∀c\\forall c∀c。\n\n 常用表示表[1]\n根据阶级(order)从小到大排名。\n\n\n\n表示\n中文名\n英文名\n数量级\n\n\n\n\nO(nc),c&lt;0O(n^c), c &lt; 0O(nc),c&lt;0 ororor O(kn)O(\\frac{k}{n})O(nk​)\n负数幂级\nnegative power\n∞\\infty∞,不存在\n\n\nO(1)O(1)O(1)\n常数级\nconstant\n∞\\infty∞\n\n\nO(log⁡log⁡n)O(\\log{\\log{n}})O(loglogn)\n双对数级\ndouble logarithmic\n221062^{2^{10^6}}22106\n\n\nO(log⁡n)O(\\log{n})O(logn)\n对数级\nlogarithmic\n1030103010^{301030}10301030\n\n\nO((log⁡n)c),c&gt;1O((\\log{n})^c), c &gt; 1O((logn)c),c&gt;1\n多重对数级\npolylogarithmic\n2106c2^{10^{\\frac{6}{c}}}210c6​\n\n\nO(nc),0&lt;c&lt;1O(n^c), 0 &lt; c &lt; 1O(nc),0&lt;c&lt;1 ororor O(nc)O(\\sqrt[c]{n})O(cn​)\n分数幂级\nfractional power\n106c10^{6c}106c\n\n\nO(n)O(n)O(n)\n线性级\nlinear\n10610^6106\n\n\nO(nlog⁡n)=O(log⁡n!)O(n\\log{n}) = O(\\log{n!})O(nlogn)=O(logn!)\n对数线性/拟线性级\nloglinear, n-log-n\n10510^5105\n\n\nO(n2)O(n^2)O(n2)\n二次级\nquadratic\n10310^3103\n\n\nO(nc),c&gt;1O(n^c), c &gt; 1O(nc),c&gt;1\n多项式/代数级\npolynomial, algebraic\n106c\\sqrt[c]{10^6}c106​\n\n\nO(cn)O(c^n)O(cn)\n指数级\nexponential\n6log⁡c106\\log_{c}{10}6logc​10\n\n\nO(n!)O(n!)O(n!)\n阶乘级\nfactorial\n999\n\n\n\n\n Big-Oh家族使用样例\n\n用于表示一个范围：算法 X 最坏的情况时间复杂度是 o(n4)o(n^4)o(n4) 和 Ω(n3)\\Omega(n^3)Ω(n3)，但是实际表现并不确定。\n用于确定一个增长率：算法 X 最佳的情况时间复杂度是 Θ(n2)\\Theta(n^2)Θ(n2)。\n用来表示一个平均值：算法 X 平均情况时间复杂度是 O(n3)O(n^3)O(n3)。\n\n\n 使用Big-Oh家族分析算法效率注意点\nBig-Oh家族之所以实用是因为它隐藏了低阶项和常数。它们主要分析当 nnn 足够大时渐进的范围,也可以说是 nnn 的增长率。\n但是在 nnn 比较小时这些被隐藏掉的项可能会成为非常重要的参考指标。也就是说不能完全根据Big-Oh家族和阶级大小来完全判断一个算法的实际工作时的效率。\n例如：\n\n10000n10000n10000n 是 O(n)O(n)O(n)，同时 2n2^n2n 是 O(2n)O(2^n)O(2n)，当时当 nnn 比较小时，例如 n=6n = 6n=6 时，前者需要进行的计算数是 600006000060000，而后者是 646464，此时前者的效率是不如后者的。\nO(1.02n)O(1.02^n)O(1.02n) 尽管是指数级(exponential)，但是它的效率并不逊色。\n\n但是Big-Oh家族在理论上对算法效率进行分析往往是有效的，并且在 nnn 比小的时候程序所消耗的时间往往是会忽略不计的。\n\n 总结\n\nBig-Oh家族定义及其渐进表示法总结[1:1]\n\n\n\n\n表示法\n名字\n描述\n渐进符号\n形式定义\n\n\n\n\no(g(n))o(g(n))o(g(n))\nlittle-Oh\n函数渐进地由ggg支配\n&lt;&lt;&lt;\n∀c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣&lt;c g(n)\\forall c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : | f(n) | &lt; c \\ g(n)∀c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣&lt;c g(n)\n\n\nO(g(n))O(g(n))O(g(n))\nBig-Oh\n函数以ggg为渐进边界\n≤\\leq≤\n∃c&gt;0,∃n0&gt;0,∀n≥n0:∣f(n)∣≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : |f(n)| \\leq c\\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​:∣f(n)∣≤c g(n)\n\n\nΘ(g(n))\\Theta(g(n))Θ(g(n))\nBig-Theta\n函数由ggg为渐进边界和下边界\n≈\\approx≈\n∃c′&gt;0,∃c′′&gt;0,∃n0&gt;0,∀n≥n0:c′g(n)≤f(n)≤c′′g(n)\\exist c&#x27;&gt;0,\\exist c&#x27;&#x27;&gt;0, \\exist n_0 &gt; 0, \\forall n \\geq n_0 : c&#x27;g(n) \\leq f(n) \\leq c&#x27;&#x27;g(n)∃c′&gt;0,∃c′′&gt;0,∃n0​&gt;0,∀n≥n0​:c′g(n)≤f(n)≤c′′g(n)\n\n\nΩ(g(n))\\Omega(g(n))Ω(g(n))\nBig-Omega\n函数由ggg为渐进下边界\n≥\\geq≥\n∃c&gt;0,∃n0&gt;0,∀n≥n0:f(n)≥c g(n)\\exist c&gt;0,\\exist n_0&gt;0,\\forall n \\geq n_0: f(n) \\geq c\\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​:f(n)≥c g(n)\n\n\nω(g(n))\\omega(g(n))ω(g(n))\nlittle-omega\n函数渐进支配ggg\n&gt;&gt;&gt;\n∃c&gt;0,∀n0&gt;0,∃n≥n0:f(n)&gt;c g(n)\\exist c&gt;0,\\forall n_0 &gt; 0, \\exist n \\geq n_0 : f(n) &gt; c\\ g(n)∃c&gt;0,∀n0​&gt;0,∃n≥n0​:f(n)&gt;c g(n)\n\n\n\n\n如何求解一个算法的时间复杂度Big-Oh：\n\n建立算法函数的伪代码。\n求出该算法函数的原始运算数(number of primitive operator)和输入大小n的函数关系。\n根据该函数求出Big-Oh表示。\n\n\n\n\n 三. 🏫Master定理\n 分而治之(Divide and Conquer)\n分而治之是一个设计算法的思想，它通常能够高速地处理问题。\n分而治之的组成成分如下：\n\n分解 (Divide)：将输入分为两个或多个不相交的输入子集。\n递归 (Recur)：使用递归解决这些子集的子问题。\n组合 (Conquer)：将所有子集的解组合起来形成输入的解。\n\n\n 递归关系 Recurrence Relation\n定义：\n\n\n\n\n\n\n\n\n\nA recurrence relation is a recursively-defined function.\n递归关系(Recurrence Relation)是使用递归定义的函数。\n假设一个程序的运行时间是 T(n)T(n)T(n)，那么递归关系会在一系列小于n的值中来表达 T(n)T(n)T(n)。\n\n例子：归并排序(merge-sort)的递归关系及其时间复杂度的证明\n关于归并排序的具体算法请看下面 五. 算法 中 归并排序。\n假设归并排序的运行时间为 T(n)T(n)T(n)，那么\nT(n)=2 T(n2)+b+anT(1)=1\\begin{aligned}\nT(n) &amp; = 2\\ T(\\frac{n}{2}) + b + an \\\\T(1) &amp; = 1\n\\end{aligned}\nT(n)T(1)​=2 T(2n​)+b+an=1​\n\n2 T(n2)2\\ T(\\frac{n}{2})2 T(2n​) 表示数组分成了两个子数组，每个子数组的大小为 n2\\frac{n}{2}2n​。\nbbb 是分裂的花费。\nananan 是 merge 的花费。\n\n因此我们经过带入可以得到：\n\nT(2)=2 T(1)+b+2a=2+b+2aT(2) = 2\\ T(1) + b + 2a = 2 + b + 2aT(2)=2 T(1)+b+2a=2+b+2a\nT(4)=2 T(4)+b+4a=2(2+b+2a)+b+4a=4+3b+8aT(4) = 2\\ T(4) + b + 4a = 2 (2 + b + 2a) + b + 4a = 4 + 3b + 8aT(4)=2 T(4)+b+4a=2(2+b+2a)+b+4a=4+3b+8a\nT(8)=2 T(4)+b+8a=2(4+3b+8a)+b+8a=8+7b+24aT(8) = 2\\ T(4) + b + 8a = 2 (4 + 3b + 8a) + b + 8a = 8 + 7b + 24aT(8)=2 T(4)+b+8a=2(4+3b+8a)+b+8a=8+7b+24a\n\n由此我们猜测 T(2k)=2k+(2k−1)b+k 2ka,k∈NT(2^k) = 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}T(2k)=2k+(2k−1)b+k 2ka,k∈N\n我们可以使用数学归纳法(induction)来验证：\n\n\n\n\n\n\n\n\n\nClaim: T(2k)=2k+(2k−1)b+k 2ka,k∈NT(2^k) = 2^k + (2^k - 1)b + k\\ 2^ka, k\\in \\mathbb{N}T(2k)=2k+(2k−1)b+k 2ka,k∈N\nBase case: k=0,T(1)=1+0∗b+0∗1∗a=1k = 0, T(1) = 1 + 0 * b + 0*1*a = 1k=0,T(1)=1+0∗b+0∗1∗a=1 is meet the claim。\nStep case: Assume that the claim is true at k, and we need to prove that T(k+1)T(k + 1)T(k+1) is true.\nT(2k+1)=2 T(2k)+b+2k+1a=2(2k+(2k−1)b+k 2ka)+b+2k+1a=2k+1+(2k+1−2)b+b+k 2k+1a+2k+1a=2k+1+(2k+1−1)b+(k+1) 2k+1a\\begin{aligned} \nT(2^{k+1}) &amp; = 2\\ T(2^k) + b + 2^{k+1}a \\\\\n &amp; = 2 (2^k + (2^k - 1)b + k\\ 2^ka) + b + 2^{k + 1}a \\\\\n &amp; = 2^{k+1} + (2^{k+1} - 2)b + b + k\\ 2^{k+1}a + 2^{k + 1}a \\\\\n &amp; = 2^{k+1} + (2^{k+1} - 1)b + (k + 1)\\ 2^{k+1}a\n\\end{aligned} T(2k+1)​=2 T(2k)+b+2k+1a=2(2k+(2k−1)b+k 2ka)+b+2k+1a=2k+1+(2k+1−2)b+b+k 2k+1a+2k+1a=2k+1+(2k+1−1)b+(k+1) 2k+1a​\nQ.E.D.Q.E.D.Q.E.D.\n我们假设 T′(n)=n+(n−1)b+anlog⁡(n),for n=2k,k∈NT&#x27;(n) = n + (n - 1)b + an\\log(n), \\text{for } n = 2^k, k\\in \\mathbb{N}T′(n)=n+(n−1)b+anlog(n),for n=2k,k∈N。\n我们可以证明出 T(n)T(n)T(n) 是 Θ(T′(n))\\Theta(T&#x27;(n))Θ(T′(n))。\n因此，T(n)T(n)T(n) 是 Θ(nlog⁡n)\\Theta(n\\log n)Θ(nlogn)。\n\n\n\n Master定理 (Master Theorem)\n考虑存在下面的递归关系：\nT(n)=a T(nb)+f(n)T(1)=1\\begin{aligned}\nT(n) &amp; = a\\ T(\\frac{n}{b}) + f(n) \\\\\nT(1) &amp; = 1\n\\end{aligned}\nT(n)T(1)​=a T(bn​)+f(n)=1​\n这是一个由分而治之设计的算法：分解成 aaa 个子集，每个子集的大小是 nb\\frac{n}{b}bn​，此外每个递归/循环有一些额外的操作 f(n)f(n)f(n)。\nMaster定理(Master Theorem)是一个根据 a,ba, ba,b 的数值以及对 f(n)f(n)f(n) 进行放缩来快速求出T(n)T(n)T(n)的Big-Oh家族的方法。\n下面就对 f(n),a,bf(n), a, bf(n),a,b 不同情况进行讨论。\n注意，本笔记中不形式证明Master定理，具体可以自行查阅。\n &gt; f(n)=0f(n) = 0f(n)=0 时\n此时 T(n)=aT(nb)T(n) = aT(\\frac{n}{b})T(n)=aT(bn​)，我们可以使用数学归纳法证明出 T(bk)=akT(b^k) = a^kT(bk)=ak。\n我们令n=bkn = b^kn=bk，根据数学公式我们可以推导出 ak=(bk)log⁡baa^k = (b^k)^{\\log_ba}ak=(bk)logb​a，因此我们可以得到\nT(n)=nlog⁡baT(n) = n^{\\log_ba}\nT(n)=nlogb​a\n因此我们可以知道 T(n)T(n)T(n) 是 Θ(nlog⁡ba)\\Theta(n^{\\log_ba})Θ(nlogb​a)。\n &gt; f(n)≠0f(n) \\neq 0f(n)=0 时\n此时可以分为三种情况：\n\n\n\nf(n)f(n)f(n) 的形式\nccc 与 log⁡ba\\log_balogb​a 的关系\nT(n)T(n)T(n)的Big-Theta\n描述\n\n\n\n\nf(n)f(n)f(n) 是 O(nc)O(n^c)O(nc)\nc&lt;log⁡bac &lt; \\log_bac&lt;logb​a\nΘ(nlog⁡ba)\\Theta(n^{\\log_ba})Θ(nlogb​a)\nf(n)f(n)f(n) 的 增长率非常小，此时忽略 f(n)f(n)f(n)\n\n\nf(n)f(n)f(n) 是 Θ(nc(log⁡n)k),k≥0\\Theta(n^c(\\log n)^k), k \\geq 0Θ(nc(logn)k),k≥0\nc=log⁡bac = \\log_bac=logb​a\nΘ(nc(log⁡n)k+1)\\Theta(n^c(\\log n)^{k+1})Θ(nc(logn)k+1)\nf(n)f(n)f(n) 的 增长率适中，此时混合使用a,b,f(n)a, b, f(n)a,b,f(n)\n\n\nf(n)f(n)f(n) 是 Ω(nc)\\Omega(n^c)Ω(nc), 并满足正则条件\nc&gt;logbac &gt; log_bac&gt;logb​a\nΘ(f(n))\\Theta(f(n))Θ(f(n))\nf(n)f(n)f(n) 的 增长率非常大，此时只考虑 f(n)f(n)f(n)\n\n\n\n情况三中需要满足正则条件(Regularity Condition)：\n∃k&lt;1:af(nb)≤kf(n)\\exist k &lt; 1 : a f(\\frac{n}{b}) \\leq k f(n)\n∃k&lt;1:af(bn​)≤kf(n)\n该条件保证了这个条件确保 f(n)f(n)f(n) 不会增长过快导致 T(n)T(n)T(n) 完全被非递归部分主导。\n注意f(n)f(n)f(n) 的形式以及ccc 与 log⁡ba\\log_balogb​a 的关系。\n\n情况一中可知，f(n)f(n)f(n)的渐进上边界都不如 nlog⁡ban^{\\log_ba}nlogb​a，那么f(n)f(n)f(n) 的增长率是可以被忽略的。\n情况二中可知，f(n)f(n)f(n)的增长率是与 nlog⁡ban^{\\log_ba}nlogb​a 持平的，因此应该要混合使用a,b,f(n)a, b, f(n)a,b,f(n)。\n情况三中可知，f(n)f(n)f(n)的渐进下边界都超过了 nlog⁡ban^{\\log_ba}nlogb​a，因此只考虑 f(n)f(n)f(n)。\n\n\n 四. 🔒数据结构\n 一些定义\n\n\n遍历(Traversals)：指访问(visit)一个数据结构的所有元素。\n\n每一个元素只访问一次。\n访问的顺序是系统的、有序的、有意义的。\n\n\n\n抽象数据类型(Abstract Data Types, ADTs)：是数据结构的抽象。\n\n组成成分：\n\n储存的数据类型。\n对数据的操作。\n与操作相关的错误条件。\n\n\n一般ADT的相关操作会使用Big-Oh来限制效率。\n\n\n\n具体数据类型(Concrete Data Types, CDTs)：是数据结构的实际。\n\nADT的实现是通过选择不同的CDT。\nCDT是数据隐藏的和封装的（面向对象）。\nCDT的选择影响运行时间和空间使用。\n\n\n\n面向对象编程(Object-oriented)的原因：\n\n区分规范(specification) 和 实施细节(implementation details)\n使用相同的ADT来探索不同的CDTs。\n无需更改ADT的代码来快速更改和提升CDTs。\n\n\n\n\n 单向链表(Singly Linked List) (CDT)\n 介绍\n\n\n\n\n\n\n\n\n\nA singly linked list is a concrete data structure consisting of a sequence of nodes. Each node stores an element and a pointer/reference to the next node.\n 成员\n\nNode 节点\n\nElement 元素\nnext 指向下一个节点的指针\n\n\nhead : Node* 头节点指针\ntail : Node* 尾节点指针 (可选)\n\n 功能性函数\n插入类函数：\n\nvoid insertHead(Object)：插入头结点\n\n时间复杂度：O(1)O(1)O(1)\n\n\nvoid insertTail(Object)：插入尾节点\n\n如果有记录尾节点，时间复杂度： O(1)O(1)O(1)\n如果没有记录尾节点，时间复杂度： O(n)O(n)O(n)\n\n\n\n删除类函数：\n\nvoid removeHead()：删除头节点\n\n时间复杂度：O(1)O(1)O(1)\n\n\nvoid removeTail(Object)：删除尾节点\n\n无论有没有记录尾节点，时间复杂度：O(n)O(n)O(n)\n\n因为要让尾节点的前一个节点的next指针指向NULL\n\n\n\n\n\n交换类函数：\n\nvoid swapElement(Node, Node)：交换元素而不交换节点的位置\n\n时间复杂度 O(1)O(1)O(1)\n\n\nvoid swapNode(Node, Node)：交换节点的位置（不常用）\n\n时间复杂度 O(n)O(n)O(n)\n\n因为要找到这两个Node的上一个Node来修改next。\n\n\n\n\n\n\n 双向链表(Doubly Linked List) (CDT)\n 介绍\n\n\n\n\n\n\n\n\n\nA doubly linked list provides a natural extension of a singly linked list.Each node stores an element and a pointer/reference to the next node and a pointer/reference to the previous node.\n 成员\n\nNode 节点\n\nelement 元素\nnext 指向下一个节点的指针\npre 指向上一个节点的指针\n\n\nhead : Node* | Node 头节点指针/节点\ntail : Node* | Node 尾节点指针/节点\n\n 功能性函数\n插入类函数：\n\nvoid insertHead(Object)：插入头结点\n\n时间复杂度：O(1)O(1)O(1)\n\n\nvoid insertTail(Object)：插入尾节点\n\n如果有记录尾节点，时间复杂度： O(1)O(1)O(1)\n如果没有记录尾节点，时间复杂度： O(n)O(n)O(n)\n\n\nvoid insertAfter(Node, Object)：插入到Node节点后面\n\n时间复杂度：O(1)O(1)O(1)\n\n\n\n删除类函数：\n\nvoid removeHead()：删除头节点\n\n时间复杂度：O(1)O(1)O(1)\n\n\nvoid removeTail(Object)：删除尾节点\n\n如果有记录尾节点，时间复杂度： O(1)O(1)O(1)\n如果没有记录尾节点，时间复杂度： O(n)O(n)O(n)\n\n\n\n交换类函数：\n\nvoid swapElement(Node, Node)：交换元素而不交换节点的位置（不常用）\n\n时间复杂度 O(1)O(1)O(1)\n\n\nvoid swapNode(Node, Node)：交换节点的位置（建议）\n\n时间复杂度 O(1)O(1)O(1)\n\n\n\n 补充\n\n有两种双向链表设计方式\n\n让head和tail指向实实在在的节点。如果链表为空，则head = NULL, tail = NULL。\n分配head和tail为新的节点，节点的元素为空。如果链表为空，则head.next == tail。\n\n\n\n 数据结构的思考\n相比于数组 Array，链表数据结构具有较快的插入和删除能力。但是，链表具有较差的查询能力，其查询能力的时间复杂度是 O(n)O(n)O(n)。\n一般具有较快的插入、删除和查询能力的数据结构都比较复杂，例如：\n\n跳表 (Skip List)：其三个操作的时间复杂度都是 O(log⁡n)O(\\log n)O(logn)。\n平衡树(Balanced Trees)：其三个操作的时间复杂度都是 O(log⁡n)O(\\log n)O(logn)。\n\n红黑树(Red-Black Tree)\nAVL树(AVL Tree)\n\n\n哈希表(Hash Table)：其三个操作的平均时间复杂度都是 O(1)O(1)O(1)，最差情况下时间复杂度是 O(n)O(n)O(n)。\n\n\n 向量(Vector) (ADT)\n 介绍\n向量(Vector)是一种抽象数据类型(ADT)。向量的主要目的是创建一个比数组(Array)更泛用的模型。\n其主要的特性是：\n\n一个元素在向量中的索引(index)被认为是前面元素的个数(number of elements prceding it)。\n\n为了不完全依赖于数组，因此我们不使用“索引(index)”概念，而使用“前面元素的个数”概念。\n例如对于一个向量 AAA 来说，A[2]A[2]A[2] 表示有 222 个元素在它的前面，分别是 A[0],A[1]A[0], A[1]A[0],A[1]。\n这个概念也可以被称为排名(rank)。\n\n\n与数组固定大小不同，向量一个自动调节大小的数据结构。\n\n 向量ADT主要操作(operator)/方法\n\nObject elemAtRank(int r)：返回 rank 为 r 的元素。\nObject replaceAtRank(int r, Object o)：替换掉 rank 为 r 的元素为 o，并返回原来的元素。\nvoid insertAtRank(int r, Object o)：在 rank 为 r 的位置插入新的元素 o。\nObject removeAtRank(int r)：删除 rank 为 r 位置的元素。\nint size()：返回向量大小。\nboolean isEmpty()：返回向量是否为空。\n\n 使用向量作为栈(Stack)\n栈(Stack)是一个先入后出(first in last out, FILO)的数据结构，其操作主要是：\n\nObject top()：返回栈顶。\n\n相当于 elemAtRank(size())。\n\n\nvoid push(Object o)：在最后的元素(栈顶)后面添加一个新的元素。\n\n相当于 insertAtRank(size(), Object o)。\n\n\nvoid pop()：删除最后的元素(栈顶)。\n\n相当于 removeAtRank(size())。\n\n\n\n 基于数组的向量(Array-based Vector) (CDT)\n是使用一个大小为N的数组V作为向量的CDT，并使用整型变量n记录向量的大小。\n &gt;操作/方法时间复杂度分析\n\nelemAtRank(r)：可以直接返回V[r]，因此其时间复杂度是 O(1)O(1)O(1)。\nreplaceAtRank(r, o)：时间复杂度是 O(1)O(1)O(1)。\ninsertAtRank(r, o)：需要对原来的元素进行右平移，在最坏的情况下(即 r=0r = 0r=0 )时间复杂度是 O(n)O(n)O(n)。\nremoveAtRank(r, o)：需要对原来的元素进行左平移，在最坏的情况下(即 r=0r = 0r=0 )时间复杂度是 O(n)O(n)O(n)。\nsize()：直接返回变量 n，因此时间复杂度是 O(1)O(1)O(1)。\nisEmpty()：直接返回 n == 0，因此时间复杂度是 O(1)O(1)O(1)。\npush(o)：不需要进行平移。\n\n如果不需要扩大数组时间复杂度是 O(1)O(1)O(1)。\n扩大数组需要平摊时间(amortized time)获取时间复杂度。具体可以看下面扩大数组中不同策略。\n\n\npop()：不需要进行平移，因此时间复杂度是 O(1)O(1)O(1)。\n\n平摊时间(amortized time)是从一组操作中每个操作平摊下来的时间。与平均时间(average time)不同，后者主要是针对一次操作的平均时间。\n &gt;扩大数组(Resize Array)\n在insertAtRank(r, o) 和 push(o) 操作中，如果数组已经满了，那么需要替换数组为更大的数组。\n替换数组需要复制原来的数据到新的数据中。假设当前数组的大小为 ccc，每次替换所使用的时间为 s2s_2s2​，那么这个过程需要的时间T(c)=s2cT(c) = s_2cT(c)=s2​c，即这个过程的时间复杂度是 O(c)O(c)O(c)。\n扩大数组的方法一共有两种：\n\n\n增量策略(incremental strategy)：使用固定的常数 c 来进行扩大数组。\n\n假设执行push的次数为 nnn，那么替换数组的次数一共为 k=floor(n/c)k = floor(n / c)k=floor(n/c) 次。\n假设T(n)T(n)T(n)是执行push nnn 次所需要的运行时间，s1s_1s1​是一次push所需要的时间，s2s_2s2​是一次替换数组所需要的时间。\n\ns1s_1s1​ 和 s2s_2s2​ 都是常数。\nT(n)=s1n+s2(c+2c+...+kc)=s1n+s2ck(k+1)2T(n) = s_1n + s_2(c + 2c + ... + kc) = s_1n + s_2c\\frac{k(k+1)}{2}T(n)=s1​n+s2​(c+2c+...+kc)=s1​n+s2​c2k(k+1)​，因此 T(n)T(n)T(n) 是 O(n2)O(n^2)O(n2)。\n\n\n平摊下来每次 push 操作的时间复杂度是 T(n)n\\frac{T(n)}{n}nT(n)​ 是 O(n)O(n)O(n)。这个是要比一般 push 操作所需要的时间复杂度 O(1)O(1)O(1) 是要差的。\n\n\n\n双倍策略(doubling strategy)：双倍数组的大小。\n\n假设执行push的次数为 nnn，那么替换数组的次数一共为 k=floor(log⁡n)k = floor(\\log n)k=floor(logn) 次。\n假设T(n)T(n)T(n)是执行push nnn 次所需要的运行时间，s1s_1s1​是一次push所需要的时间，s2s_2s2​是一次替换数组所需要的时间。\n\ns1s_1s1​ 和 s2s_2s2​ 都是常数。\nT(n)=s1n+s2(1+2+4+...+2k−1)=(s1+s2)n−s2T(n) = s_1n + s_2(1 + 2 + 4 + ... + 2^{k - 1}) = (s_1 + s_2)n - s_2T(n)=s1​n+s2​(1+2+4+...+2k−1)=(s1​+s2​)n−s2​，因此 T(n)T(n)T(n) 是 O(n)O(n)O(n)。\n\n\n平摊下来每次 push 操作的时间复杂度是 T(n)n\\frac{T(n)}{n}nT(n)​ 是 O(1)O(1)O(1)。\n\n\n\n\n 树(Tree) (ADT)\n 介绍\n树是一种抽象数据结构(ADT)。\n\n\n\n\n\n\n\n\n\nIn computer science, a tree is an abstract model of a hierarchical structure. A tree consists of nodes with a parent-child relation.\n 成员\n\nNode 节点\n\nelement  元素\nparent 父节点\nchildren[] 子节点\n\n\nroot : Node* 根节点：不具有父节点的节点。\ninternal : Node 内节点：具有至少一个子节点的节点。\nleaf / external : Node 叶节点/外节点：不具有子节点的节点。\nancestors : Node → Node[] 祖先节点：(递归定义) 一个节点其父节点和其父节点的祖先节点的数组/集合。\ndescendant : Node → Node[] 祖孙节点：(递归定义) 一个节点其所有子节点和所有子节点的祖孙节点的数组/集合。\ndepth : Node → Int 节点的深度：该节点的祖先节点的个数(不包括自己)。\n\n根节点的深度为0，根节点的子节点深度为1，以此类推。\n\n\nheight : Tree → Int 树的高度：最大的叶节点深度。或者说从根节点到叶节点最长的路径(不包括根节点)。\n\n只有根节点的树的深度为0。\n\n\n\n 树ADT主要操作/方法：\n &gt; 基础方法 (Generic)：\n\nint size()：返回树的大小。\nbool isEmpty()：返回树是否为空。\nIterator iterator()：返回树的遍历所有元素的迭代器。\nIterator positions()：返回树的以一定顺序遍历位置的迭代器。\n\n &gt; 接入方法 (Accessor)：\n\nNode root()：返回树的根节点。\nNode parent(Node)：返回节点的父节点。\nIterator children(Node)：返回节点的子节点迭代器。\n\n &gt; 查询方法 (Query)：\n\nbool isInternal(Node)：是否是内部节点。\nbool isExternal(Node)：是否是叶节点。\nbool isRoot(Node)：是否是根节点。\n\n 树的遍历 (Traversals)\n &gt; 前序遍历 Preorder Traversal\n先遍历父节点，再从左到右遍历其子节点。\n1234Algorithm preOrder(v)  visit(v)  for each child w of v    preorder(w)\n &gt; 后序遍历 Postorder Traversal\n先遍历子节点，再遍历父节点\n1234Algorithm postOrde(v)  for each child w of v    postOrder(w)  visit(v)\n\n 二叉树(Binary Tree) (ADT)\n 定义\n二叉树是一种抽象数据结构(ADT)。\n\n一般定义：\n\n\n\n\n\n\n\n\n\n\na tree whose each internal node has at most two children, and the children of a node are an ordered pair, though one might be “missing”.\n\n递归定义：\n\n\n\n\n\n\n\n\n\n\nA tree consisting of a single node, or a tree whose root has an  ordered pair of “children”, each  of which is missing (a null) or is  the root of a binary tree\n\n特点：\n\n每个节点最多有两个子节点\n节点之间是有序的，即左子节点和右子节点，尽管有一个是空节点。\n\n\n\n 性质\n &gt; 合适/完满二叉树 (proper/full binary tree)\n\n\n\n\n\n\n\n\n\nA binary tree is said to be “proper” (a.k.a. “full”) if every internal node has exactly 2 children.\n如果二叉树的所有内部节点都具有两个子节点，那么称这个二叉树是合适/完满二叉树。\n &gt; 完美二叉树 (perfect binary tree)\n\n\n\n\n\n\n\n\n\nA binary tree is perfect if it is proper and all leaves are at the same depth.\n如果一个满二叉树中所有的子节点都在同一个深度，那么称这个二叉树是完美二叉树。\n\n在深度 ddd 拥有的节点的个数为 2d2^d2d\n在深度 ddd 及其以下的深度总结点个数为 2(d+1)−12^{(d+1)}-12(d+1)−1\n高度为 hhh 的树总节点为 nnn，那么有 h=log⁡2(n+1)−1h = \\log_{2}(n+1) - 1h=log2​(n+1)−1，n=2(h+1)−1n = 2^{(h + 1)} - 1n=2(h+1)−1\n\n &gt; 完全二叉树 (complete binary tree)\n\n\n\n\n\n\n\n\n\n除了叶节点所处的深度以外，其他深度是一个完美二叉树，并且叶节点是靠右排序的二叉树是完全二叉树。\n 二叉树的遍历 (Traversals)\n除了树通用的前序遍历和后序遍历以外，还有一个中序遍历(Inorder Traversal)：\n先遍历左子节点，再遍历该节点，最后遍历子节点。\n123456Algorithm inOrder(v)  if hasLeft(v)    inOrder(v.left)  visit(v)  if hasRight(v)    inOrder(v.right)\n 二叉树的效率分析\n\n求树的高度：如果树的大小为 nnn，那么：\n\n对于完美二叉树来说，时间复杂度是 Θ(log⁡(n))\\Theta(\\log(n))Θ(log(n))。\n对于非完美二叉树来说，考虑到一条链，时间复杂度是 Ω(log⁡(n))\\Omega(\\log(n))Ω(log(n)) 和 O(n)O(n)O(n)。\n\n\n\n 基于数组的二叉树 (Array-Based Representation of Binary Tree) (CDT)\n它也可以被称为 树形数组(tree-as-array)。它是一种使用数组作为CDT实现二叉树ADT的方式。\n一般使用 int rank(Node) 来表示节点的数组索引。注意，它返回的是整型。\n\nrank(root) = 1：根节点的索引是 111。\nrank(parent(node)) = rank(node) &gt;&gt; 1：每个节点的父节点是该节点的索引除以 222。\nrank(left_child(node)) = rank(node) &lt;&lt; 1：每个节点的左节点是该节点的索引乘以 222。\nrank(right_child(node)) = rank(node) &lt;&lt; 1 + 1：每个节点的右节点是该节点的索引乘以 222 加 111。\n\n树形数组的优点：\n\n能够节省空间。因为不用储存相关的指针，而是使用计算代替。\n储存能够更紧凑，具有更好的内存局部性&quot;better memory locality&quot;。\n很好地解决缓存和内存层次结构的问题——当访问数组元素时，其他条目可以被拉入缓存，因此访问速度更快。\n\n\n 优先队列(Priority Queue) (ADT)\n 介绍\n优先队列是一个抽象数据结构(ADT)。优先队列是储存一组具有 (key, value) 的数据结构，并能够有效地返回和操作其中具有最小/最大 key 的元素。\n一般我们默认优先队列是最小优先队列(Min-Priority Queue)，也就是返回/操作拥有最小key的元素。\n 优先队列ADT主要操作/方法：\n\nvoid insert(k, v)：插入一组(k, v)的元素。\nElement removeMin()：删除并返回具有最小key的元素。\nElement min()：返回具有最小key的元素。\nint size()：返回元素个数。\nbool isEmpty()：优先队列返回是否为空。\n\n 基于二叉堆(Binary Heap)的优先队列 (CDT)\n本笔记中默认的二叉堆是 小根堆。\n\n\n\n\n\n\n\n\n\nA binary heap is a complete binary tree storing key-value pairs at its nodes.\n二叉堆是将 (key, value) 对储存在节点的完全二叉树。\n除了二叉堆以外，还有二项式堆(Binomial Heap)和斐波那契堆(Fibonacci Heap)。\n二叉堆具有以下的性质：\n\nHeap-Order：对于每一个除了根以外的节点，都有 key(v) &gt;= key(parent(v))。\n\n即子节点的值不会比父节点更小。\n那么堆顶，即二叉堆的根节点是所有节点中的最小值。\n\n\nComplete Binary Tree：是一个二叉树。因此如果一共有 nnn 个节点，则树的高度为 h=log⁡nh = \\log nh=logn。\n\n 堆的插入(insert)\n步骤如下：\n\n根据完全二叉树性质寻找插入点 ZZZ 作为叶节点。\n储存 keykeykey 值给点 ZZZ。\n恢复堆序属性(unheap操作)：将插入点 ZZZ 从下到上进行 冒泡，如果父节点的 key 值比 ZZZ 大，那么就交换两个节点的位置或元素，直到父节点的 key 值比 ZZZ 小或者已经到达根节点。\n\n关于 111，如果使用结构体模拟树的结构，那么时间复杂度可能会达到 O(n)O(n)O(n)。但是如果使用数组作为CDT模拟二叉树(具体可看上方二叉树中基于数组的二叉树，树形数组)，那么只需要在数组的末尾插入新的节点即可，此时的时间复杂度是 O(1)O(1)O(1)。\n关于 333，因为二叉树的高度是 h=log⁡nh = \\log nh=logn，因此 upheap 操作的时间复杂度是 O(log⁡n)O(\\log n)O(logn)。\n 堆的删除(remove / pop)\n堆的删除指的是删除堆顶。步骤如下：\n\n使用最后一个节点 www 代替根节点。\n删除 www 原节点。\n恢复堆属性(Downheap操作)：选择两个子节点中最小的子节点，如果该子节点的key值比 www 节点的小，那么就交换两个节点的位置或元素，直到所有子节点的 key 值比 www 大或者已经达到叶节点。\n\n\n 映射(Maps) (ADT)\n 介绍\n\n\n\n\n\n\n\n\n\nA map models a collection of (key, value) entries that is searchable by the key.\n性质：\n\n具有搜索、插入、删除元素的功能。\n具有相同 key 值的元素是不被允许的。\n\n 映射ADT主要操作/方法：\n\nValue get(Key k)：如果存在key相应的元素，则通过 key 获取相应的 value，否则返回 NULL。\nValue put(Key k, Value v)：插入 (key, value) 对。如果已经存在 key 在映射里则返回 NULL，否则返回 value值。\nValue remove(Key k)：如果存在key相应的元素，则通过 key 来删除并返回该元素的 value，否则返回 NULL。\nint size()：返回元素个数。\nbool isEmpty()：返回是否为空。\nIterator keys()：返回 key 的迭代器。\nIterator values()：返回 value 的迭代器。\nIteraotr entries()：返回 (key, value) 的迭代器。\n\n 基于简单链表的MAP (CDT)\n\nget(k)：遍历链表来寻找 key。时间复杂度是 O(n)O(n)O(n)。\nput(k, v)：遍历链表来寻找是否有重复的 key，如果没有则插入到链表中。时间复杂度是 O(n)O(n)O(n)。\nremove(k, v)：遍历链表来寻找 key。时间复杂度是 O(n)O(n)O(n)。\n\n因为链表的特性（具有较差的访问能力），因此无论是排序的链表还是未排序的链表（链表无法使用二分查找法），时间复杂度操作都是 O(n)O(n)O(n)。\n 基于哈希表的MAP (CDT)\n基本思想：将每个 key 转化成 index 放入一个较大的数组 Array 中。\n哈希表的特性：\n\n哈希值 (hash value)：由哈希函数得到的值被称为哈希值。\n哈希码 h1h_1h1​ (hash code)：是一个键值转一个整型的函数，即keys → integers。一些可能的方法：\n\n将 key 的内存地址作为哈希码。\n将 key 的 bit 值转化成整型作为哈希码。一般用于内存不大于整型的数据类型，例如byte, short, int, float。\n将 key 的 bit 值划分成相同长度的部分，对这些部分求和(忽略溢出)。适用于内存大于整型的数据类型，例如 double, long。\n多项式累积方法。\n\n\n压缩函数 h2h_2h2​ (Compression function)：是一个将整型压缩到一定范围的函数，即integers → [0, N-1]。一些可能的方法：\n\n除法(Division)：h2(x)=xmod  Nh_2(x) = x \\mod Nh2​(x)=xmodN。\n\nNNN 通常是一个素数。\n\n\n乘加除法(Multiply, Add and Divide (MAD))：h2(x)=(ax+b)mod  Nh_2(x) = (ax + b) \\mod Nh2​(x)=(ax+b)modN。\n\na,ba, ba,b 是非负整数。\namod  N≠0a \\mod N \\neq 0amodN=0，否则无论 xxx 为多少总会映射到 bbb。\n\n\n\n\n哈希函数 hhh (hash function)：是一个将对象(Object)映射到一个固定的范围 [0,N−1][0, N-1][0,N−1] 整型的函数。\n\n此时有 h(x)=h2(h1(x))h(x) = h_2(h_1(x))h(x)=h2​(h1​(x))。\n哈希函数的主要目的是使用明显随机的方式来将 keys 分散。\n分散的目的是为了减少冲突(Collision)。\n随机的目的是为了减少模式(Pattern)，从而减少冲突。\n\n\n冲突 (Collision)：当不同的元素获取到相同的索引时，会发生冲突。一些可能的解决方法：\n\n分离链(Separate Chaining)：让相同 index 的元素以链表的形式连接起来。\n二叉搜索树(Binary Search Tree)。\n开放地址(Open addressing)：让冲突的新元素放入到下一个可用的数组中。一些可能的方法：\n\n线性探索(Linear probing)：使用一个常数 ccc 来进行冲突元素的新元素寻址，即h(k)+ch(k) + ch(k)+c。\n\n一般使用循环数组作为哈希表。\n可能会导致未来新元素使用更长的时间来寻址。\n如果数组满了可能会导致死循环，因此要规定最多循环次数。\n如果中间有冲突的数组被删除，可能会导致后面冲突的数组查询失败。\n\n一个删除的解决方案是不断检测右边是否具有相同的哈希值，如果相同则将该数值重新插入。\nLazy deletion延迟删除：将被删除的数值标记为“删除”，只当用到它的时候再进行修复。当被查询到“删除”标记的点时直接跳过而不是停止。\n\n\n\n\n双哈希(Double Hashing)：使用一个额外的哈希函数 d(k)d(k)d(k) 来辅助寻找新元素。\n\n新的哈希值为 (h(k)+j d(k))mod  N,j∈[0,N−1](h(k) + j\\ d(k))\\mod N, j\\in[0, N-1](h(k)+j d(k))modN,j∈[0,N−1]，选择第一个空元素作为哈希值。一些可能的 h(k)h(k)h(k)：\n\nd(k)=q−(kmod  q)d(k) = q - (k \\mod q)d(k)=q−(kmodq)，其中 q&lt;Nq &lt; Nq&lt;N 且 qqq 是素数。\n\n\n对于线性探索来说，d(k)=1d(k) = 1d(k)=1。\nNNN 必须是素数，以探索所有的可能数组包。\n\n\n\n\n\n\n\n那么使用哈希表来实现Map主要的思路是：\n\n寻找哈希函数：将 (k,v)(k,v)(k,v) 储存在 i=h(k)i = h(k)i=h(k) 索引的数组中。\n处理冲突。\n\n 基于分离链(Separate Chaining)处理冲突的方法\n因为分离链定义让相同 index 的元素以链表的形式连接起来，其中链表中每个节点还有一个单独的 key 值用于寻找具体的元素。\n那么链表的每个节点应该具有以下的操作，假设有 mmm 个冲突的元素：\n\nElement get(k)：获取key = k的元素。其时间复杂度是 O(m)O(m)O(m)。\nElement put(k, v)：放入(k, v)对的元素，需要检测是否有相同 key 的元素，如果有则返回null。因此时间复杂度是 O(m)O(m)O(m)。\nElement remove(k)：删除key = k的元素。其时间复杂度是 O(m)O(m)O(m)。\n\n那么使用基于分离链哈希表的map具体实现方式如下：\n\nget(k)：return A[h(k)].get(k)。\nput(k, v)：return A[h(k)].put(k)。注意要让 size++。\nremove(k): return A[h(k)].remove(k)。注意要让 size--。\n\n对于每个操作，最佳访问时间是 O(1)O(1)O(1)，最差访问时间依然是 O(n)O(n)O(n)，即全部都有冲突。但是平均下来，其时间复杂度应该是 O(n/N)O(n / N)O(n/N)，其中 NNN 是哈希表数组的容量。\n 哈希函数的性能分析\n在最坏的情况下，搜索、插入和删除的时间复杂度都是 O(n)O(n)O(n)。\n一般用负载因子(load factor) α=n/N\\alpha = n / Nα=n/N 来表示哈希表的性能。\n哈希表各个操作的期望值基本上都是 O(1)O(1)O(1)。具体证明可自行查阅。\n\n 二叉搜索树(Binary Search Tree) (ADT)\n\n\n\n\n\n\n\n\n\nA binary search tree is a binary tree storing (key,value) entries at its internal nodes and satisfying the following “search tree” property.\n二叉搜索树是一个储存(key,value)值到节点的二叉树，并满足下面的性质：\n性质：\n\n对于任意一个内部节点 vvv，拥有左子节点 uuu 和 右子节点 www，满足 key(u) &lt;= key(v) &lt;= key(w)。\n对于任意一个节点 vvv，其左边子辈的值都比 vvv 小，右边子辈的值都比 vvv 大。\n换句话说，二叉搜索树的中序遍历(inorder traversal)返回的数组一定是根据key升序的。\n\n 二叉搜索树ADT主要操作/方法\n\nNode search(Key k)：返回key = k的节点，如果没有则返回null。\n\n实现：比较当前节点储存的key 与 k 相比较，如果等于则返回。如果k大则查找右节点，如果k小则查找左节点。如果不存在节点，则返回null。\n时间复杂度是 O(h)O(h)O(h)，其中 hhh 是树的高度。\n如果是平衡二叉树，则时间复杂度是 O(log⁡n)O(\\log n)O(logn)。\n\n\nvoid insert(Key k, Value v)：插入 (k, v) 对。\n\n实现：使用二分法找到要插入的位置，将其插入进去。\n时间复杂度是 O(h)O(h)O(h)，其中 hhh 是树的高度。\n\n\nNode remove(Key k)：删除 key = k 的节点。\n\n实现：使用二分查找找到要删除的节点删除，分为下面四个情况：\n\n没有找到该节点，此时返回 null。\n该节点是叶节点，此时删除该节点。\n节点具有一个子节点，将该子节点替换到原来的位置。\n节点具有两个子节点，此时根据树的中序遍历找到当前key的下一个key节点 www (www 称为该节点的中序后继)，并使用这个节点 www 替代该节点，再尝试删除 www，直到不符合被删除的节点具有两个子节点为止。\n\n\n时间复杂度是 O(h)O(h)O(h)，其中 hhh 是树的高度。\n\n\n\n 平衡二叉树(Balanced Trees)\n平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。\n平衡二叉树的高度 h=log⁡nh = \\log nh=logn。\n一般使用旋转(notation)的方法来让二叉搜索树逐步变成平衡二叉树。\n 一次旋转 (Single Rotation)\n一次旋转适合三个高度节点之间呈类似于 \\ 和 / 的直线形。也就是中间高度的节点是中间值的情况。\n过程如下：\n\n选择一个节点 PPP。\n选择该节点的一个子节点 CCC。\n交换两个节点：\n\n选择 CCC 中相反方向的子节点 VVV：如果 CCC 是 PPP 的左节点，那么就选择 CCC 的右节点。否则选择左节点。\n处理 PPP 的父节点：\n\n将 PPP 的父节点相应方向的子节点修改为 CCC。\n将 CCC 的父节点修改为 PPP 的父节点。\n如果 PPP 为根节点，那么修改根节点为 CCC。\n\n\n处理 CCC 的子节点 VVV：\n\n将 VVV 的父节点修改为 PPP。\n将 PPP 原来方向上的子节点 CCC 的位置修改为 VVV。\n\n\n处理 CCC 和 PPP：\n\n将 CCC 原来 VVV 位置的子节点修改为 PPP。\n将 PPP 的父节点修改为 CCC。\n\n\n\n\n\n\n整个过程时间复杂度是 O(1)O(1)O(1)。\n 二次旋转 (Double Rotation)\n诸如下图中的类似 &gt;和&lt; 形，是无法使用一次旋转的，如果只旋转a 和 c 将无法改变高度。\n此时需要先将&gt;或&lt;形旋转成/或\\形，再进行一次旋转。整个过程被称为二次旋转，如下图。\n\n具体的其他二叉树方法将（例如AVL树、红黑树）不在本笔记中展示。可能会未来在其他笔记中展示。\n \n\n 五. 💻算法\n算法的设计思路通常有这么几种：\n\n暴力搜索(Brute Force)：生成所有潜在解决方案并测试哪些是实际解决方案。时间复杂通常非常高，是属于多项式级其以上的时间复杂度。\n分而治之(Divide and Conquer)：递归地将问题分解成更小的部分并逐步解决它们，然后将它们重新组合在一起。是一种比较高效的设计思路。\n启发式(Heuristics)：是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。\n动态规划(DP)：DP是一种适用于最优解满足“分解性质”情况的通用方法。\n\n\n 排序算法(Sorting algorithms)\n排序算法的性质：\n\n排序稳定性(Stability)：如果两个元素键值相等，排序算法会保留这两个元素的相对位置。\n排序自适应性(Adaptive)：如果数组已经接近已排序，那么算法的效率会提高。\n排序接入模式(Access Patterns)\n\nSequential Access：数据的读取和写入是按照其在存储器中存放的顺序进行的。\nRandom Access：数据储存中能够在常数时间 O(1)O(1)O(1) 内直接访问任意位置的数据。\n\n\n是否需要额外空间。\n\n如果没有特殊说明，以下算法都默认从小到大排序/升序、使用 数组(array) 作为数据结构。\n 基于比较的排序算法的一些思考\n如果一个排序算法仅包含关于成对比较元素的信息，那么就称这个排序是基于比较的(comparison-based)。\n并不是所有的排序算法都是基于比较的，例如桶排序(bucket sort)是使用实际的值来进行排序的，其时间复杂度是O(n)O(n)O(n)，但是其实现依赖于其值的范围。是一种使用空间换取时间的方法。\n对于 nnn 个数的数组来说，它一共拥有 n!n!n! 种排序方法。我们使用基于比较的算法来对数组进行排序是通过两两比较来减半它排序方法的可能性。也就是说，基于比较的排序算法本质其实是逐步将 n!n!n! 减半成 111。\n这意味着我们需要去做 log⁡2(n!)\\log_2(n!)log2​(n!) 次比较。实际上 O(log⁡(n!))=O(nlog⁡n)O(\\log(n!)) = O(n \\log n)O(log(n!))=O(nlogn)。也就是说基于比较的算法不能比 O(nlog⁡n)O(n \\log n)O(nlogn) 更优。\n\n 1. 冒泡排序(Bubble sort)\n 基本思想\n让大的元素逐渐往后移动。\n\n外部循环(Outer loop)：扫描整个数组。\n内部循环(Inner loop)：对于数组每个元素与右边邻域对比，如果右边邻域更小则立即交换。\n\n 算法思考\n因为算法中最大元素像水泡一样逐渐向上冒，因此被称为冒泡排序。\n 复杂性分析\n考虑到最差的情况，也就是每次循环都会进行交换。外部循环次数为(n−1)(n - 1)(n−1)，假设当前外部循环index=iindex = iindex=i，那么内部循环次数为 (n−i−1)(n - i - 1)(n−i−1)，因此总循环次数为 n(n−1)2\\frac{n(n - 1)}{2}2n(n−1)​。\n假设比较和交换原始操作数为 ttt 为常数，循环以外的原始操作数为 kkk 为常数，那么总原始操作数为 n(n−1)2+t(n−1)+k\\frac{n(n - 1)}{2} + t(n - 1) + k2n(n−1)​+t(n−1)+k。\n根据删除规则，我们可以知道它的时间复杂度是 O(n2)O(n^2)O(n2)。\n此外，也可以使用递归关系来证明冒泡排序的时间复杂度：\n\n使用递归关系证明冒泡排序的时间复杂度\n首先冒泡排序并不是天然递归的，而是一个双重循环。\n但是我们能使用递归思想来将冒泡排序改成递归：如果要将长度为 nnn 的数组进行排序，首先将这个数组中的最大数值通过冒泡操作交换到当前数组最右边的位置并固定，随后再将剩下 n−1n - 1n−1 的数组进行排序(递归)。\n这样就写出其运行时间的递推公式：\nT(n)=dn+T(n−1)T(1)=1\\begin{aligned} \nT(n) &amp; = dn + T(n - 1) \\\\\nT(1) &amp; = 1\n\\end{aligned}\nT(n)T(1)​=dn+T(n−1)=1​\n\ndndndn 表示通过冒泡操作交换所需要的时间。\nT(n−1)T(n - 1)T(n−1) 表示剩余数组排序所需要的时间。\n\n我们可以根据等差数列求出 T(n)T(n)T(n) 的通项公式为：\nT(n)=1+(n(n+1)2−1)dT(n) = 1 + (\\frac{n(n+1)}{2} - 1) d\nT(n)=1+(2n(n+1)​−1)d\n那么很明显 T(n)T(n)T(n) 是 Θ(n2)\\Theta(n^2)Θ(n2)。\n\n\n 算法的性质。\n\n如果相同的元素不进行交换，那么该算法 具有 稳定性。\n可以通过添加变量来让算法 具有 自适应性（内部循环没有进行任何交换）。\n不需要额外的空间。\n可适用于单向链表的swapElement(Node, Node)，时间复杂度不变。\n\n\n 2. 选择排序(Selection sort)\n 基本思想\n保持数组后面的元素不变作为已排序的元素，前面的元素作为未排序的元素，选择未排序的元素组中最大的元素插入到已排序元素组的头部。\n\n外部循环：扫描整个数组。\n内部循环：扫描整个未排序部分的数组。并不会让最大的元素立即交换，而是记录住最大元素的位置。等内部循环扫描完，将被记录的元素：\n\n插入到已排序部分的数组的最左边。或者：\n与未排序部分的数组最右边的元素交换并将其加入到已排序部分数组。\n\n\n\n 算法思考\n与冒泡排序不同，冒泡排序是比较当前元素和其邻域，而该排序是比较当前元素和被记录的元素。\n为什么要延迟交换而不是立即交换：\n\n如果交换操作可能会比较昂贵，并不像数组一样是O(1)O(1)O(1)，那么就需要尽可能减少交换次数。\n如果数组非常大，那么需要尽可能地减少交换次数来提高效率。\n\n 复杂度分析\n相比于冒泡排序，它们具有相同数量的迭代和比较，仅仅是有更少数量的交换。\n因此它的时间复杂度也是O(n2)O(n^2)O(n2)。\n 算法的性质。\n\n该算法 不具有 稳定性。\n该算法 不具有 自适应性。\n不需要额外的空间。\n可适用于单向链表的swapElement(Node, Node)，时间复杂度不变。\n\n\n 3. 插入排序(Insertion sort)\n保持数组前面元素的排序不变作为已经排序的元素，后面的元素作为未排序的元素。选择当前未排序元素不断交换左边比该元素大的元素，并将其加入到已经排序的元素。\n\n外部循环：扫描整个数组。\n内部循环：获取并记录当前未排序元素的最左边元素，从右到左扫描已经排序的元素，如果被扫描的元素比记录的元素大，那么就交换，直到被扫描的元素比记录的元素小。\n\n 复杂度分析\n\n在最坏的情况下，它的外部原始操作数是 O(n)O(n)O(n)，内部原始操作数是 O(n)O(n)O(n)，因此它的总时间复杂度是O(n∗n)=O(n2)O(n * n) = O(n^2)O(n∗n)=O(n2)。\n在最佳的情况下，它内部循环操作数是 O(1)O(1)O(1)，那么它的总时间复杂程度是 O(n∗1)=O(n)O(n * 1) = O(n)O(n∗1)=O(n)。\n\n 算法的性质\n\n如果相同的元素不进行交换，那么该算法 具有 稳定性。\n该算法 具有 自适应性。\n不需要额外的空间。\n不适用于单向链表。适用于双向链表。\n\n\n 4. 归并排序(Merge sort)\n归并排序是一个基于分而治之(divide-and-conquer)的算法，它是先划分再排序。\n\n分解 (Divide)：将待排序的数组 SSS 分解为两个部分 S1S_1S1​, S2S_2S2​。\n\n分解直到只剩下单个元素或者空元素为止。因为单个元素的数组一定是已经排序好的数组。\n分解只是简单的数学运算，因此时间复杂度是 O(1)O(1)O(1)。\n\n\n递归 (Recur)：递归地将 S1S_1S1​ 和 S2S_2S2​ 进行排序(带入到分而治之中)。\n\n递归分解，回归组合。\n递归全部子集的时间复杂度是 O(log⁡(n))O(\\log(n))O(log(n))。\n\n\n组合 (Conquer)：将已排序的 S1S_1S1​ 和 S2S_2S2​ 合并(merge)。\n\nmerge是基于两个已经排序好的数组进行的：依次判断两个数组当前第一个数(最小的数)，选择最小的一个放入到新的数组后面，直到有一个数组为空后，将另一个数组剩余的元素依次放入到新的数组后面。\n假设放入的操作时间复杂度是O(1)O(1)O(1)，那么合并的时间复杂度是 O(n)O(n)O(n)。\n\n\n\n归并排序递归调用的过程是一个二叉树结构。\n\n 复杂度分析\n综上所述，归并排序的时间复杂度是 O(nlog⁡n)O(n\\log{n})O(nlogn)。\n此外可以使用递归关系来证明归并排序的时间复杂度，详细请见 三.Master定理 中 递归关系 中的样例。\n归并排序需要用到额外的空间，因此其空间复杂度是 O(n)O(n)O(n)。\n也可以使得空间复杂度是 O(1)O(1)O(1)，但是过于混乱一般不作考虑。\n 算法的性质\n\n在归并遇见相等数据时，如果优先选择左边数组那么该算法 具有 稳定性。\n该算法 不具有 自适应性。\n该算法 需要 额外的空间。\n该算法对数据的访问是顺序的(sequential)，因此在硬盘中具有较好的排序效率。\n因为依赖于快速对中间的数据进行访问，因此不太适合使用链表。\n\n\n 5. 快速排序(Quick Sort)\n快排是一个基于分而治之的算法，它是先排序后划分。\n\n分解 (Divide)：称之为partition操作。选择一个元素 xxx 称之为枢(pivot)，并将数组 SSS 分为：\n\nLLL：元素小于 xxx 的。\nGEGEGE 元素大于等于 xxx 的。\npivot经常是使用随机选择。\n假设 交换 或者 删除再插入 的时间复杂度是O(1)O(1)O(1)，那么分解的时间复杂度是 O(n)O(n)O(n)。\n\n\n递归 (Recur)：对 LLL 和 GEGEGE 使用进行递归排序，带入到分而治之中。\n\n最差的情况下，选择的枢总是最小/最大值，那么此时递归所有的子集时间复杂度是 O(n)O(n)O(n)。\n最佳的情况下，选择的枢总是中间值，那么此时递归所有的子集时间复杂度是 O(log⁡n)O(\\log n)O(logn)。\n\n\n组合 (Conquer)：将 LLL 和 GEGEGE 左右连接起来。\n\n组合只是简单的连接，时间复杂度是 O(1)O(1)O(1)。\n\n\n\n快速排序递归调用的过程是一个二叉树结构。\n 快速算法的分解(Divide)实现形式\n该操作称为partition操作。\n\n\n使用额外的空间进行分解，具体思想如下：\n\n创建两个数组，分别表示 LLL 和 GEGEGE。\n选择一个枢(pivot)。\n从左到右遍历数组，将小于枢的数加入到 LLL，将大于等于枢的数加入到 GEGEGE。\n\n\n\n使用双指针的方法进行分解，这个方法是就地(in-place)，步骤如下：\n\n选择一个枢(pivot)。\n定义两个指针 jjj 和 kkk，分别初始化指向数组的开头和结尾。\n使用 jjj 向右扫描，直到找到第一个 ≥\\geq≥ 枢的元素 或者 j==kj == kj==k 停止。\n使用 kkk 向左扫描，直到找到第一个 &lt;&lt;&lt; 枢的元素 或者 j==kj == kj==k 停止。\n交换 j,kj, kj,k 的元素。\n如果 j&lt;kj &lt; kj&lt;k，则返回 333。\n此时 j==kj == kj==k，并且此时 j,kj, kj,k 的位置元素等于枢，也是 GEGEGE 位置的左边界线。\n\n\n\n 算法的思考\n如果选择枢的方式是固定而不是随机的(例如总是选择第一个值作为枢)，并且出现了 LLL 子集是空的情况(此时选择的枢是最小值)，那么此时会导致算法出现死循环。因为每次对 GEGEGE 子集进行排序时，总是会选择最左边的值(也是最小值)作为枢，从而导致 LLL 子集是空的情况。\n\n\n\n\n\n\n\n\n\n快速排序要避免固定选择枢和出现一方子集是空集的情况，否则可能会导致死循环。\n\n解决方法1：使用随机的方式选择枢。\n解决方法2：将排序分为三个部分，分别是 LLL, {pivot}\\{pivot\\}{pivot}, E+GE+GE+G。\n解决方法3：三点取值，选择最左边的数、中间的数和最右边的数中的中位数作为枢。\n\n 复杂度分析\n\n最差的情况下，快速排序的时间复杂度是 O(n2)O(n^2)O(n2)。\n最佳的情况下，快速排序的时间复杂度是 O(nlog⁡n)O(n\\log{n})O(nlogn)。\n平均情况下，在一半的时间中快速排序选择的枢是中间值，那么时间复杂度是 O(nlog⁡n)O(n\\log{n})O(nlogn)。\n\n也可以认为平均情况下，选择的枢值总是让两个子集分解成 13\\frac{1}{3}31​ 和 23\\frac{2}{3}32​ 两个区域，也就是说递归二叉树的高度是 32log⁡n\\frac{3}{2}\\log n23​logn。\n具体证明可以自行查看维基百科。\n\n\n\n快速排序不需要用到额外的空间，因此其空间复杂度是 O(1)O(1)O(1)。\n 算法的性质\n\n快速排序 不具有 稳定性。\n该算法 不具有 自适应性。\n该算法 不需要 额外的空间，是就地(in-place)的算法。\n该算法对数据的访问是随机的(randomized)。\n因为是使用 交换 或者 删除再插入 操作进行，因此可以使用双向链表。\n\n\n 启发式算法(Heuristics)\n启发式算法是一个使用经验法则(rule of thumb)设计的算法。启发式算法比简单的方法能够做出更好的决策，但仍然不一定是最佳的。\n通常有两种：\n\n程序中的决策可以给出准确/最佳的答案，但通常是为了加快程序运行速度。\n\n例如，A*搜索算法中使用可接受的启发式方法(Admissible heuristic)、在快速排序算法中使用随机选择的方式选择枢(pivot)。\n\n\n程序中的决策可能不会给出最佳答案，但旨在给出以其他方式无法获得的良好答案。\n\n一般用于解决一些NP-hard问题，例如 TSP问题、图染色问题等。\n例如 遗传算法、模拟退火。\n具体可以参考AIM-优化算法笔记。\n\n\n\n 贪心算法(Greedy)\n贪心算法是一种常见的启发式算法。贪心算法是做出短期内看起来最好的决定，而不考虑未来的策略。\n一些贪心算法可以得到最优解，例如最小生成树(Minimal Spanning Tree, MST)中Prim算法。\n大部分贪心算法无法给出最优解，但是可以给出接近最优的解。\n 最小生成树问题(Minimal Spanning Tre, MST)\n问题输入：联通的、有边权值的无向图(connected, undirected, weighted graph)。\n问题输出：一棵树，仅使用图中存在的边连接图中所有顶点，并且边权重的和是最小的。\n Prim算法\n思路：\n\n选择任意顶点 MMM。\n选择对外可以连接到的所有的点中最小的那个边，并将边加入到 MST中，将点加入到内部的点中。\n是否全部连接，如果没有则返回 222。通过已连接的边个数判断，即 边的个数 e=n−1e = n - 1e=n−1。\n\n算法实现：\n\n1.1.1. 初始化数组 value[n] = inf，数组大小为点的个数，表示表示内部点对未连接的点边权的最小值；初始化连接边的个数m = 0。\n2.2.2. 随机选择一个点 MMM。\n3.3.3. 使value[M] = 0，并根据 MMM 连接的所有边 (M,V)(M, V)(M,V) 更新 edge 数组。即\n\n12345value[M] = 0              # 因为已经被连接，所以更新为0forall e in edge(M)  v = e.v                 # 获取边连接的另一个点  if(e.value &lt; value[v])  # 根据边权值更新对外连接点的大小    value[v] = e.value \n\n4.4.4. 找到 value[v] != 0 中最小的点 VVV，使 value[V] = 0，m++。\n5.5.5. 跟 333 一样根据 VVV 连接的所有边 (V,U)(V, U)(V,U) 更新 edge 数组。\n6.6.6. 判断是否所有的点已经连通，即 (m - 1) == n，如果没有则返回 444。\n\n\n 动态规划(Dynamic Programming, DP)\n\n\n\n\n\n\n\n\n\nDP is a general method that can be suitable when the optimal solutions satisfy a “decomposition property”.\nDP 是一种适用于最优解满足“分解性质”情况的通用方法。\nDP的步骤通常如下：\n\n将最优解分解为子解相当于将问题分解为子问题，并且子解对于子问题是最优的。\n因此，最优解可以通过更小的子问题的最优解来构建。\n\n与分治法不同的是，DP中的子问题可以重叠，即不同的路径可能会遇见相同的子问题。\n因此DP的思想通常是，对于某一个解 SnS_nSn​，如果我想要得到这个解，我该直到哪些解才能得出这个解，并依次获取和尝试合并这些可能解的组合。又或者说，我现在已知某一个解，我是否可以让这个解和其他输入/解组合获取一个新的解。其中这个“得到”和“获取”的过程是一个状态转移的过程，这个过程是一个状态转移方程/贝尔曼方程(Bellman Equation)。\n\n例如，假设有这样一个问题：给出一个整型集合 SSS，和一个目标值 KKK，我是否可以找出一个 SsubS_{sub}Ssub​ 的子集，其元素的和等于 KKK。\n\n假设我们输入 S[i],0≤i≤(n−1)S[i], 0 \\leq i \\leq (n-1)S[i],0≤i≤(n−1) 是集合第 iii 个元素。\n我们使用 dp[i][m]=true,0≤m≤Kdp[i][m] = true, 0 \\leq m \\leq Kdp[i][m]=true,0≤m≤K 来表示使用前 iii 个元素组成的子集中 SsubS_{sub}Ssub​ 元素和可以等于 mmm。\n如果我们知道 dp[i−1][m]=truedp[i - 1][m] = truedp[i−1][m]=true，那么可以根据它和当前元素 S[i]S[i]S[i] 得出 dp[i][m+S[i]]=truedp[i][m + S[i]] = truedp[i][m+S[i]]=true。\n如何知道dp[i−1][m]=truedp[i - 1][m] = truedp[i−1][m]=true? 只需要对 mmm 进行遍历 (0≤m≤K−S[i])(0 \\leq m \\leq K-S[i])(0≤m≤K−S[i]) 依次检查是否为true即可。\n由此我们就可以得到状态转移方程：dp[i][m]=dp[i][m]  |  dp[i−1][m−S[i]]dp[i][m] = dp[i][m]\\ \\text{ | } \\ dp[i - 1][m - S[i]]dp[i][m]=dp[i][m]  |  dp[i−1][m−S[i]]。\n时间复杂度是 O(kn)O(kn)O(kn)。\n此外我们可以使用滚动数组将其变成一维dp，此时对容量 mmm 的遍历是倒着的（如果正着就会导致元素 iii 被重复计算，此时属于完全背包问题）。\n\n\n\n与暴力搜索，暴力搜索是将所有可能的答案依次列出来并测试，答案之间可能没有太大的关系。而动态规划是根据状态转移来尝试获取哪些解。\n\n 最短路算法(Shortest Path)\n最短路算法分为单源最短路和多源最短路。\n解决单源最短路的一种方法是 Dijkstra 算法，其时间复杂度是 O(nlog⁡n+m)O(n\\log n + m)O(nlogn+m)。如果将其应用在多源最短路的话，那么其时间复杂度是 O(n(nlog⁡n+m))O(n(n\\log n + m))O(n(nlogn+m))。\n此外，有一个特定的算法用来解决多源最短路，就是Floyd-Warshall (FW)算法，该算法的时间复杂度是 O(n3)O(n^3)O(n3)。\n Floyd-Warshall (FW)\nFW算法是一个动态规划的算法，通过逐步加入点来构造子答案从而获取整体最优解的方法。\n适用于负数边、有向边的情况。\n\n\n定义：\n\n\n定义 d(i,j,k)d(i,j,k)d(i,j,k)：表示点在 i,ji,ji,j 之间使用 {1,...,k}\\{1,...,k\\}{1,...,k} 作为允许使用的潜在中间点的最短路。\n\n例如 d(2,5,3)d(2,5,3)d(2,5,3)：在仅使用 {1,2,3}\\{1,2,3\\}{1,2,3} 其中的点作为中间点（这些点可以使用也可以不使用，但不能使用其他的点）时点 222 到点 555 的最短路。\n\n\n\n定义 w(i,j)w(i, j)w(i,j)：表示两个点之间的距离。\n\n如果不连通则等于 ∞\\infty∞，即 w(i, j) = inf。\n自边等于 000，即 w(i, i) = 0。\n\n\n\n\n\n初始化：对于所有的两个点之间：d(i,j,0)=w(i,j)d(i, j, 0) = w(i, j)d(i,j,0)=w(i,j)。\n\n\n状态转移方程：考虑当 k = k + 1时，即对于每两对点之间在前 k 个点已经加入好，那么有：\n\n\nd(i,j,k+1)=min⁡(d(i,j,k),d(i,k+1,k)+d(k+1,j,k))d(i, j, k+1) = \\min (d(i, j, k), d(i, k+1, k) + d(k+1, j, k))\nd(i,j,k+1)=min(d(i,j,k),d(i,k+1,k)+d(k+1,j,k))\n\n 📘Reference\n\n“Big O Notation.” Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org/wiki/Big_O_notation. Accessed 19 May 2024.\n“Recurrence Relation.” Wikipedia, The Free Encyclopedia, 8 April 2024, en.wikipedia.org/wiki/Recurrence_relation. Accessed 20 May 2024.\n“Master Theorem (Analysis of Algorithms).” Wikipedia, The Free Encyclopedia, 10 May 2024, en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms). Accessed 22 May 2024.\n“Quicksort.” Wikipedia, The Free Encyclopedia, 12 May 2024, en.wikipedia.org/wiki/Quicksort. Accessed 21 May 2024.\n\n\n\n\n源自: https://en.wikipedia.org/wiki/Big_O_notation ↩︎ ↩︎\n\n\n\n","slug":"笔记/笔记-ADE-算法数据结构和效率","date":"2024-05-24T17:42:20.000Z","categories_index":"笔记","tags_index":"Notes,Algorithm,Data Structure,Big-Oh","author_index":"zExNocs"},{"id":"d681443dee58dcfb94dec12db90a9a0d","title":"随笔日记导航","content":" 随笔\n 娱乐类随笔\n\n梗图\n记录网友怪话\n\n 技术类随笔\n\n让Hexo支持KaTeX和emoji\n\n\n 日记\n","slug":"导航/导航-随笔日记导航","date":"2024-05-24T17:15:32.000Z","categories_index":"导航","tags_index":"Diary,Essay","author_index":"zExNocs"},{"id":"c9fd788a84f48b02fed840451084249f","title":"笔记导航","content":" 按照年份分类\n Y3\n\nADE - 算法数据结构和效率 : 有关算法效率分析的课题笔记，包括Big-Oh家族、Master定理和部分算法与数据结构的算法分析。\nLAC - 形式语言与自动机理论 : 有关形式语言与自动机理论的笔记。\n\n","slug":"导航/导航-笔记导航","date":"2024-05-24T14:25:57.000Z","categories_index":"导航","tags_index":"Notes","author_index":"zExNocs"},{"id":"625e3e920d4d18f0b54366f772b38b35","title":"语言学习导航","content":"","slug":"导航/导航-语言学习导航","date":"2024-05-24T10:44:53.000Z","categories_index":"导航","tags_index":"Languaue","author_index":"zExNocs"},{"id":"f2a68e25ffce8d6b8f475f30117ea7f4","title":"算法和数据结构导航","content":" 算法\n 数据结构\n","slug":"导航/导航-算法和数据结构导航","date":"2024-05-24T10:43:22.000Z","categories_index":"导航","tags_index":"Algorithm,Data Structure","author_index":"zExNocs"}]