[{"id":"ed2691e46b19986acffbcbe7e26041d1","title":"随笔-让Aurora支持KaTeX和Emoji","content":" ✒️背景\n最早接触markdown是在洛谷的个人博客时使用的。其中有一个功能我特别喜欢用，就是用$$符号展示出的公式，类似于这样：f(x)=eΔkTf(x)=e^{\\frac{\\Delta}{kT}}f(x)=ekTΔ​，以至于以后只要用到有关字母公式的地方就会喜欢性地打出$$。\n但是我在使用Aurora的时候，发现它并不能直接使用$$公式，研究发现是Hexo默认的markdown渲染器不支持KaTeX，故有此文章来研究如何让Hexo支持。\n 🔖内容\nHexo的markdown渲染器有很多种：Hexo多种Markdown渲染器对比分析。\nHexo自带的markdown渲染器不支持KaTeX，也不支持emoji。而网络上常见的pandoc在部署到Aurora时会出现很多问题。这里我使用的是markdown-it-plus，它原生就支持emoji和KaTeX插件。具体步骤如下：\n\n卸载原生渲染器 npm un hexo-renderer-marked --save\n安装新渲染器 npm i hexo-renderer-markdown-it-plus --save\n添加选项：在根目录下_config.yml添加以下字段：\n\n12345678910markdown_it_plus:    highlight: true    html: true    xhtmlOut: true    breaks: true    langPrefix:    linkify: true    typographer:    quotes: “”‘’    pre_class: highlight\n\n添加css：在根目录下_config.aurora.yml找到injects字段，并添加css，参考如下：\n\n12345678#! ---------------------------------------------------------------#! Injections#! @docs https://aurora.tridiamond.tech/guide/site-meta.html#custom-meta#! ---------------------------------------------------------------injects:  scripts:  css:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css&quot;&gt;\n\n清理并重新生成Hexo hexo clean &amp; hexo g -d\n\n 📘Reference\n\nHexo多种Markdown渲染器对比分析: https://zsyyblog.com/b73ceb85.html\nhexo-renderer-markdown-it-plus官方文档：https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus\nAurora官方插件文档：https://aurora.tridiamond.tech/cn/configs/site-meta.html\n\n","slug":"随笔/随笔-让Hexo支持KaTeX和Emoji","date":"2024-05-27T13:05:16.000Z","categories_index":"随笔","tags_index":"Hexo","author_index":"zExNocs"},{"id":"dd909d4f3bf029c1efe5bae0e6ec00d1","title":"随笔-记录网友怪话","content":"←返回导航\n\n\n\n\n","slug":"随笔/随笔-记录网友怪话","date":"2024-05-25T14:52:15.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"ca919ca5c3402d033970c77af27cf3c5","title":"随笔-梗图","content":"←返回导航\n 娱乐向\n\n\n\n\n\n\n\n\n 提问向\n\n\n提问的艺术\n\n\n\n提问收费表\n\n\n\n","slug":"随笔/随笔-梗图","date":"2024-05-25T13:55:45.000Z","categories_index":"随笔","tags_index":"Essay","author_index":"zExNocs"},{"id":"49266c0927eaad653ea21227e55d59fb","title":"LAC - Formal Languages and Automata Theory 形式语言与自动机理论","content":" 背景\n课程原名为Languages and Computation(语言与计算)，但是这很明显是一个比较笼统的名字。本课程的主要内容还是将有关形式语言与自动机理论的知识。\n关于自动机，早在学习算法竞赛的时候有学过AC自动机(Aho-Corasick automaton, 是字典树 + KMP算法 + 自动机的结合)的知识，但是并没有建立有关自动机的系统性概念。\n此外，在学习做游戏AI的时候，有接触过关于状态设计模式的概念，游戏AI是一个巨大的状态自动机，因此我也利用这个方法在我CPP课程的游戏里设计了敌人的AI，具体可以参考这个笔记: 简单游戏引擎开发笔记。\n 介绍\n本笔记主要分为下面几个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n","slug":"笔记/笔记-LAC-形式语言与自动机","date":"2024-05-25T10:53:20.000Z","categories_index":"笔记","tags_index":"Notes,Automata Theory,Formal Languages,Theory","author_index":"zExNocs"},{"id":"ca7a89ba385cdbc1ce7b55d4c88122bd","title":"AIM - Optimization 优化算法","content":" 背景\n课程原名为Artificial Intelligence Methods(人工智能方法)，但实际上内容都是有关一些优化算法的内容，相比如今环境下主流的大模型、神经网络还是相差甚远。因为部分优化算法中也具备一些学习能力（比如说遗传算法），因此也可以被视为一种弱人工智能。\n 介绍\n本笔记主要分为下面几个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n","slug":"笔记/笔记-AIM-优化算法","date":"2024-05-25T10:52:11.000Z","categories_index":"笔记","tags_index":"Algorithm,AI,Optimization","author_index":"zExNocs"},{"id":"8e94a57200662cea86ae71df183554b9","title":"ADE - Algorithms Data Structures and Efficiency 算法数据结构和效率","content":" ✒️背景\n早在一年前就知道了这个有关算法和数据结构的课程。作为一个退役OIer，之前有接触过关于这个课程的内容，比如堆、图论等，因此是对这个课程具有很大兴趣的。\n不过这个课程并不是集中于讲解算法和数据结构，而是着重于使用理论对算法效率的分析，比如Big-Oh表示法。学算法竞赛的时候只是经常听说过和使用过时间复杂度、空间复杂度，不过一直以来对它们的理解都停留在算法在时间和空间上对某一或多种变量/输入的增长程度上，可以说是对这一类知识处于一种一知半解的状态。\n建议使用右边的导航选择性地阅读。\n 🔖介绍\n本笔记着重于介绍使用理论知识分析算法和数据结构的效率，此外还会介绍一些算法和数据结构的抽象功能，以及对这些功能实现的效率分析。\n本笔记主要分为下面四个部分(并不是按照课程顺序排序，而是相似课程归纳)：\n\n一. 算法效率的评估\n二. Big-Oh表示法和其家族\n三. Master定理\n四. 数据结构\n五. 算法\n\n 一. 🔬算法效率的评估\n如何评估一个算法的效率？最直接的方式就是在程序输入后何时才能获得输出值。其中一种比较直观的方式是根据 程序的运行时间 来评估测量算法效率。\n在同一个程序中，程序的运行时间往往会随着输入大小(input size)而增加。即使固定输入大小，实际运行时间通常也会有所不同，这取决于输入的详细信息。例如在最短路算法中，即使是相同数量的点和边，不同的连接方法也会导致运行时间不同 (关于SPFA，它死了) 。\n由于你的时间非常值钱，因此我们需要一些方法来对算法的效率进行客观地评估，这些方法主要可以分类为两种：实验统计和理论分析。\n\n 方法一：Experiment 实验统计\n\n\n\n\n\n\n\n\n\n\n实验统计是使用观察和控制变量的方法来对一种现象进行系统的测试和验证。\n具体步骤如下:\n\n写一个程序实施该算法\n使用不同的输入大小和输入信息运行程序\n记录实际运行时间\n绘制并使用统计学分析（如回归分析）\n\n在固定输入大小、不同输入信息中，统计中获得最佳运行时间、最差运行时间、平均运行时间，我们通常会关注最差的情况，主要原因是平均时间往往很难以去分析 (例如为什么在判断一个公司工资待遇往往不是使用平均值，更多的是最低工资)。\n 缺点 &amp; 局限性\n\n必须用程序实现该算法，可能会很耗时。\n需要提供大量输入集或者选择合适的输入集来找到最差的情况，不然会导致结果的偏差。\n效率的评估受到硬件/软件/语言环境的影响。\n\n\n 方法二：Theory 理论分析\n\n\n\n\n\n\n\n\n\n理论分析是基于已有的知识和数据，运用逻辑和数学的方法来对一种现象进行解释和预测。\n跟实验统计一样，我通常指关注最差的情况。\n 特点\n\n具有一定的抽象性。\n能够独立于硬件/软件/语言环境来评估算法的效率。\n能够考虑所有可能的输入。\n\n 缺点 &amp; 局限性\n\n实施过程可能会比较困难，需要一定的知识基础。\n在现实实施的时候可能有一些特殊情况导致与理论结果相差较大，使用理论解释这种情况可能会比较困难。\n\n 评估标准\n在实验统计中，我们往往使用 程序的运行时间 来作为评估的标准，但是在理论知识中我们无法使用这个来作为评估标准。因为程序的运行时间往往受到环境的影响，因此理论难以测量出运行时间，所以我们使用另一种方法来作为理论分析中使用的评估标准：原始运算数量。\n 原始运算的定义\n\n\n\n\n\n\n\n\n\n原始运算(primitive operations)是算法执行的基本运算。\n在真实的计算机中，实际的运算应该是逻辑门的操作，但是很明显这个是很琐碎的，与算法的运算相差太远。因此我们需要去定义哪些运算属于原始运算以便于记数。一般来说，我们会将汇编代码、算数运算视作一个原始运算。\n注意，原始运算的定义不是固定的，下面有更具体的说明。在这个笔记中，我们将这些操作视作一个原始运算：\n\n\n\n描述\n伪代码样例\n\n\n\n\n变量赋值\na ← 0\n\n\n数组索引\na[10]\n\n\n变量比较\na == 10\n\n\n算数运算\na + 1\n\n\n函数调用\nfunction()\n\n\n函数返回\nreturn 0\n\n\n\n注意：\n\n在本笔记中我们忽视了汇编中有关jump的指令，即本笔记中默认jump指令原始运算为0。\n数组索引需要用到袁术运算是因为它需要在内存中进行索引。\n函数调用属于原始运算是因为它需要在内存中进行索引。\n在CPU中，浮点运算(如除法)实际上是一个非常复杂的算法。但在汇编语言中，它只是一个指令，因此我们也将其视作一个原始运算。\n\n对于其他的运算，都可以拆分为这些原始运算：\n\n\n\n描述\n分析\n操作数\n伪代码样例\n\n\n\n\nfor循环，循环次数为nnn\n要经历1次初始赋值；n次判断；n次叠加，每次叠加是两个原始运算(加法和赋值)\n1+n+2n=3n+11+n+2n = 3n+11+n+2n=3n+1\nfor i ← 1 to n do\n\n\nfor循环，循环次数为(n−1)(n-1)(n−1)\n要经历1次初始赋值；(n-1)次判断，每次判断是两个原始运算(减法和比较)；(n-1)次叠加，每次叠加是两个原始运算(加法和赋值)\n1+2(n−1)+2(n−1)=4n−31+2(n-1)+2(n-1) = 4n-31+2(n−1)+2(n−1)=4n−3\nfor i ← 1 to (n-1) do\n\n\nwhile循环，循环次数为nnn\n每次循环只需要判断即可\nnnn\nwhile i &gt; n\n\n\nwhile循环，循环次数为(n−1)(n-1)(n−1)\n每次循环都需要进行判断和减法\n2(n−1)2(n-1)2(n−1)\nwhile i &gt; (n-1)\n\n\nif then判断，then内部原始运算数为kkk\n一个判断。由于我们是统计最差次数，因此我们需要将if里原始运算进行累加(默认触发)\n1+k1 + k1+k\nif ... then ...\n\n\n\n\n一个计算原始运算数的例子: arrayMax(A, n)\n一个返回数组最大值arrayMax(A, n)的伪代码：\n123456Algorithm arrayMax(A, n)    # A为数组，n为数组大小，即数组从0开始，(n-1)结束。  currentMax ← A[0]         # 原始运算数为2，分别是数组索引和赋值  for i ← 1 to (n - 1) do   # (n-1)次数的循环运算，原始运算数为(4n-3)    if A[i] &gt; currentMax    # 每次循环原始运算数为2，分别是数组索引和判断，共(n-1)次循环，原始运算数为2(n-1)      currentMax ← A[i]     # then内部运算。每次循环原始运算数为2，分别是数组索引和赋值，原始运算数为2(n-1)  return currentMax         # 原始运算为1，函数返回\n综上所述，这个算法的原始运算总数为 2+(4n−3)+2(n−1)+2(n−1)+1=8n−42 + (4n - 3) + 2(n - 1) + 2(n - 1) + 1 = 8n - 42+(4n−3)+2(n−1)+2(n−1)+1=8n−4\n\n\n原始运算的个数并不是固定的，例如在计算操作 c←A[i]c \\leftarrow A[i]c←A[i] 中，你也可以认为是444个原始运算：\n\n获取AAA数组的指针储存在寄存器中。\n获取iii储存在寄存器中。\n计算A+iA + iA+i作为A[i]A[i]A[i]的指针储存在寄存器中。\n复制变量ccc的数值写在A+iA + iA+i指针的内存中。\n\n当然在这个笔记中，你也可以认为只有222个原始运算：\n\n根据iii索引获取A[i]A[i]A[i]数组位置 (数组索引)。\n将变量ccc的数值赋值给A[i]A[i]A[i] (变量赋值)。\n\n但是无论是444还是222，这个操作永远不可能会是2n2n2n，即它的增长率永远不可能会超过常数级(增长率的定义在下面)。\n\n\n\n\n\n\n\n\n\n原始运算的个数只与算法的效率有关，与正确性无关。\n 使用原始运算估算运行时间\n增长率(Growth Rate)指的是函数的因变量随着自变量的增加而增长的速率。\n\n\n\n\n\n\n\n\n\n对于算法来说，假设它的最差情况的运行时间为T(n)T(n)T(n)，那么T(n)T(n)T(n)的增长率是该算法的固有属性，是不受硬件/软件环境影响的。\n我们可以使用原始运算来估算运行时间，假设：\n\n原始运算的个数为P(n)P(n)P(n)。\n最快的原始运算所需要的时间为aaa，是一个常数。\n最慢的原始运算所需要的时间为bbb，是一个常数。\n\n可以得出：aP(n)≤T(n)≤bP(n)aP(n) \\leq T(n) \\leq bP(n)aP(n)≤T(n)≤bP(n)\n由于a和b都是常数，那么我们认为T(n)T(n)T(n)和P(n)P(n)P(n)具有相同的增长率。很明显T(n)T(n)T(n)和P(n)P(n)P(n)的导数肯定是不同的，因此增长率并不等同于导数。\n但是增长率有一种只可意会不可言传的感觉：这种增长率具体形式是什么样的？如何定义哪两个函数具有相同的增长率？那么就需要用到我们的Big-Oh表示法了。\n 二. 🏠Big-Oh表示法和其家族\n 基本知识\n我们需要一种函数分类(Classification of Functions)来通过缩放的行为将函数分组在一起，同一组的函数具有这样的相似性：\n\n删除不必要的细节。\n相对快速、简单。\n处理运行时可能会发生的“奇怪的”函数(例如分段函数)。\n在数学上拥有明确的定义。\n\n其中一种最佳的方法是使用Big-Oh表示法和其家族(Big-Oh notation and family)：\n\nOOO: Big-Oh\nΩ\\OmegaΩ: Big-Omega\nΘ\\ThetaΘ: Big-Theta\nooo: little-oh\nω\\omegaω: little-omega\n\n Big-Oh: O(n)\n 定义\n假设由两个正函数f(n)f(n)f(n)和g(n)g(n)g(n)，如果我们称 f(n) is O(g(n))f(n) \\ is \\ O(g(n))f(n) is O(g(n)) ，当且仅当\n\n\n\n\n\n\n\n\n\n∃c&gt;0,∃n0&gt;0,∀n≥n0,f(n)≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)\n∃c&gt;0,∃n0​&gt;0,∀n≥n0​,f(n)≤c g(n)\n注意:\n\n量词顺序是 ∃ ∃ ∀\\exist \\ \\exist \\ \\forall∃ ∃ ∀\nccc 和 n0n_0n0​必须是常数，不能随着nnn变化。不然这是没有意义的。\n注意符号&gt;,≥,≤&gt;,\\geq,\\leq&gt;,≥,≤的区分。相比之下是比较严格的(例如，n0n_0n0​ 不能等于 000, nnn 可以等于 n0n_0n0​)。\n\n\n此外，Big-Oh可以会被定义为：\nlim sup⁡n→∞f(n)g(n)&lt;∞\\limsup_{n\\to \\infty} \\frac{f(n)}{g(n)} &lt; \\infty \nn→∞limsup​g(n)f(n)​&lt;∞\n\n\n\n\n\n\n\n\n\nBig-Oh只规定了f(n)f(n)f(n)的增长率的上限(upper bound on the growth rate of the function)。\n 特点\n\nBig-Oh不关注算法或者是“算法最差的运行时间”，而是只关注于函数。\n一般f(n)f(n)f(n)表示运行时间，nnn表示输入的个数，所以Big-Oh中描述的函数一般为 f:N+→R+f: \\mathbb{N^+} \\to \\mathbb{R^+}f:N+→R+，g(n)g(n)g(n)也类似。\nBig-Oh只规定了f(n)f(n)f(n)的增长率的上限，也就是说，当nnn足够大时，f(n)f(n)f(n)的增长速率不大于g(n)g(n)g(n)。\nBig-Oh中g(n)g(n)g(n)的选择并不是一定要选择“最佳”或者“最有用的”函数。例如，对于f(n)=1f(n) = 1f(n)=1可以是O(1)O(1)O(1)，但也可以是O(n)O(n)O(n)。因此g(n)g(n)g(n)的增长率越小越能反应出f(x)f(x)f(x)的增长率。\n\n 性质\nBig-Oh作为一个二元关系(binary relation)，拥有以下性质：\n\nBig-Oh具有自反性(Reflexive, e.g. xRxx R xxRx)，即 f(n)f(n)f(n) 是 O(f(n))O(f(n))O(f(n))。\nBig-Oh不具有对称性(Symmetric, e.g. xRy  ⟺  yRxx R y \\iff y R xxRy⟺yRx)，例如 f(n)=1f(n) = 1f(n)=1 是 O(n)O(n)O(n)，但是 f(n)=nf(n) = nf(n)=n 不是 O(1)O(1)O(1)。\nBig-Oh具有传递性(Transitive, e.g. xRy  &amp;  yRz→xRzx R y \\ \\ \\&amp; \\ \\ y R z \\to xRzxRy  &amp;  yRz→xRz)。即如果 ∀n≥n1,f(n)≤c1g(n)\\forall n \\geq n_1, f(n) \\leq c_1g(n)∀n≥n1​,f(n)≤c1​g(n)，且∀n≥n2,g(n)≤c2h(n)\\forall n \\geq n_2, g(n) \\leq c_2h(n)∀n≥n2​,g(n)≤c2​h(n)，那么总有 ∀n≥n3,f(n)≤c1c2h(n),n3=max⁡(n1,n2)\\forall n \\geq n_3, f(n) \\leq c_1c_2h(n), n_3=\\max(n_1,n_2)∀n≥n3​,f(n)≤c1​c2​h(n),n3​=max(n1​,n2​)。\n\n综上所述，Big-Oh具有自反性和传递性，因此Big-Oh更像是⊂,∈,≤\\subset, \\in, \\leq⊂,∈,≤,而不是===，因此有一种表示方法是将Big-Oh视作集合，使用n∈O(n)n \\in O(n)n∈O(n)。\n此外，也有一种说法是使用f(n)=O(n)f(n) = O(n)f(n)=O(n)，其中等于号是一种单向的等于。但是本笔记中更偏向于使用“是”或者“is”来表示。\n 推论\n\n推论1：存在三个函数f(n)f(n)f(n), g(n)g(n)g(n), p(n)p(n)p(n)和正数k,b∈N+k, b\\in \\mathbb{N^+}k,b∈N+，如果f(n)f(n)f(n)是O(g(n))O(g(n))O(g(n))，且f(n)=k p(n)+bf(n)=k\\ p(n) + bf(n)=k p(n)+b，那么有p(n)p(n)p(n)是O(g(n))O(g(n))O(g(n))\n\n\n证明推论1\n假设有c0&gt;0,n0&gt;0c_0 &gt; 0, n_0 &gt; 0c0​&gt;0,n0​&gt;0，对于n1≥n0n_1 \\geq n_0n1​≥n0​，有：\nf(n1)≤c0 g(n1)f(n_1) \\leq c_0 \\ g(n_1)f(n1​)≤c0​ g(n1​)，那么有：\nk p(n1)+b≤c0 g(n1)k\\ p(n_1) + b \\leq c_0 \\ g(n_1)k p(n1​)+b≤c0​ g(n1​)，整理得：\np(n1)≤c0kg(n1)−bkp(n_1) \\leq \\frac{c_0}{k}g(n_1) - \\frac{b}{k}p(n1​)≤kc0​​g(n1​)−kb​\n当n足够大时候，假设此时n1≥n2n_1 \\geq n_2n1​≥n2​，有 cg(n1)≥2bcg(n_1) \\geq 2bcg(n1​)≥2b\n从而有 p(n1)≤c02kg(n1)p(n_1) \\leq \\frac{c_0}{2k}g(n_1)p(n1​)≤2kc0​​g(n1​)\n设 c1=c2k&gt;0c_1=\\frac{c}{2k}&gt;0c1​=2kc​&gt;0，我们得到：\np(n1)≤c1 g(n1)p(n_1) \\leq c_1\\ g(n_1)p(n1​)≤c1​ g(n1​)，即\n存在 c1c_1c1​，n2n_2n2​使得 ∀n&gt;n2,p(n)≤c1 g(n)\\forall n &gt; n_2, p(n) \\leq c_1\\ g(n)∀n&gt;n2​,p(n)≤c1​ g(n)\n因此p(n)p(n)p(n)是O(g(n))O(g(n))O(g(n))。\n\n\n 例子\n\n证明arrayMax(A, n)是 O(n)O(n)O(n) 的例子\n由上述计算原始运算数的例子可知，arrayMax(A, n)的原始运算记数为 f(n)=8n−4f(n) = 8n - 4f(n)=8n−4\n设g(n)=ng(n) = ng(n)=n，因此需要求证 ∃c&gt;0,∃n0&gt;0,∀n≥n0,f(n)≤c g(n)\\exist c &gt; 0, \\exist n_0 &gt; 0, \\forall n \\geq n_0, f(n) \\leq c \\ g(n)∃c&gt;0,∃n0​&gt;0,∀n≥n0​,f(n)≤c g(n)，整理可得：\n{n≤4c−8c&gt;8n≥4c−8c&lt;8−4≤0c=8\\begin{cases}\nn \\leq \\frac{4}{c - 8} &amp; c &gt; 8 \\\\\nn \\geq \\frac{4}{c - 8} &amp; c &lt; 8 \\\\\n-4 \\leq 0 &amp; c = 8\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​n≤c−84​n≥c−84​−4≤0​c&gt;8c&lt;8c=8​\n由于我们规定是 ∀n≥n0\\forall n \\geq n_0∀n≥n0​，因此我们只能取 n≥8n \\geq 8n≥8。\n当我们取 n=8n = 8n=8时，很明显任意n0&gt;0n_0 &gt; 0n0​&gt;0都可以证明成立。此时我们可以取 n0=1n_0 = 1n0​=1。\n当我们取 n&gt;8n &gt; 8n&gt;8时，很明显任意n0&gt;4c−8n_0 &gt; \\frac{4}{c - 8}n0​&gt;c−84​都可以证明成立。此时我们可以取 n0=4c−8n_0 = \\frac{4}{c - 8}n0​=c−84​。\n实际上，上述情况只需要求出一组(c,n0)(c,n_0)(c,n0​)即可，因此我们可以直接取c=8,n0=1c = 8, n_0 = 1c=8,n0​=1。不过这里给出了一种选取(c,n0)(c,n_0)(c,n0​)的具体方法。\n因此arrayMax(A, n)的时间复杂度是 O(n)O(n)O(n)。\n\n\n\n对于分段函数Big-Oh的证明\n如何计算下面函数的Big-Oh:\nf(n)={nif n is even1if n is oddf(n) = \n\\begin{cases}\nn &amp; \\text{if } n \\text{ is even} \\\\\n1 &amp; \\text{if } n \\text{ is odd}\n\\end{cases}\nf(n)={n1​if n is evenif n is odd​\n因为Big-Oh是规定的函数增长率的上限，因此我们应该取增长率最大的函数，即f(n)=nf(n) = nf(n)=n，此时当c=1,n0=1c = 1, n_0 = 1c=1,n0​=1可以证明出f(n)f(n)f(n)是O(n)O(n)O(n)，而无法证明出f(n)f(n)f(n)是O(1)O(1)O(1)。\n\n\n 常用表示表[1]\n\n\n\n表示\n中文名\n英文名\n数量级\n\n\n\n\nO(1)O(1)O(1)\n常数级\nconstant\n∞\\infty∞\n\n\nO(log⁡log⁡n)O(\\log{\\log{n}})O(loglogn)\n双对数级\ndouble logarithmic\n221062^{2^{10^6}}22106\n\n\nO(log⁡n)O(\\log{n})O(logn)\n对数级\nlogarithmic\n1030103010^{301030}10301030\n\n\nO((log⁡n)c),c&gt;1O((\\log{n})^c), c &gt; 1O((logn)c),c&gt;1\n多重对数级\npolylogarithmic\n2106c2^{10^{\\frac{6}{c}}}210c6​\n\n\nO(nc),0&lt;c&lt;1O(n^c), 0 &lt; c &lt; 1O(nc),0&lt;c&lt;1\n分数幂级\nfractional power\n106c10^{\\frac{6}{c}}10c6​\n\n\nO(n)O(n)O(n)\n线性级\nlinear\n10610^6106\n\n\nO(nlog⁡n)=O(log⁡n!)O(n\\log{n}) = O(\\log{n!})O(nlogn)=O(logn!)\n对数线性/拟线性级\nloglinear, quasilinear\n10510^5105\n\n\nO(n2)O(n^2)O(n2)\n二次级\nquadratic\n10310^3103\n\n\nO(nc)O(n^c)O(nc)\n多项式/代数级\npolynomial, algebraic\nnc\\sqrt[c]{n}cn​\n\n\nO(cn)O(c^n)O(cn)\n指数级\nexponential\n6log⁡c106\\log_{c}{10}6logc​10\n\n\nO(n!)O(n!)O(n!)\n阶乘级\nfactorial\n999\n\n\n\n 总结\n 三. 🏫Master定理\n// TODO\n 四. 🔒数据结构\n// TODO\n 五. 💻算法\n// TODO\n 📘Reference\n\n\n\n源自: https://en.wikipedia.org/wiki/Big_O_notation ↩︎\n\n\n\n","slug":"笔记/笔记-ADE-算法数据结构和效率","date":"2024-05-25T00:42:20.000Z","categories_index":"笔记","tags_index":"Notes,Algorithm,Data Structure,Big Oh","author_index":"zExNocs"},{"id":"d681443dee58dcfb94dec12db90a9a0d","title":"随笔日记导航","content":" 随笔\n 娱乐类随笔\n\n梗图\n记录网友怪话\n\n 技术类随笔\n\n让Hexo支持KaTeX和emoji\n\n\n 日记\n","slug":"导航/导航-随笔日记导航","date":"2024-05-25T00:15:32.000Z","categories_index":"导航","tags_index":"Diary,Essay","author_index":"zExNocs"},{"id":"c9fd788a84f48b02fed840451084249f","title":"笔记导航","content":" 按照年份分类\n Y3\n\nADE - 算法数据结构和效率 : 有关算法效率分析的课题笔记，包括Big-Oh家族、Master定理和部分算法与数据结构的算法分析。\n\n","slug":"导航/导航-笔记导航","date":"2024-05-24T21:25:57.000Z","categories_index":"导航","tags_index":"Notes","author_index":"zExNocs"},{"id":"625e3e920d4d18f0b54366f772b38b35","title":"语言学习导航","content":"","slug":"导航/导航-语言学习导航","date":"2024-05-24T17:44:53.000Z","categories_index":"导航","tags_index":"Languaue","author_index":"zExNocs"},{"id":"f2a68e25ffce8d6b8f475f30117ea7f4","title":"算法和数据结构导航","content":" 算法\n 数据结构\n","slug":"导航/导航-算法和数据结构导航","date":"2024-05-24T17:43:22.000Z","categories_index":"导航","tags_index":"Algorithm,Data Structure","author_index":"zExNocs"}]